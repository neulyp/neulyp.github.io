<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 深入理解JVM笔记三 · lyp's blog</title><meta name="description" content="深入理解JVM笔记三 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="lyp's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/neulyp/" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">深入理解JVM笔记三</h1><div class="post-info">Oct 21, 2016</div><div class="post-content"><p>内存分配策略</p>
<p>###1.对象有现在eden区分配。</p>
<p>大多数情况下，对象在新生代eden区中分配，当Eden区没有足够的空间分配，虚拟机将发起一次minor GC。<br>虚拟机提供<code>-XX：+PrintGCDetails</code>这个日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并在进程退出的时候输出当前的内存各区域分配的情况。</p>
<pre><code>public class aa{
        /**
         * -verbose:gc -Xms20M -Xms20M -Xmn10M -XX:+PrintGCDetails 
         * -XX:SurvivorRatio=8
         * 
         */
public static final int _1MB =1024*1024;
        public static void main(String[] args) {

            byte[] allocation1,allocation2,allocation3,allocation4;
            allocation1= new byte[2*_1MB];
            allocation2= new byte[2*_1MB];
            allocation3= new byte[2*_1MB];
            allocation4= new byte[3*_1MB];
        }
}
[GC (Allocation Failure) [PSYoungGen: 7128K-&gt;648K(9216K)] 7128K-&gt;6800K(19456K), 0.0030424 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (Ergonomics) [PSYoungGen: 648K-&gt;0K(9216K)] [ParOldGen: 6152K-&gt;6673K(27648K)] 6800K-&gt;6673K(36864K), [Metaspace: 2654K-&gt;2654K(1056768K)], 0.0070118 secs] [Times: user=0.06 sys=0.00, real=0.01 secs] 
Heap
 PSYoungGen      total 9216K, used 3154K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 38% used [0x00000000ff600000,0x00000000ff914930,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
 ParOldGen       total 27648K, used 6673K [0x0000000081c00000, 0x0000000083700000, 0x00000000ff600000)
  object space 27648K, 24% used [0x0000000081c00000,0x0000000082284408,0x0000000083700000)
 Metaspace       used 2660K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 288K, capacity 386K, committed 512K, reserved 1048576K
</code></pre><p>###2.对象直接进入老年代</p>
<p>虚拟机提供一个-XX:pertenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在eden取以及两个survivor区之间发生大量的内存复制。（新生代采用复制算法收集内存）</p>
<pre><code>public class aa{
        /**
         * -verbose:gc -Xms20M -Xms20M -Xmn10M -XX:+PrintGCDetails -XX:PertenureSizeThreshold=3145728
         * -XX:SurvivorRatio=8
         * 
         */
public static final int _1MB =1024*1024;
        public static void main(String[] args) {

            byte[] allocation4;
            allocation4= new byte[4*_1MB];
        }
}
</code></pre><p>###3.长期存活的对象将直接进入老年代</p>
<p>虚拟机给每个对象定义了一个age年龄计数器。如果对象在eden出生并经历了第一次minor gc仍然活着的话，并且能够被survivor容纳，警备移动大survivor空间，并且对象的年龄设为1.对于survivor中没熬过一次minor gc，年龄就增加1.当她的年龄增加到一定程度，默认是15，就会被净胜到老年代。对象净胜到老年代的年龄阈值通过参数-XX:MaxTenuringThreshold设置。</p>
<p>###4.动态对象年龄判定</p>
<p>为了更好地适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到阈值才能够到老年代，瑞国survivor中相同年龄所有对象的大小纸盒大于survivor空间的一般，年龄大于或等于改年龄的对象就可以进入老年代了。</p>
<p>###5.空间分配担保</p>
<p>在发生minor gc之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果这个条件成立，那么minor gc可以确保是安全的。如果不成立，虚拟机会查看handlepromotionfailure设置值食肉允许担保失败，如果允许，那么就会继续检查老年代中最大可用连续空间时都大于历次净胜到老年代对象的平均大小。如果大于，将尝试着进行一次minor gc，尽管这次minor gc是有风险的。如果小于，或者handlepromotionfailure设置不允许毛线，那么就要改为进行一次full gc。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/10/21/深入理解JVM笔记四/" class="prev">PREV</a><a href="/2016/10/19/深入理解JVM笔记二/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>