<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Spring_AOP源码分析 | lyp's blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Spring_AOP源码分析</h1><a id="logo" href="/.">lyp's blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Spring_AOP源码分析</h1><div class="post-meta">Nov 3, 2016<span> | </span><span class="category"><a href="/categories/javaweb/">javaweb</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><h1 id="Spring-AOP-源码分析"><a href="#Spring-AOP-源码分析" class="headerlink" title="Spring AOP 源码分析"></a>Spring AOP 源码分析</h1><h2 id="零-Spring-aop的使用"><a href="#零-Spring-aop的使用" class="headerlink" title="零.Spring aop的使用"></a>零.Spring aop的使用</h2><p>想要分析aop源码。总要先知道spring aop怎么使用吧。要不然，分析个orz…</p>
<p>使用Spring AOP可以基于两种方式，一种是比较方便和强大的注解方式，另一种则是中规中矩的xml配置方式。</p>
<h3 id="0-1-基于注解的使用"><a href="#0-1-基于注解的使用" class="headerlink" title="0.1 基于注解的使用"></a>0.1 基于注解的使用</h3><p>第一步xml配置：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd
    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;

    &lt;!-- 激活组件扫描功能,在包cn.ysh.studio.spring.aop及其子包下面自动扫描通过注解配置的组件 --&gt;
    &lt;context:component-scan base-package=&quot;cn.ysh.studio.spring.aop&quot;/&gt;
    &lt;!-- 激活自动代理功能 --&gt;
    &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;

    &lt;!-- 用户服务对象 --&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;cn.ysh.studio.spring.aop.service.UserService&quot; /&gt;

&lt;/beans&gt;
</code></pre><p>第二步是为Aspect切面类添加注解：</p>
<!--lang: java--> 
<pre><code>@Component
//声明这是一个切面Bean
@Aspect
public class ServiceAspect {

    private final static Log log = LogFactory.getLog(ServiceAspect.class);

    //配置切入点,该方法无方法体,主要为方便同类中其他方法使用此处配置的切入点
    @Pointcut(&quot;execution(* cn.ysh.studio.spring.aop.service..*(..))&quot;)
    public void aspect(){    }

    /*
     * 配置前置通知,使用在方法aspect()上注册的切入点
     * 同时接受JoinPoint切入点对象,可以没有该参数
     */
    @Before(&quot;aspect()&quot;)
    public void before(JoinPoint joinPoint){
        if(log.isInfoEnabled()){
            log.info(&quot;before &quot; + joinPoint);
        }
    }

    //配置后置通知,使用在方法aspect()上注册的切入点
    @After(&quot;aspect()&quot;)
    public void after(JoinPoint joinPoint){
        if(log.isInfoEnabled()){
            log.info(&quot;after &quot; + joinPoint);
        }
    }

    //配置环绕通知,使用在方法aspect()上注册的切入点
    @Around(&quot;aspect()&quot;)
    public void around(JoinPoint joinPoint){
        long start = System.currentTimeMillis();
        try {
            ((ProceedingJoinPoint) joinPoint).proceed();
            long end = System.currentTimeMillis();
            if(log.isInfoEnabled()){
                log.info(&quot;around &quot; + joinPoint + &quot;\tUse time : &quot; + (end - start) + &quot; ms!&quot;);
            }
        } catch (Throwable e) {
            long end = System.currentTimeMillis();
            if(log.isInfoEnabled()){
                log.info(&quot;around &quot; + joinPoint + &quot;\tUse time : &quot; + (end - start) + &quot; ms with exception : &quot; + e.getMessage());
            }
        }
    }

    //配置后置返回通知,使用在方法aspect()上注册的切入点
    @AfterReturning(&quot;aspect()&quot;)
    public void afterReturn(JoinPoint joinPoint){
        if(log.isInfoEnabled()){
            log.info(&quot;afterReturn &quot; + joinPoint);
        }
    }

    //配置抛出异常后通知,使用在方法aspect()上注册的切入点
    @AfterThrowing(pointcut=&quot;aspect()&quot;, throwing=&quot;ex&quot;)
    public void afterThrow(JoinPoint joinPoint, Exception ex){
        if(log.isInfoEnabled()){
            log.info(&quot;afterThrow &quot; + joinPoint + &quot;\t&quot; + ex.getMessage());
        }
    }

}
</code></pre><!---> 

第三步测试：

    public class Tester {

        private final static Log log = LogFactory.getLog(Tester.class);

        public static void main(String[] args) {
            //启动Spring容器
            ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
            //获取service组件
            UserService service = (UserService) context.getBean("userService");
            //以普通的方式调用UserService对象的三个方法
            User user = service.get(1L);
            service.save(user);
            try {
                service.delete(1L);
            } catch (Exception e) {
                if(log.isWarnEnabled()){
                    log.warn("Delete user : " + e.getMessage());
                }
            }
        }
    }

### 0.2 xml配置 ###

    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:context="http://www.springframework.org/schema/context"
        xmlns:aop="http://www.springframework.org/schema/aop"
        xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd
            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd">


        <!-- 系统服务组件的切面Bean -->
<pre><code>    &lt;bean id=&quot;serviceAspect&quot; class=&quot;cn.ysh.studio.spring.aop.aspect.ServiceAspect&quot;/&gt;
    &lt;!-- AOP配置 --&gt;
    &lt;aop:config&gt;
        &lt;!-- 声明一个切面,并注入切面Bean,相当于@Aspect --&gt;
        &lt;aop:aspect id=&quot;simpleAspect&quot; ref=&quot;serviceAspect&quot;&gt;
            &lt;!-- 配置一个切入点,相当于@Pointcut --&gt;
            &lt;aop:pointcut expression=&quot;execution(* cn.ysh.studio.spring.aop.service..*(..))&quot; id=&quot;simplePointcut&quot;/&gt;
            &lt;!-- 配置通知,相当于@Before、@After、@AfterReturn、@Around、@AfterThrowing --&gt;
            &lt;aop:before pointcut-ref=&quot;simplePointcut&quot; method=&quot;before&quot;/&gt;
            &lt;aop:after pointcut-ref=&quot;simplePointcut&quot; method=&quot;after&quot;/&gt;
            &lt;aop:after-returning pointcut-ref=&quot;simplePointcut&quot; method=&quot;afterReturn&quot;/&gt;
            &lt;aop:after-throwing pointcut-ref=&quot;simplePointcut&quot; method=&quot;afterThrow&quot; throwing=&quot;ex&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre><p>AOP用起来还是很简单的。就把xml配置好就算完工了。有Advisor和aspect两种方式来完成。如果是用Advisor的话需要实现AfterReturningAdvice，MethodBeforeAdvice，ThrowsAdvice等接口。而如果用aspect的话则不用继承或者实现其他的类，一个普通的类即可。</p>
<h2 id="一．AOP介绍"><a href="#一．AOP介绍" class="headerlink" title="一．AOP介绍"></a>一．AOP介绍</h2><p>软件开发经历了从汇编语言到高级语言和从过程化编程到面向对象编程；前者是为了提高开发效率，而后者则使用了归纳法，把具有共性的东西进行归类并使之模块化，达到便于维护和扩展的目的；如果说面向对象编程可以对业务需求进行很好的分解使之模块化；那么面向切面编程AOP（Aspect-Oriented Programming）则可以对系统需求进行很好的模软件开发经历了从汇编语言到高级语言和从过程化编程到面向对象编程；前者是为了提高开发效率，而后者则使用了归纳法，把具有共性的东西进行归类并使之模块化，达到便于维护和扩展的目的；如果说面向对象编程可以对业务需求进行很好的分解使之模块化；那么面向切面编程AOP（Aspect-Oriented Programming）则可以对系统需求进行很好的模块组织，简化系统需求和实现之间的对比关系，是对OOP思想的一种补充；块组织，简化系统需求和实现之间的对比关系，是对OOP思想的一种补充。</p>
<p>举个例子来说明一下吧！现在系统中有很多的业务方法，如上传产品信息、修改产品信息、发布公司库等；现在需要对这些方法的执行做性能监控，看每个业务方法的执行时间；在不改变原业务代码的基础上，也许我们会这么做。</p>
<p>Offer接口：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public interface IOffer {
    public void postOffer();
    public void modifyOffer();
}
</code></pre><p>Offer实现：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public class OfferImpl implements IOffer {
    public void postOffer() {
        System.out.println(&quot;post offer&quot;);
    }

    public void modifyOffer() {
        System.out.println(&quot;modify offer&quot;);
    }
}
</code></pre><p>工具类：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public class PerformanceUtil {
    public static long start=0;
    public static long end=0;
    public static void startPerformance(){
        start=System.currentTimeMillis();
    }
    public static void endPerformance(){
        end=System.currentTimeMillis();
        System.out.println(&quot;method use:&quot;+(end-start));
    }
}
</code></pre><p>Offer代理：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public class OfferProxy implements IOffer {

    private IOffer delegate;

    public OfferProxy(IOffer delegate){
        this.delegate=delegate;
    }
    public void postOffer() {
        PerformanceUtil.startPerformance();
        delegate.postOffer();
        PerformanceUtil.endPerformance();
    }

    public void modifyOffer() {
        PerformanceUtil.startPerformance();
        delegate.modifyOffer();
        PerformanceUtil.endPerformance();
    }

}
</code></pre><p>Offer测试：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public class TestProxy {
    public static void main(String[] args) {
        IOffer offer= new OfferProxy(new OfferImpl());
        offer.postOffer();
        offer.modifyOffer();
    }
}
</code></pre><p>输出：</p>
<pre><code>post offer
method use:1
modify offer
method use:0
</code></pre><p>上面的例子中，OfferProxy实现了IOffer，而所有的业务实现均委托给其成员offer；可以想像，这应该就是最简单的AOP的实现了；但这种方式会存在一个问题：如果有非常多的这种业务对象需要性能监控，我们就需要写同样多的XyzProxy来满足需求，这也是非常巨大的工作量。</p>
<h2 id="二．-代理模式"><a href="#二．-代理模式" class="headerlink" title="二．    代理模式"></a>二．    代理模式</h2><p>代理模式中，存在一个称为ProxyObject的代理对象和RealObject的真实对象，它们都实现了相同的接口；在调用的地方持有ProxyObject的实例，当调用request()方法时，ProxyObject可以在执行RealObject.request()前后做一些特定的业务，甚至不调用RealObject.request()方法。</p>
<p>目前实现代理模式的方式有两种：基于JDK的动态代理和基于CGLIB字节码的代理。</p>
<h3 id="2-1-JDK动态代理"><a href="#2-1-JDK动态代理" class="headerlink" title="2.1 JDK动态代理"></a>2.1 JDK动态代理</h3><p>JDK动态代理，顾名思义，是基于JDK的反射(reflect)机制；在JDK中，提供了InvocationHandler这个接口。</p>
<p>注释如下：</p>
<pre><code>InvocationHandler is the interface implemented by the invocation handler of a proxy instance.
Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.
</code></pre><p>意思是说：该接口由被代理对象的handler所实现；当调用代理对象的方法时，该方法调用将被编码，然后交给代理对象的invoke方法去执行。<br>因此上面的代码可以改写成如下所示：</p>
<p>实现：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyFactory implements InvocationHandler {
    private Object delegate;

    public Object bind(Object delegate){
        this.delegate= delegate;
        return Proxy.newProxyInstance(delegate.getClass().getClassLoader(), 
                delegate.getClass().getInterfaces(), this);
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        PerformanceUtil.startPerformance();
        Object result=null;
        try {
            result=method.invoke(delegate, args);
        } catch (Exception e) {
            // TODO: handle exceptions
        }
        PerformanceUtil.endPerformance();
        return result;
    }

}
</code></pre><p>测试：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public class TestJDKProxy {
    public static void main(String[] args) {
        IOffer offer = (IOffer) new ProxyFactory().bind(new OfferImpl());
        offer.postOffer();
        offer.modifyOffer();
    }
}
</code></pre><p>结果：</p>
<pre><code>post offer
method use:1
modify offer
method use:0
</code></pre><p>通过这种方式，你不需要为针对每一个业务写一个代理对象，就可以很轻松地完成你的需求；但也许你已经注意到了，JDK的动态代理，在创建代理对象(上面红色代码部分)时，被代理的对象需要实现接口(即面向接口编程)；</p>
<h3 id="2-2CGLIB代理方式"><a href="#2-2CGLIB代理方式" class="headerlink" title="2.2CGLIB代理方式"></a>2.2CGLIB代理方式</h3><p>如果目标对象没有实现任何接口，那怎么办呢？不用担心，你可以用CGLIB来实现代理。</p>
<p>实现：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

import java.lang.reflect.Method;

import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;


public class CglibProxyFactory  implements MethodInterceptor{

    private Object delegate;

    public Object bind(Object delegate){
        this.delegate=delegate;
        Enhancer enhancer= new Enhancer();
        enhancer.setSuperclass(delegate.getClass());
        enhancer.setCallback(this);
        return enhancer.create();
    }
    public Object intercept(Object object, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        PerformanceUtil.startPerformance();
        Object o =proxy.invoke(this.delegate, args);
        PerformanceUtil.endPerformance();
        return o;
    }

}
</code></pre><p>测试类：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public class TestCglibProxy {
    public static void main(String[] args) {
        DefaultOffer defaultOffer= (DefaultOffer) new CglibProxyFactory().bind(new DefaultOffer());
        defaultOffer.postOffer();
        defaultOffer.modifyOffer();
    }
}
</code></pre><p>测试结果：</p>
<pre><code>post offer
method use:20
modify offer
method use:0
</code></pre><p>使用CGLIB创建的代理对象，其实就是继承了要代理的目标类，然后对目标类中所有非final方法进行覆盖，但在覆盖方法时会添加一些拦截代码(上面CglibProxyFactory类中的intercept方法)。</p>
<h2 id="三．-Spring-AOP-实现"><a href="#三．-Spring-AOP-实现" class="headerlink" title="三．    Spring AOP 实现"></a>三．    Spring AOP 实现</h2><h3 id="3-1-Spring-AOP-几个基本概念"><a href="#3-1-Spring-AOP-几个基本概念" class="headerlink" title="3.1 Spring AOP 几个基本概念"></a>3.1 Spring AOP 几个基本概念</h3><p>Spring AOP jar包：<strong>spring-aop-4.2.5.release.jar</strong></p>
<p>Spring AOP中的几个基本概念，每次学习AOP都被这几个概念折腾的很不爽，我们在这里再把这几个概念描述一遍，力争把这几个概念搞清，在每次review这块内容的时候可以很快上手。</p>
<ol>
<li>切面(Aspect)：切面就是一个关注点的模块化，如事务管理、日志管理、权限管理等；</li>
<li>连接点(Joinpoint)：程序执行时的某个特定的点，在Spring中就是一个方法的执行；</li>
<li>通知(Advice)：通知就是在切面的某个连接点上执行的操作，也就是事务管理、日志管理等；</li>
<li>切入点(Pointcut)：切入点就是描述某一类选定的连接点，也就是指定某一类要织入通知的方法；</li>
<li>目标对象(Target)：就是被AOP动态代理的目标对象；</li>
</ol>
<p>用一张图来形象地表达AOP的概念及其关系如下：</p>
<p><img src="http://i.imgur.com/SoF1QtC.png" alt=""></p>
<h3 id="3-2-Spring-AOP-中切入点、通知、切面的实现"><a href="#3-2-Spring-AOP-中切入点、通知、切面的实现" class="headerlink" title="3.2 Spring AOP 中切入点、通知、切面的实现"></a>3.2 Spring AOP 中切入点、通知、切面的实现</h3><p>理解了上面的几个概念后，我们分别来看看Spring AOP是如何实现这些概念的；</p>
<h4 id="3-2-1-切入点-Pointcut"><a href="#3-2-1-切入点-Pointcut" class="headerlink" title="3.2.1.切入点(Pointcut)"></a>3.2.1.切入点(Pointcut)</h4><p>它定义了哪些连接点需要被织入横切逻辑；在Java中，连接点对应哪些类(接口)的方法。因此，我们都能猜到，所谓的切入点，就是定义了匹配哪些娄的哪些方法的一些规则，可以是静态的基于类(方法)名的值匹配，也可以是基于正则表达式的模式匹配。</p>
<p>来看看Spring AOP Pointcut相关的类图：</p>
<p><img src="http://i.imgur.com/0Fpm5dB.png" alt=""></p>
<p>在Pointcut接口的定义中，也许你已经想到了，ClassFilter是类过滤器，它定义了哪些类名需要拦截；典型的两个实现类为TypePatternClassFilter和TrueClassFilter(所有类均匹配)；而MethodMatcher为方法匹配器，定义哪些方法需要拦截。</p>
<p>在上面的类图中：</p>
<ul>
<li>StaticMethodMatch与DynamicMethodMatch的区别是后者在运行时会依据方法的参数值进行匹配。</li>
<li>NameMatchMethodPointCut根据指定的mappedNames来匹配方法。</li>
<li>AbstractRegexpMethodPointCut根据正则表达式来匹配方法</li>
</ul>
<p>类图中部分代码实现：</p>
<p>MethodMatcher.class:</p>
<pre><code>package org.springframework.aop;

import java.lang.reflect.Method;

public abstract interface MethodMatcher {
    public static final MethodMatcher TRUE = TrueMethodMatcher.INSTANCE;

    public abstract boolean matches(Method paramMethod, Class&lt;?&gt; paramClass);

    public abstract boolean isRuntime();

    public abstract boolean matches(Method paramMethod, Class&lt;?&gt; paramClass, Object[] paramArrayOfObject);
}
</code></pre><p>StaticMethodMatcher.class:</p>
<pre><code>package org.springframework.aop.support;

import java.lang.reflect.Method;
import org.springframework.aop.MethodMatcher;

public abstract class StaticMethodMatcher implements MethodMatcher {
    public final boolean isRuntime() {
        return false;
    }

    public final boolean matches(Method method, Class&lt;?&gt; targetClass, Object[] args) {
        throw new UnsupportedOperationException(&quot;Illegal MethodMatcher usage&quot;);
    }
}
</code></pre><p>DynamicMethodMatcher.class:</p>
<pre><code>package org.springframework.aop.support;

import java.lang.reflect.Method;
import org.springframework.aop.MethodMatcher;

public abstract class DynamicMethodMatcher implements MethodMatcher {
    public final boolean isRuntime() {
        return true;
    }

    public boolean matches(Method method, Class&lt;?&gt; targetClass) {
        return true;
    }
}
</code></pre><p>Pointcut.class:</p>
<pre><code>package org.springframework.aop;

public abstract interface Pointcut {
    public static final Pointcut TRUE = TruePointcut.INSTANCE;

    public abstract ClassFilter getClassFilter();

    public abstract MethodMatcher getMethodMatcher();
}
</code></pre><h4 id="3-2-2-通知-Advice"><a href="#3-2-2-通知-Advice" class="headerlink" title="3.2.2.通知(Advice)"></a>3.2.2.通知(Advice)</h4><p>通知定义了具体的横切逻辑。在Spring中，存在两种类型的Advice，即per-class和per-instance的Advice。</p>
<p>所谓per-class，即该类型的Advice只提供方法拦截，不会为目标对象保存任何状态或者添加新的特性，它也是我们最常见的Advice。下面是per-class的类图：</p>
<p><img src="http://i.imgur.com/tGVnfQi.png" alt=""></p>
<ul>
<li>BeforeAdvice：在连接点前执行的横切逻辑。</li>
<li>AfterReturningAdvice：在连接点执行后，再执行横切逻辑。</li>
<li>AfterAdvice：一般由程序自己实现，当抛出异常后，执行横切逻辑。</li>
<li>AroundAdvice：Spring AOP中并没有提供这个接口，而是采用了AOP Alliance的MethodInteceptor接口；通过看AfterReturningAdvice的源码我们知道，它是不能更改连接点所在方法的返回值的(更改引用)；但使用的MethodInteceptor，所有的事情，都不在话下。</li>
</ul>
<p>部分源码介绍：</p>
<p>AfterAdvice,Advice两个接口是空的</p>
<p>AfterReturningAdvice.class</p>
<pre><code>package org.springframework.aop;

import java.lang.reflect.Method;

public abstract interface AfterReturningAdvice extends AfterAdvice {
    public abstract void afterReturning(Object paramObject1, Method paramMethod, Object[] paramArrayOfObject,
            Object paramObject2) throws Throwable;
}
</code></pre><p>MethodBeforeAdvice.class</p>
<pre><code>import java.lang.reflect.Method;

public abstract interface MethodBeforeAdvice extends BeforeAdvice {
    public abstract void before(Method paramMethod, Object[] paramArrayOfObject, Object paramObject) throws Throwable;
}
</code></pre><p>MethodInterceptor.class</p>
<pre><code>package org.aopalliance.intercept;

public abstract interface MethodInterceptor extends Interceptor {
    public abstract Object invoke(MethodInvocation paramMethodInvocation) throws Throwable;
}
</code></pre><p>在上面的类图中，还有两种类没有介绍，那就是 <strong><em>AdviceAdapter 和 </em></strong>AdviceInteceptor.结构如图所示<br><img src="http://i.imgur.com/0ooNuhA.png" alt=""></p>
<p>我们以AfterReturningAdviceInterceptor为例来说明：</p>
<pre><code>package org.springframework.aop.framework.adapter;

import java.io.Serializable;
import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.springframework.aop.AfterAdvice;
import org.springframework.aop.AfterReturningAdvice;
import org.springframework.util.Assert;

public class AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice, Serializable {
    private final AfterReturningAdvice advice;

    public AfterReturningAdviceInterceptor(AfterReturningAdvice advice) {
        Assert.notNull(advice, &quot;Advice must not be null&quot;);
        this.advice = advice;
    }

    public Object invoke(MethodInvocation mi) throws Throwable {
        Object retVal = mi.proceed();
        this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());
        return retVal;
    }
}
</code></pre><p>该类实现了MethodInterceptor和AfterAdvice接口，同时构造函数中还有一个AfterReturningAdvice实例的参数；这个类存在的作用是为了什么呢？Spring AOP把所有的Advice都适配成了MethodInterceptor，统一的好处是方便后面横切逻辑的执行(参看下一节)，适配的工作即由<em>*</em>AdviceAdapter完成；</p>
<p>Spring AOP所谓的AfterReturningAdvice，通过适配成MethodInterceptor后，其实就是在invoke方法中，先执行目标对象的方法，再执行的AfterReturningAdvice所定义的横切逻辑。</p>
<p>对于per-instance的Advice，目前只有一种实现，就是Introduction，使用的场景比较少。</p>
<p><img src="http://i.imgur.com/EmLqrLw.png" alt=""></p>
<h4 id="3-2-3-切面-Aspect"><a href="#3-2-3-切面-Aspect" class="headerlink" title="3.2.3.切面(Aspect)"></a>3.2.3.切面(Aspect)</h4><p>在Spring中，Advisor就是切面；但与通常的Aspect不同的是，Advisor通常只有一个Pointcut和一个Advice，而Aspect则可以包含多个Pointcut和多个Advice，因此Advisor是一种特殊的Aspect。</p>
<p>接下来看下per-class Advisor的类图：</p>
<p><img src="http://i.imgur.com/rELgifs.png" alt=""></p>
<p>继承关系如下：</p>
<p><img src="http://i.imgur.com/oSYJlw4.png" alt=""></p>
<p>Advisor包含一个Pointcut和一个Advisor；在AbstractGenericPointcutAdvisor中，持有一个Advice的引用；下面的几个实现，均是针对前面提到的几种不同的Pointcut的实现。</p>
<h3 id="3-3-Spring-AOP实现基本线索"><a href="#3-3-Spring-AOP实现基本线索" class="headerlink" title="3.3 Spring AOP实现基本线索"></a>3.3 Spring AOP实现基本线索</h3><p>我们选择ProxyFactoryBean作为入口点和分析的开始。ProxyFactoryBean是在Spring IoC环境中，创建AOP应用的最底层方法，从中，可以看到一条实现AOP的基本线索。</p>
<p>所有的逻辑从以下的方法开始,我们主要针对单例的代理对象的生成：</p>
<pre><code>public Object getObject() throws BeansException {
    //这里初始化通知器链
    initializeAdvisorChain();
    if (isSingleton()) {
        //根据定义需要生成单例的proxy
        return getSingletonInstance();
    }

    if (this.targetName == null) {
        this.logger.warn(
                &quot;Using non-singleton proxies with singleton targets is often undesirable. Enable prototype proxies by setting the &apos;targetName&apos; property.&quot;);
    }
    //这里根据定义需要生成prototype类型的proxy
    return newPrototypeInstance();
}
</code></pre><p>下面我们深入到SpringAOP核心代码的内部，看看代理对象的生成机制，拦截器横切逻辑以及织入的实现。</p>
<pre><code>private synchronized Object getSingletonInstance() {
        if (this.singletonInstance == null) {
            //返回具体的目标对象，就是被代理的对象
            this.targetSource = freshTargetSource();
            if ((this.autodetectInterfaces) &amp;&amp; (getProxiedInterfaces().length == 0) &amp;&amp; (!(isProxyTargetClass()))) {
                //从targetsource中获取目标对象的class
                Class targetClass = getTargetClass();
                if (targetClass == null) {
                    throw new FactoryBeanNotInitializedException(&quot;Cannot determine target class for proxy&quot;);
                }
                //这里设置代理对象的借口
                setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader));
            }
            //这里使用proxyfactory来生成我们需要的proxy。
            super.setFrozen(this.freezeProxy);
            this.singletonInstance = getProxy(createAopProxy());
        }
        return this.singletonInstance;
    }
</code></pre><p>ProxyFactoryBean是AdvisedSupport的子类，Spring使用AopProxy接口把AOP代理的实现与框架的其他部分分离开来。在AdvisedSupport中通过这样的方式来得到AopProxy,当然这里需要得到AopProxyFactory的帮助 ，从JDK或者cglib中得到想要的代理对象：</p>
<pre><code>protected final synchronized AopProxy createAopProxy() {
        if (!(this.active)) {
            activate();
        }
        return getAopProxyFactory().createAopProxy(this);
    }
</code></pre><p>getAopProxyFactory()获取ProxyCreatorSupport的属性aopProxyFactory</p>
<pre><code>public AopProxyFactory getAopProxyFactory() {
        return this.aopProxyFactory;
    }
</code></pre><p>该属性被默认初始化为DefaultAopProxyFactory对象。</p>
<pre><code>public ProxyCreatorSupport() {
    this.aopProxyFactory = new DefaultAopProxyFactory();
}
public ProxyCreatorSupport(AopProxyFactory aopProxyFactory) {
        Assert.notNull(aopProxyFactory, &quot;AopProxyFactory must not be null&quot;);
        this.aopProxyFactory = aopProxyFactory;
    }
</code></pre><p>这个DefaultAopProxyFactory是Spring用来生成AopProxy的地方，它包含JDK和Cglib两种实现方式。让我接着往里面看：</p>
<pre><code>/*** Eclipse Class Decompiler plugin, copyright (c) 2016 Chen Chao (cnfree2000@hotmail.com) ***/
package org.springframework.aop.framework;

import java.io.Serializable;
import java.lang.reflect.Proxy;
import org.springframework.aop.SpringProxy;

public class DefaultAopProxyFactory implements AopProxyFactory, Serializable {
    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
        //做一些判断操作。isoptimize（）是指是否采取进一步的优化，true采用cglib来生成代理。
        //isproxytargetclass决定是否采用基于接口的代理。
        if ((config.isOptimize()) || (config.isProxyTargetClass()) || (hasNoUserSuppliedProxyInterfaces(config))) {
            Class targetClass = config.getTargetClass();
            if (targetClass == null) {
                throw new AopConfigException(
                        &quot;TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.&quot;);
            }
            //如果目标对象实现的接口，则采用jdk动态代理来生成proxy
            if ((targetClass.isInterface()) || (Proxy.isProxyClass(targetClass))) {
                return new JdkDynamicAopProxy(config);
            }
            //如果target不是接口的实现的话，返回cglib类型的aopproxy
            return new ObjenesisCglibAopProxy(config);
        }
        //不满足最开始的判断 直接使用jdk动态代理
        return new JdkDynamicAopProxy(config);
    }

    private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) {
        Class[] ifcs = config.getProxiedInterfaces();
        return ((ifcs.length == 0) || ((ifcs.length == 1) &amp;&amp; (SpringProxy.class.isAssignableFrom(ifcs[0]))));
    }
}
</code></pre><p>可以看到其中的代理对象可以由JDK或者Cglib来生成，JdkDynamicAopProxy类和Cglib2AopProxy都实现的是AopProxy的接口，我们进入JdkDynamicAopProxy实现中看看Proxy是怎样生成的：</p>
<pre><code>public JdkDynamicAopProxy(AdvisedSupport config) throws AopConfigException {
        Assert.notNull(config, &quot;AdvisedSupport must not be null&quot;);
        if ((config.getAdvisors().length == 0) &amp;&amp; (config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE)) {
            throw new AopConfigException(&quot;No advisors and no TargetSource specified&quot;);
        }
        this.advised = config;
    }

    public Object getProxy() {
        return getProxy(ClassUtils.getDefaultClassLoader());
    }

    public Object getProxy(ClassLoader classLoader) {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + this.advised.getTargetSource());
        }
        //根据advised中的配置信息，获取proxy需要代理的接口、放入proxiedInterfaces中。
        Class[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised);
        findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
        //这里我们调用jdk proxy 来生成需要的proxy实例
        return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
    }
</code></pre><p>再来看cglib代理</p>
<pre><code>class ObjenesisCglibAopProxy extends CglibAopProxy {
    private static final Log logger = LogFactory.getLog(ObjenesisCglibAopProxy.class);

    private static final SpringObjenesis objenesis = new SpringObjenesis();

    public ObjenesisCglibAopProxy(AdvisedSupport config) {
        super(config);
    }

    protected Object createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks) {
        Class proxyClass = enhancer.createClass();
        Object proxyInstance = null;

        if (objenesis.isWorthTrying()) {
            try {
                proxyInstance = objenesis.newInstance(proxyClass, enhancer.getUseCache());
            } catch (Throwable ex) {
                logger.debug(&quot;Unable to instantiate proxy using Objenesis, falling back to regular proxy construction&quot;,
                        ex);
            }

        }

        if (proxyInstance == null) {
            try {
                proxyInstance = (this.constructorArgs != null)
                        ? proxyClass.getConstructor(this.constructorArgTypes).newInstance(this.constructorArgs)
                        : proxyClass.newInstance();
            } catch (Throwable ex) {
                throw new AopConfigException(
                        &quot;Unable to instantiate proxy using Objenesis, and regular proxy instantiation via default constructor fails as well&quot;,
                        ex);
            }

        }

        ((Factory) proxyInstance).setCallbacks(callbacks);
        return proxyInstance;
    }
}
</code></pre><p>继承了CglibAopProxy。下面的和最开始的例子比较，是不是很熟悉。</p>
<pre><code>public Object getProxy(ClassLoader classLoader) {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Creating CGLIB proxy: target source is &quot; + this.advised.getTargetSource());
        }
        try {
            Class rootClass = this.advised.getTargetClass();
            Assert.state(rootClass != null, &quot;Target class must be available for creating a CGLIB proxy&quot;);

            Class proxySuperClass = rootClass;
            if (ClassUtils.isCglibProxyClass(rootClass)) {
                proxySuperClass = rootClass.getSuperclass();
                Class[] additionalInterfaces = rootClass.getInterfaces();
                for (Class additionalInterface : additionalInterfaces) {
                    this.advised.addInterface(additionalInterface);
                }

            }

            validateClassIfNecessary(proxySuperClass, classLoader);

            Enhancer enhancer = createEnhancer();
            if (classLoader != null) {
                enhancer.setClassLoader(classLoader);
                if ((classLoader instanceof SmartClassLoader)
                        &amp;&amp; (((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass))) {
                    enhancer.setUseCache(false);
                }
            }
            enhancer.setSuperclass(proxySuperClass);
            enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
            enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
            enhancer.setStrategy(new ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));

            Callback[] callbacks = getCallbacks(rootClass);
            Class[] types = new Class[callbacks.length];
            int k;
            for (int k = 0; k &lt; types.length; ++k) {
                types[k] = callbacks[k].getClass();
            }

            enhancer.setCallbackFilter(new ProxyCallbackFilter(this.advised.getConfigurationOnlyCopy(),
                    this.fixedInterceptorMap, this.fixedInterceptorOffset));
            enhancer.setCallbackTypes(types);

            return createProxyClassAndInstance(enhancer, callbacks);
        } catch (CodeGenerationException ex) {
            throw new AopConfigException(&quot;Could not generate CGLIB subclass of class [&quot; + this.advised.getTargetClass()
                    + &quot;]: &quot; + &quot;Common causes of this problem include using a final class or a non-visible class&quot;, ex);
        } catch (IllegalArgumentException ex) {
            throw new AopConfigException(&quot;Could not generate CGLIB subclass of class [&quot; + this.advised.getTargetClass()
                    + &quot;]: &quot; + &quot;Common causes of this problem include using a final class or a non-visible class&quot;, ex);
        } catch (Exception ex) {
            throw new AopConfigException(&quot;Unexpected AOP exception&quot;, ex);
        }
    }
</code></pre><p>用Proxy包装target之后，通过ProxyFactoryBean得到对其方法的调用就被Proxy拦截了， <strong><em>ProxyFactoryBean的getObject()方法得到的实际上是一个Proxy了，target对象已经被封装了。</em></strong>对 ProxyFactoryBean这个工厂bean而言，其生产出来的对象是封装了目标对象的代理对象。</p>
<h3 id="3-4拦截器的作用"><a href="#3-4拦截器的作用" class="headerlink" title="3.4拦截器的作用"></a>3.4拦截器的作用</h3><p>前面分析了SpringAOP实现中得到Proxy对象的过程，接下来我们去探寻Spring AOP中拦截器链是怎样被调用的，也就是Proxy模式是怎样起作用的。<br>还记得在JdkDynamicAopProxy中生成Proxy对象的时候，有一句这样的代码吗？</p>
<pre><code>return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
</code></pre><p>这里我们的JdkDynamicAopProxy实现了InvocationHandler这个接口，<code>final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable</code>.</p>
<p>this参数对应的是InvocationHandler对象,也就是说当 Proxy对象的函数被调用的时候，InvocationHandler的invoke方法会被作为回调函数调用.</p>
<p>我们来看一下动态代理中invoke函数的实现：</p>
<pre><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object oldProxy = null;
        boolean setProxyContext = false;

        TargetSource targetSource = this.advised.targetSource;
        Class targetClass = null;
        Object target = null;
        try {
            Object localObject1;
            //目标对象未实现equals方法
            if ((!(this.equalsDefined)) &amp;&amp; (AopUtils.isEqualsMethod(method))) {
                localObject1 = Boolean.valueOf(equals(args[0]));
                return localObject1;
            }
            //目标对象未实现hashcode方法
            if ((!(this.hashCodeDefined)) &amp;&amp; (AopUtils.isHashCodeMethod(method))) {
                localObject1 = Integer.valueOf(hashCode());
                return localObject1;
            }
            //opaque顺序控制生成代理对象是否可以强制转换类型为advised，默认为false。
            //z这里针对opaque为true且代理的为借口自身，并且代理类为advised借口的子接口，不进行代理操作。
            if ((!(this.advised.opaque)) &amp;&amp; (method.getDeclaringClass().isInterface())
                    &amp;&amp; (method.getDeclaringClass().isAssignableFrom(Advised.class))) {
            //这里就是目标对象的调用
                localObject1 = AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);
                return localObject1;
            }
            //设置exposeproxy为true，让springaop框架将生成的当前代理对象绑定到threadlocal
            if (this.advised.exposeProxy) {
                oldProxy = AopContext.setCurrentProxy(proxy);
                setProxyContext = true;
            }
            //这里是得到目标对象，目标对象可能来自一个示例池或者一个简单的java对象。
            target = targetSource.getTarget();
            if (target != null) {
                targetClass = target.getClass();
            }
            //重要！！！：：：这里获得定义好的拦截器链
            List chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
            Object retVal;
            Object retVal;
            //如果没有拦截器，直接调用目标的对象方法，不创建methodinvocation
            if (chain.isEmpty()) {
                Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
                retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
            } else {
                //如果有拦截器的设定，那么需要调用拦截器之后才能调用目标对象的相应的方法。
                //通过构造一个ReflectiveMethodInvocation来实现
                MethodInvocation invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass,
                        chain);
                //通过ReflectiveMethodInvocation来调用拦截器连和相应的目标方法。
                //在proceed方法内部实现了自身的递归调用来便利整个拦截器链。

                retVal = invocation.proceed();
            }

            Class returnType = method.getReturnType();
            if ((retVal != null) &amp;&amp; (retVal == target) &amp;&amp; (returnType.isInstance(proxy))
                    &amp;&amp; (!(RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())))) {
                retVal = proxy;
            } else if ((retVal == null) &amp;&amp; (returnType != Void.TYPE) &amp;&amp; (returnType.isPrimitive())) {
                throw new AopInvocationException(
                        &quot;Null return value from advice does not match primitive return type for: &quot; + method);
            }

            Object localObject2 = retVal;

            return localObject2;
        } finally {
            if ((target != null) &amp;&amp; (!(targetSource.isStatic()))) {
                //释放gettarget方法获取的target对象，和targetsource实现有关
                targetSource.releaseTarget(target);
            }
            if (setProxyContext) {
                AopContext.setCurrentProxy(oldProxy);
            }
        }
    }
</code></pre><p>上面所说的目标对象方法的调用，是通过AopUtils的方法调用，使用反射机制来对目标对象的方法进行的;</p>
<pre><code>public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) throws Throwable {
    try {
        ReflectionUtils.makeAccessible(method);
        return method.invoke(target, args);
    } catch (InvocationTargetException ex) {
        throw ex.getTargetException();
    } catch (IllegalArgumentException ex) {
        throw new AopInvocationException(&quot;AOP configuration seems to be invalid: tried calling method [&quot; + method
                + &quot;] on target [&quot; + target + &quot;]&quot;, ex);
    } catch (IllegalAccessException ex) {
        throw new AopInvocationException(&quot;Could not access method [&quot; + method + &quot;]&quot;, ex);
    }
}
</code></pre><p>接下来，我们来看具体的ReflectiveMethodInvocation中proceed()方法的实现，也就是拦截器链的实现机制：</p>
<pre><code>public Object proceed() throws Throwable {
        //重点！！！currentInterceptorIndex初始化值为-1，首先判断长度是否为0，为0直接调用目标对象的方法。
        if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {
            return invokeJoinpoint();
        }

        Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers
                .get(++this.currentInterceptorIndex);

        if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {
            //匹配逻辑，只要方法匹配就调用拦截器，不匹配，跳过这个拦截器，调用下一个。
            InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
            //需要注意一点，我们这里虽然反悔了，但是匹配到的拦截器自身的invoke方法还是会调用的，
            //继续遍历拦截器链
            if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {
                return dm.interceptor.invoke(this);
            }
            //没匹配， 调用下一个拦截器，重复上面逻辑
            return proceed();
        }
        //如果是MethodInterceptor，我们调用invoke方法，主要为了兼容原始aop联盟的东西，
        return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);
    }
</code></pre><p>从上面的分析我们看到了Spring AOP拦截机制的基本实现，比如Spring怎样得到Proxy，怎样利用JAVA Proxy以及反射机制对用户定义的拦截器链进行处理。</p>
<h3 id="3-5织入的实现"><a href="#3-5织入的实现" class="headerlink" title="3.5织入的实现"></a>3.5织入的实现</h3><p>在上面调用拦截器的时候，经过一系列的注册，适配的过程以后，拦截器在拦截的时候，会调用到预置好的一个通知适配器，设置通知拦截器，这是一系列Spring设计好为通知服务的类的一个，是最终完成通知拦截和实现的地方，例如对 MethodBeforeAdviceInterceptor的实现是这样的：</p>
<pre><code>public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable {
    private MethodBeforeAdvice advice;

    public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) {
        Assert.notNull(advice, &quot;Advice must not be null&quot;);
        this.advice = advice;
    }

    public Object invoke(MethodInvocation mi) throws Throwable {
        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());
        //这个invoke方法是拦截器的回调方法，会在代理对象的方法被调用的时候出发回调
        return mi.proceed();
    }
}
</code></pre><p>可以看到通知适配器将advice适配成Interceptor以后，会调用advice的before方法去执行横切逻辑。这样就成功的完成了before通知的织入。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/11/03/Spring-AOP源码分析/" data-id="ciyve3lrh000rakw06q630s8h" class="article-share-link">Aktie</a><div class="tags"><a href="/tags/spring/">spring</a></div><div class="post-nav"><a href="/2016/11/03/spring/" class="pre">spring</a><a href="/2016/10/28/数据仓库三种变化类型/" class="next">数据仓库三种变化类型</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/hadoop/">hadoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javaweb/">javaweb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java杂记/">java杂记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/juc/">juc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jvm/">jvm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">life</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/pat/">pat</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/poffer/">poffer</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tomact/">tomact</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据仓库/">数据仓库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/javaweb/" style="font-size: 15px;">javaweb</a> <a href="/tags/life/" style="font-size: 15px;">life</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/机器学习/" style="font-size: 15px;">机器学习</a> <a href="/tags/poffer/" style="font-size: 15px;">poffer</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/juc/" style="font-size: 15px;">juc</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/java杂记/" style="font-size: 15px;">java杂记</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/计算机网络/" style="font-size: 15px;">计算机网络</a> <a href="/tags/pat/" style="font-size: 15px;">pat</a> <a href="/tags/tomact/" style="font-size: 15px;">tomact</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/数据仓库/" style="font-size: 15px;">数据仓库</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/01/17/Poffer1/">poffer1</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/16/jvm-questions/">jvm-questions</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/16/network_TCP三次握手和四次挥手状态变迁解析/">network_tcp三次握手</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/14/jv-collections1-list/">jv_collections1-list</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/14/jv-collections1-hashmap/">jv_collections1-hashmap&hashset</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/13/network_tcp报文详解/">network_tcp报文详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/13/network_questions/">network_questions</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/13/network_1/">network_概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/13/jsp_questions/">jsp_questions</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/13/linux_command/">linux_commands</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="hellozjf.com" title="周靖峰" target="_blank">周靖峰</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">lyp's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>