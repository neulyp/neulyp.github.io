<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lyp&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-02-15T07:30:21.634Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Loren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ms2—mysql基准测试</title>
    <link href="http://yoursite.com/2017/02/15/ms2%E2%80%94-mysql%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2017/02/15/ms2—-mysql基准测试/</id>
    <published>2017-02-15T07:13:44.000Z</published>
    <updated>2017-02-15T07:30:21.634Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>基准测试是针对系统设计的一种压力测试。通常的目标是为了掌握系统的行为。</p>
<h3 id="为什么需要基准测试"><a href="#为什么需要基准测试" class="headerlink" title="为什么需要基准测试"></a>为什么需要基准测试</h3><p>基准测试是一种压力测试，是唯一方便有效的、可以学习系统在给定负载下会发生什么的一种方法。<br>基准测试的主要问题在于不是真实压力的测试，有很多因素会影响基准测试的准确度。<br>我们只能进行大概的测试，来确定系统大致的余量有多少。</p>
<h3 id="基准测试的策略"><a href="#基准测试的策略" class="headerlink" title="基准测试的策略"></a>基准测试的策略</h3><p>两种主要策略：针对整个系统（集成式）、单独测试MySQL（单组件式）。</p>
<p>测试指标<br>吞吐量：单位时间内的事务处理数<br>响应时间或延迟：任务所需的整体时间<br>并发性：任意时间内有多少同时发生的并发请求，主要关注的是正在工作中的并发操作，或者是同时工作中的线程数或连接数。<br>可扩展性：增加一倍的工作量，是否能获得两倍的效果；增加一倍的资源，是否能增加一倍的吞吐量。</p>
<h3 id="基准测试方法"><a href="#基准测试方法" class="headerlink" title="基准测试方法"></a>基准测试方法</h3><p>努力使测试过程更接近真实应用的情况。</p>
<p>设计和规划基准测试：<br>采用标准的基准测试，还是设计专用的基准测试。</p>
<p>基准测试应该运行多长时间：<br>应该运行足够长的时间，到系统的稳定状态。</p>
<p>获取系统性能和状态：<br>需要记录的数据包括系统状态和性能指标。</p>
<p>获得准确的测试结果</p>
<p>运行基准测试并分析结果：<br>要尽可能使所有测试过程自动化，包括装载数据，系统预热、执行测试，记录结果等。</p>
<h3 id="基准测试工具"><a href="#基准测试工具" class="headerlink" title="基准测试工具"></a>基准测试工具</h3><p>ab：apache http 服务器基准测试工具</p>
<p>http_load: web服务器测试</p>
<p>sysbench 是一款多线程系统压测工具。</p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;基准测试是针对系统设计的一种压力测试。通常的目标是为了掌握系统的行为。&lt;/p&gt;
&lt;h3 id=&quot;为什么需要基准测试&quot;&gt;&lt;a href=&quot;#为什么需要基准测试&quot; class=&quot;headerlink&quot; title=&quot;为什么需要基准测试&quot;&gt;&lt;/
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>ms1_mysql的架构和历史</title>
    <link href="http://yoursite.com/2017/02/07/ms1-mysql%E7%9A%84%E6%9E%B6%E6%9E%84%E5%92%8C%E5%8E%86%E5%8F%B2/"/>
    <id>http://yoursite.com/2017/02/07/ms1-mysql的架构和历史/</id>
    <published>2017-02-07T15:29:47.000Z</published>
    <updated>2017-02-15T07:12:43.942Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h3 id="1-MySQL逻辑架构"><a href="#1-MySQL逻辑架构" class="headerlink" title="1.MySQL逻辑架构"></a>1.MySQL逻辑架构</h3><p><img src="http://i.imgur.com/qMS43OR.png" alt=""></p>
<p>第一层的结构不是MySQL独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的结构，比如连接处理、授权认证、安全等。</p>
<p>第二层是Mysql中比较核心的部分。大多数的Mysql核心功能都在这一层。包括查询解析、分析、优化、缓存以及所有的内置函数，所有跨存储引擎的功能都在这一层实现，存储过程、触发器、视图等。</p>
<p>第三层包含了存储引擎。存储引擎负责Mysql中数据的存储和提取。服务器通过API与存储引擎进行通信，这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎包含几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作，但存储引擎不会去解析SQL语句（Innodb会解析外键定义），不同存储引擎之间也不会相互通信，只是简单的响应上层服务器的请求。</p>
<h3 id="2-并发控制"><a href="#2-并发控制" class="headerlink" title="2.并发控制"></a>2.并发控制</h3><h4 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h4><p>一般情况下，锁定的数据量越少，则系统的并发程度越高。锁策略是在锁的开销和安全性之间寻求平衡。大多数一般是在表上施加行级锁。Mysql中每个存储引擎都可以实现自己的锁策略和锁粒度。Mysql中有表锁和行级锁。</p>
<ul>
<li><p>表锁：</p>
<ul>
<li><p>是Mysql中最基本的锁策略，并且是开销最小的策略，它会锁定整个表。一个用户对表进行写操作，需要首先获得写锁，这回阻塞其他用户对该表的所有读写操作。</p>
</li>
<li><p>尽管存储引擎可以管理自己的锁，但是Mysql本身还是会使用各种有效的表锁来实现不同的目的。比如：服务器会为诸如：ALTER Table之类的语句使用表锁，而忽略存储引擎的锁机制。</p>
</li>
</ul>
</li>
<li>行级锁<ul>
<li>行级锁可以最大程度的支持并发处理，INNodb和XtraDB存储引擎中实现了行级锁。行级锁只在存储引擎层实现，而在Mysql服务器层没有实现。服务器层完全不了解存储引擎中的锁实现（实际上也不需要了解）。</li>
</ul>
</li>
</ul>
<h3 id="3-事务"><a href="#3-事务" class="headerlink" title="3.事务"></a>3.事务</h3><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p>事务内的数据，要么全部执行成功，那么全部执行失败。可以Start Transaction开始一个事务，commit提交一个事务，而rollback撤销所有的修改。</p>
<p>A: atomicity 原子性：事务是不可分割的最小工作单位。</p>
<p>C: consistency一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态。</p>
<p>I: isolation: 隔离性：事务所做的修改在提交之前，对其他事务是不可见的。</p>
<p>D: durability:持久性：一旦事务提交，事务所做的所有修改都会永久保存到数据库中。</p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>隔离性定义了四个级别，每一个级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的。哪些是不可见的。较低的级别的隔离通常可以执行更高的并发。</p>
<p>READ UNCOMMITTED(未提交读): 事务即使没有提交,所做的修改对其他事务是可见的.  也称脏读.</p>
<p>READ COMMITTED(提交读):　事务没有提交前,所做的任何修改对其他事务是不可见的.这大多数数据库默认的隔离级别,也叫不可重复读.</p>
<p>REPEATABLE READ(可重复读): 当某个事务读取某个范围内记录时,另外一个事务又在该范围内插入了新纪录并且提交成功,这时前一个事务再次读取该范围内记录,便会产生幻行.</p>
<p>SERIALIIZABLE(可串行化): 通过强制事务串行执行,避免幻读的问题, 也就是在读取的每一行记录上加锁,所以可能导致大量超时和锁争用,实际中很少用这个隔离级别.</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。</p>
<h4 id="MySQL中的事务"><a href="#MySQL中的事务" class="headerlink" title="MySQL中的事务"></a>MySQL中的事务</h4><p>MySQL中提供了两种事务型的存储引擎：InnoDB和NDB Cluster</p>
<p>自动提交：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> = <span class="string">'AUTOCOMMIT'</span>;</div><div class="line"><span class="keyword">SET</span> AUTOCOMMIT = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<h3 id="4-多版本并发控制"><a href="#4-多版本并发控制" class="headerlink" title="4.多版本并发控制"></a>4.多版本并发控制</h3><p>innoDB中MVCC通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存了行的过期时间。当然存储的并不是实际的时间值，而是系统版本号。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<h3 id="4-mysql存储引擎"><a href="#4-mysql存储引擎" class="headerlink" title="4.mysql存储引擎"></a>4.mysql存储引擎</h3><p><code>show table status like &#39;user&#39;</code></p>
<h4 id="innodb存储引擎"><a href="#innodb存储引擎" class="headerlink" title="innodb存储引擎"></a>innodb存储引擎</h4><p>mysql默认事务型引擎</p>
<h4 id="myisam存储引擎"><a href="#myisam存储引擎" class="headerlink" title="myisam存储引擎"></a>myisam存储引擎</h4><p>不支持事务和行级锁</p>
<h4 id="archive存储引擎"><a href="#archive存储引擎" class="headerlink" title="archive存储引擎"></a>archive存储引擎</h4><p>只支持insert select操作</p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;1-MySQL逻辑架构&quot;&gt;&lt;a href=&quot;#1-MySQL逻辑架构&quot; class=&quot;headerlink&quot; title=&quot;1.MySQL逻辑架构&quot;&gt;&lt;/a&gt;1.MySQL逻辑架构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http:/
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>面试题4：替换空格</title>
    <link href="http://yoursite.com/2017/01/17/Poffer4/"/>
    <id>http://yoursite.com/2017/01/17/Poffer4/</id>
    <published>2017-01-17T12:19:24.000Z</published>
    <updated>2017-02-15T08:11:35.817Z</updated>
    
    <content type="html"><![CDATA[<p>请实现一个函数，把字符串中的每个空格替换成“%20”。例如输入“We are happy.”，则输出“We%20are%20happy.”。</p>
<p>解答：</p>
<ol>
<li>首先遍历原字符串，找出字符串的长度以及其中的空格数量，</li>
<li>根据原字符串的长度和空格的数量我们可以求出最后新字符串的长度。</li>
<li>设置两个指针originalIndex和newIndex分别指向原字符串和新字符串的末尾位置。</li>
<li>如果originalIndex指向内容不为空格，那么将内容赋值给newIndex指向的位置，如果originalIndex指向为空格，那么从newIndex开始赋值“02%”</li>
<li>直到originalIndex==newIndex时表明字符串中的所有空格都已经替换完毕。</li>
</ol>
<p>代码：略</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请实现一个函数，把字符串中的每个空格替换成“%20”。例如输入“We are happy.”，则输出“We%20are%20happy.”。&lt;/p&gt;
&lt;p&gt;解答：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先遍历原字符串，找出字符串的长度以及其中的空格数量，&lt;/li&gt;
&lt;li&gt;根据原字符
    
    </summary>
    
      <category term="poffer" scheme="http://yoursite.com/categories/poffer/"/>
    
    
      <category term="poffer" scheme="http://yoursite.com/tags/poffer/"/>
    
  </entry>
  
  <entry>
    <title>面试题13：在O(1)时间删除链表节点</title>
    <link href="http://yoursite.com/2017/01/17/Poffer13/"/>
    <id>http://yoursite.com/2017/01/17/Poffer13/</id>
    <published>2017-01-17T12:19:24.000Z</published>
    <updated>2017-02-16T06:25:03.005Z</updated>
    
    <content type="html"><![CDATA[<p>题目：给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间删除该节点。</p>
<p>如果我们把下一个节点的内容复制到要删除的节点上覆盖原有的内容，再把下一个节点删除，那是不是就相当于把当前要删除的节点删除了？</p>
<p>解答：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode head,ListNode deListNode)</span></span>&#123;  </div><div class="line">       <span class="keyword">if</span>(deListNode == <span class="keyword">null</span> || head == <span class="keyword">null</span>)&#123;  </div><div class="line">           <span class="keyword">return</span> ;  </div><div class="line">       &#125;  </div><div class="line">       <span class="keyword">if</span>(head == deListNode)&#123;  </div><div class="line">           head =<span class="keyword">null</span>;  </div><div class="line">       &#125;  </div><div class="line">       <span class="keyword">else</span>&#123;  </div><div class="line">           <span class="keyword">if</span>(deListNode.next == <span class="keyword">null</span>)&#123;  </div><div class="line">               ListNode pinitListNode = head;  </div><div class="line">               <span class="keyword">while</span>(pinitListNode.next.next != <span class="keyword">null</span>)&#123;  </div><div class="line">                   pinitListNode = pinitListNode.next;  </div><div class="line">               &#125;  </div><div class="line">               pinitListNode.next = <span class="keyword">null</span>;  </div><div class="line">           &#125;<span class="keyword">else</span>&#123;  </div><div class="line">               deListNode.data = deListNode.next.data;  </div><div class="line">               deListNode.next = deListNode.next.next;  </div><div class="line">           &#125;  </div><div class="line">       &#125;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间删除该节点。&lt;/p&gt;
&lt;p&gt;如果我们把下一个节点的内容复制到要删除的节点上覆盖原有的内容，再把下一个节点删除，那是不是就相当于把当前要删除的节点删除了？&lt;/p&gt;
&lt;p&gt;解答：&lt;br&gt;&lt;figure clas
    
    </summary>
    
      <category term="poffer" scheme="http://yoursite.com/categories/poffer/"/>
    
    
      <category term="poffer" scheme="http://yoursite.com/tags/poffer/"/>
    
  </entry>
  
  <entry>
    <title>面试题11：数值的整数次方</title>
    <link href="http://yoursite.com/2017/01/17/Poffer11/"/>
    <id>http://yoursite.com/2017/01/17/Poffer11/</id>
    <published>2017-01-17T12:19:24.000Z</published>
    <updated>2017-02-16T05:16:29.112Z</updated>
    
    <content type="html"><![CDATA[<p>题目：实现函数double Power(double base,int exponent),求base的exponent次方。不得使用库函数，同时不需要考虑大数问题</p>
<p>解答：我们用右移运算代替除2，用位与运算符代替了求余运算符（%)来判断一个数是奇数还是偶数。位运算的效率比乘除法及求余运算的效率要高很多。既然要优化代码，我们就把优化做到极致。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> offer;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 实现函数power。</div><div class="line"> * <span class="doctag">@author</span> neuly</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">t11</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exponent)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(exponent==<span class="number">0</span>)</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span>(exponent==<span class="number">1</span>)</div><div class="line">			<span class="keyword">return</span> base;</div><div class="line">		<span class="keyword">double</span> result=pow(base, exponent&gt;&gt;<span class="number">1</span>);</div><div class="line">		result*=result;</div><div class="line">		<span class="keyword">if</span>((exponent&amp;<span class="number">0x1</span>)==<span class="number">1</span>) result*=base;</div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">p</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exponent)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(base==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		<span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)&#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>/pow(base, -exponent);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> pow(base, exponent);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		System.out.println(p(<span class="number">2</span>, <span class="number">3</span>));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：实现函数double Power(double base,int exponent),求base的exponent次方。不得使用库函数，同时不需要考虑大数问题&lt;/p&gt;
&lt;p&gt;解答：我们用右移运算代替除2，用位与运算符代替了求余运算符（%)来判断一个数是奇数还是偶数。位
    
    </summary>
    
      <category term="poffer" scheme="http://yoursite.com/categories/poffer/"/>
    
    
      <category term="poffer" scheme="http://yoursite.com/tags/poffer/"/>
    
  </entry>
  
  <entry>
    <title>面试题15：链表中倒数第K个结点</title>
    <link href="http://yoursite.com/2017/01/17/Poffer15/"/>
    <id>http://yoursite.com/2017/01/17/Poffer15/</id>
    <published>2017-01-17T12:19:24.000Z</published>
    <updated>2017-02-16T11:35:24.567Z</updated>
    
    <content type="html"><![CDATA[<p>题目：输入一个链表，输出该链表中倒数第k哥结点。</p>
<p>思路：</p>
<ol>
<li>先遍历一遍，然后得到数组逆序，放入栈中，输出第k个。</li>
<li>方法二只遍历一遍，采用双指针，两个指针之间相差k</li>
</ol>
<p>解答：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> offer;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">t15</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</div><div class="line">		<span class="keyword">int</span> data;</div><div class="line">		ListNode  next;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">findK</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(head==<span class="keyword">null</span> ||k&lt;=<span class="number">0</span>) <span class="keyword">return</span>  <span class="keyword">null</span>;</div><div class="line">		ListNode ANode = head;  </div><div class="line">        ListNode BNode = <span class="keyword">null</span>;  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;k-<span class="number">1</span>;i++)&#123;  </div><div class="line">            <span class="keyword">if</span>(ANode.next != <span class="keyword">null</span>)  </div><div class="line">                ANode = ANode.next;  </div><div class="line">            <span class="keyword">else</span>  </div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">        &#125;  </div><div class="line">        BNode = head;  </div><div class="line">        <span class="keyword">while</span>(ANode.next != <span class="keyword">null</span>)&#123;  </div><div class="line">            ANode = ANode.next;  </div><div class="line">            BNode = BNode.next;  </div><div class="line">        &#125;  </div><div class="line">		<span class="keyword">return</span> BNode;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">        ListNode head = <span class="keyword">new</span> ListNode();  </div><div class="line">        ListNode second = <span class="keyword">new</span> ListNode();  </div><div class="line">        ListNode third = <span class="keyword">new</span> ListNode();  </div><div class="line">        ListNode forth = <span class="keyword">new</span> ListNode();  </div><div class="line">        head.next = second;  </div><div class="line">        second.next = third;  </div><div class="line">        third.next = forth;  </div><div class="line">        head.data = <span class="number">1</span>;  </div><div class="line">        second.data = <span class="number">2</span>;  </div><div class="line">        third.data = <span class="number">3</span>;  </div><div class="line">        forth.data = <span class="number">4</span>;  </div><div class="line">        t15 test = <span class="keyword">new</span> t15();  </div><div class="line">        ListNode result = test.findK(head, <span class="number">1</span>);  </div><div class="line">        System.out.println(result.data);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：输入一个链表，输出该链表中倒数第k哥结点。&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先遍历一遍，然后得到数组逆序，放入栈中，输出第k个。&lt;/li&gt;
&lt;li&gt;方法二只遍历一遍，采用双指针，两个指针之间相差k&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;解答：&lt;/p&gt;
&lt;figu
    
    </summary>
    
      <category term="poffer" scheme="http://yoursite.com/categories/poffer/"/>
    
    
      <category term="poffer" scheme="http://yoursite.com/tags/poffer/"/>
    
  </entry>
  
  <entry>
    <title>面试题14：调整数组顺序使奇数位于偶数的前面</title>
    <link href="http://yoursite.com/2017/01/17/Poffer14/"/>
    <id>http://yoursite.com/2017/01/17/Poffer14/</id>
    <published>2017-01-17T12:19:24.000Z</published>
    <updated>2017-02-16T10:59:42.112Z</updated>
    
    <content type="html"><![CDATA[<p>题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p>思路：双指针。</p>
<p>解答：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> offer;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">t14</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">0</span>;</div><div class="line">    &#125;  </div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">order2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;  </div><div class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span>)  </div><div class="line">            <span class="keyword">return</span>;  </div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;  </div><div class="line">        <span class="keyword">int</span> j = arr.length-<span class="number">1</span>;  </div><div class="line">        <span class="keyword">while</span>(i&lt;j)&#123;  </div><div class="line">            <span class="keyword">if</span>(isEven(arr[i]) &amp;&amp; !isEven(arr[j]))&#123;  </div><div class="line">                <span class="keyword">int</span> temp = arr[i];  </div><div class="line">                arr[i]= arr[j];  </div><div class="line">                arr[j] = temp;  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!isEven(arr[i]) &amp;&amp; isEven(arr[j]))&#123;  </div><div class="line">                i++;  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(isEven(arr[i]) &amp;&amp; isEven(arr[j]))&#123;  </div><div class="line">                j--;  </div><div class="line">            &#125;<span class="keyword">else</span>&#123;  </div><div class="line">                i++;  </div><div class="line">                j--;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		t14 t= <span class="keyword">new</span> t14();</div><div class="line">		<span class="keyword">int</span>[] arr= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</div><div class="line">		t.order2(arr);</div><div class="line">		System.out.println(<span class="string">"s"</span>);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length ;i++)&#123;  </div><div class="line">            System.out.print(arr[i]+<span class="string">","</span>);  </div><div class="line">        &#125; </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。&lt;/p&gt;
&lt;p&gt;思路：双指针。&lt;/p&gt;
&lt;p&gt;解答：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
    
    </summary>
    
      <category term="poffer" scheme="http://yoursite.com/categories/poffer/"/>
    
    
      <category term="poffer" scheme="http://yoursite.com/tags/poffer/"/>
    
  </entry>
  
  <entry>
    <title>面试题16：反转链表</title>
    <link href="http://yoursite.com/2017/01/17/Poffer16/"/>
    <id>http://yoursite.com/2017/01/17/Poffer16/</id>
    <published>2017-01-17T12:19:24.000Z</published>
    <updated>2017-02-16T12:22:00.141Z</updated>
    
    <content type="html"><![CDATA[<p>题目：题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p>
<p>解答：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> offer;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">t16</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</div><div class="line">		<span class="keyword">int</span> data;</div><div class="line">		ListNode  next;</div><div class="line">	&#125;</div><div class="line">	 <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span></span>&#123;  </div><div class="line">	        <span class="keyword">if</span>(head == <span class="keyword">null</span>)  </div><div class="line">	            <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">	        ListNode preListNode = <span class="keyword">null</span>;  </div><div class="line">	        ListNode nowListNode = head;  </div><div class="line">	          </div><div class="line">	        <span class="keyword">while</span>(nowListNode != <span class="keyword">null</span>)&#123;  </div><div class="line">	            ListNode nextListNode = nowListNode.next;   <span class="comment">//保存下一个结点  </span></div><div class="line">	            nowListNode.next = preListNode;             <span class="comment">//当前结点指向前一个结点  </span></div><div class="line">	            preListNode = nowListNode;                  <span class="comment">//前任结点 到现任节点  </span></div><div class="line">	            nowListNode = nextListNode;                 <span class="comment">//现任节点到下一结点  </span></div><div class="line">	        &#125;  </div><div class="line">	        <span class="keyword">return</span> preListNode;  </div><div class="line">	    &#125;  </div><div class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">	        ListNode head = <span class="keyword">new</span> ListNode();  </div><div class="line">	        ListNode second = <span class="keyword">new</span> ListNode();  </div><div class="line">	        ListNode third = <span class="keyword">new</span> ListNode();  </div><div class="line">	        ListNode forth = <span class="keyword">new</span> ListNode();  </div><div class="line">	        head.next = second;  </div><div class="line">	        second.next = third;  </div><div class="line">	        third.next = forth;  </div><div class="line">	        head.data = <span class="number">1</span>;  </div><div class="line">	        second.data = <span class="number">2</span>;  </div><div class="line">	        third.data = <span class="number">3</span>;  </div><div class="line">	        forth.data = <span class="number">4</span>;  </div><div class="line">	        t16 test = <span class="keyword">new</span> t16();  </div><div class="line">	        ListNode result = test.ReverseList(head);  </div><div class="line">	        System.out.println(result.data);  </div><div class="line">	 &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。&lt;/p&gt;
&lt;p&gt;解答：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;l
    
    </summary>
    
      <category term="poffer" scheme="http://yoursite.com/categories/poffer/"/>
    
    
      <category term="poffer" scheme="http://yoursite.com/tags/poffer/"/>
    
  </entry>
  
  <entry>
    <title>面试题17：合并两个排序的链表</title>
    <link href="http://yoursite.com/2017/01/17/Poffer17/"/>
    <id>http://yoursite.com/2017/01/17/Poffer17/</id>
    <published>2017-01-17T12:19:24.000Z</published>
    <updated>2017-02-16T13:56:02.262Z</updated>
    
    <content type="html"><![CDATA[<p>题目：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p>
<p>解答：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> offer;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">t17</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</div><div class="line">		<span class="keyword">int</span> data;</div><div class="line">		ListNode  next;</div><div class="line">	&#125;</div><div class="line">	 <span class="function"><span class="keyword">public</span> ListNode  <span class="title">Merge</span><span class="params">(ListNode pHead1,ListNode pHead2)</span></span>&#123;  </div><div class="line">	        <span class="keyword">if</span>(pHead1 == <span class="keyword">null</span>)  </div><div class="line">	            <span class="keyword">return</span> pHead2;  </div><div class="line">	        <span class="keyword">else</span> <span class="keyword">if</span>(pHead2 == <span class="keyword">null</span>)  </div><div class="line">	            <span class="keyword">return</span> pHead1;  </div><div class="line">	        ListNode pMergedHead = <span class="keyword">null</span>;  </div><div class="line">	        <span class="keyword">if</span>(pHead1.data &lt;pHead2.data)&#123;  </div><div class="line">	            pMergedHead = pHead1;  </div><div class="line">	            pMergedHead.next = Merge(pHead1.next ,pHead2);  </div><div class="line">	        &#125;<span class="keyword">else</span>&#123;  </div><div class="line">	            pMergedHead = pHead2;  </div><div class="line">	            pMergedHead.next = Merge(pHead1,pHead2.next);  </div><div class="line">	        &#125;  </div><div class="line">	        <span class="keyword">return</span> pMergedHead;  </div><div class="line">	    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。&lt;/p&gt;
&lt;p&gt;解答：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;l
    
    </summary>
    
      <category term="poffer" scheme="http://yoursite.com/categories/poffer/"/>
    
    
      <category term="poffer" scheme="http://yoursite.com/tags/poffer/"/>
    
  </entry>
  
  <entry>
    <title>面试题3：二维数组中查找</title>
    <link href="http://yoursite.com/2017/01/17/Poffer3/"/>
    <id>http://yoursite.com/2017/01/17/Poffer3/</id>
    <published>2017-01-17T12:19:24.000Z</published>
    <updated>2017-02-15T08:07:11.908Z</updated>
    
    <content type="html"><![CDATA[<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序，请完成一个函数，输入一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>解答：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> offer;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，</div><div class="line"> * 每一列都按照从上到下递增的顺序排序。请完成一个函数，</div><div class="line"> * 输入一个这样的一个二维数组和一个整数，判断数组是否含有该数组</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> neuly</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">t3</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span>[][] a=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">12</span>&#125;,&#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">13</span>&#125;,&#123;<span class="number">6</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">15</span>&#125;&#125;;</div><div class="line">		System.out.println(find(<span class="keyword">null</span>,<span class="number">5</span>));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[][] a,<span class="keyword">int</span> t)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(a!=<span class="keyword">null</span>)&#123;</div><div class="line">			<span class="keyword">int</span> x=a.length;</div><div class="line">			<span class="keyword">int</span> y=a[<span class="number">0</span>].length-<span class="number">1</span>;</div><div class="line">			<span class="keyword">int</span> i=<span class="number">0</span>,j=y;</div><div class="line">			<span class="keyword">while</span>(i&lt;x&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</div><div class="line">				<span class="keyword">if</span>(a[i][j]==t) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(a[i][j]&gt;t)&#123;</div><div class="line">					j--;</div><div class="line">				&#125;<span class="keyword">else</span>&#123;</div><div class="line">					i++;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序，请完成一个函数，输入一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
&lt;p&gt;解答：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr
    
    </summary>
    
      <category term="poffer" scheme="http://yoursite.com/categories/poffer/"/>
    
    
      <category term="poffer" scheme="http://yoursite.com/tags/poffer/"/>
    
  </entry>
  
  <entry>
    <title>面试题5：从尾到头打印链表</title>
    <link href="http://yoursite.com/2017/01/17/Poffer5/"/>
    <id>http://yoursite.com/2017/01/17/Poffer5/</id>
    <published>2017-01-17T12:19:24.000Z</published>
    <updated>2017-02-15T08:22:34.834Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个链表的头结点，从尾到头反过来打印每个节点。</p>
<p>解答：</p>
<ol>
<li>用栈来打印。（遍历一遍入栈，然后对栈做出栈操作）</li>
<li>递归就是一个栈。</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> offer;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">t5</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> key, ListNode next)</span> </span>&#123;</div><div class="line">			<span class="keyword">this</span>.key=key;</div><div class="line">			<span class="keyword">this</span>.next=next;		</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> key;</div><div class="line">		ListNode next;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(head!=<span class="keyword">null</span>)&#123;</div><div class="line">			<span class="keyword">if</span>(head.next!=<span class="keyword">null</span>)&#123;</div><div class="line">				printList(head.next);</div><div class="line">			&#125;</div><div class="line">			System.out.println(head.key);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		ListNode n5= <span class="keyword">new</span> ListNode(<span class="number">5</span>, <span class="keyword">null</span>);</div><div class="line">		ListNode n4= <span class="keyword">new</span> ListNode(<span class="number">4</span>, n5);</div><div class="line">		ListNode n3= <span class="keyword">new</span> ListNode(<span class="number">3</span>, n4);</div><div class="line">		ListNode n2= <span class="keyword">new</span> ListNode(<span class="number">2</span>, n3);</div><div class="line">		ListNode head= <span class="keyword">new</span> ListNode(<span class="number">1</span>, n2);</div><div class="line">		printList(head);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;输入一个链表的头结点，从尾到头反过来打印每个节点。&lt;/p&gt;
&lt;p&gt;解答：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用栈来打印。（遍历一遍入栈，然后对栈做出栈操作）&lt;/li&gt;
&lt;li&gt;递归就是一个栈。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;figure class=&quot;highlig
    
    </summary>
    
      <category term="poffer" scheme="http://yoursite.com/categories/poffer/"/>
    
    
      <category term="poffer" scheme="http://yoursite.com/tags/poffer/"/>
    
  </entry>
  
  <entry>
    <title>面试题12：打印1到最大的n位数</title>
    <link href="http://yoursite.com/2017/01/17/Poffer12/"/>
    <id>http://yoursite.com/2017/01/17/Poffer12/</id>
    <published>2017-01-17T12:19:24.000Z</published>
    <updated>2017-02-16T05:43:55.191Z</updated>
    
    <content type="html"><![CDATA[<p>题目：题目：输入数字n，按顺序打印出从1最大的的n位数十进制数。比如输入3，则打印出1，2，3一直到最大的3位数即999.</p>
<p>解答：<br><a href="http://blog.csdn.net/jsqfengbao/article/details/47174629" target="_blank" rel="external">http://blog.csdn.net/jsqfengbao/article/details/47174629</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：题目：输入数字n，按顺序打印出从1最大的的n位数十进制数。比如输入3，则打印出1，2，3一直到最大的3位数即999.&lt;/p&gt;
&lt;p&gt;解答：&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/jsqfengbao/article/details/4717
    
    </summary>
    
      <category term="poffer" scheme="http://yoursite.com/categories/poffer/"/>
    
    
      <category term="poffer" scheme="http://yoursite.com/tags/poffer/"/>
    
  </entry>
  
  <entry>
    <title>poffer1</title>
    <link href="http://yoursite.com/2017/01/17/Poffer1/"/>
    <id>http://yoursite.com/2017/01/17/Poffer1/</id>
    <published>2017-01-17T12:19:24.000Z</published>
    <updated>2017-02-07T09:20:26.708Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="poffer" scheme="http://yoursite.com/categories/poffer/"/>
    
    
      <category term="poffer" scheme="http://yoursite.com/tags/poffer/"/>
    
  </entry>
  
  <entry>
    <title>面试题9：fibonacci</title>
    <link href="http://yoursite.com/2017/01/17/Poffer9/"/>
    <id>http://yoursite.com/2017/01/17/Poffer9/</id>
    <published>2017-01-17T12:19:24.000Z</published>
    <updated>2017-02-16T05:06:59.350Z</updated>
    
    <content type="html"><![CDATA[<p>题目：写一个函数，输入n，求斐波那契数列的第n项</p>
<p>解答：</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">t9</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		<span class="keyword">return</span> fibonacci(n-<span class="number">1</span>)+fibonacci(n-<span class="number">2</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fibo</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">		<span class="keyword">int</span>[] result=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</div><div class="line">		<span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> result[n];</div><div class="line">		<span class="keyword">long</span> b1=<span class="number">1</span>;</div><div class="line">		<span class="keyword">long</span> b2=<span class="number">1</span>;</div><div class="line">		<span class="keyword">long</span> sum=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</div><div class="line">			sum=b1+b2;</div><div class="line">			b2=b1;</div><div class="line">			b1=sum;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> sum;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>详细步骤：<a href="http://blog.csdn.net/jsqfengbao/article/details/47121489" target="_blank" rel="external">http://blog.csdn.net/jsqfengbao/article/details/47121489</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：写一个函数，输入n，求斐波那契数列的第n项&lt;/p&gt;
&lt;p&gt;解答：&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;
    
    </summary>
    
      <category term="poffer" scheme="http://yoursite.com/categories/poffer/"/>
    
    
      <category term="poffer" scheme="http://yoursite.com/tags/poffer/"/>
    
  </entry>
  
  <entry>
    <title>面试题6：重建二叉树</title>
    <link href="http://yoursite.com/2017/01/17/Poffer6/"/>
    <id>http://yoursite.com/2017/01/17/Poffer6/</id>
    <published>2017-01-17T12:19:24.000Z</published>
    <updated>2017-02-15T13:53:53.764Z</updated>
    
    <content type="html"><![CDATA[<p>题目：输入某二叉树的前序遍历和中序遍历的结果，请重新构造出该二叉树。假设输入的前序遍历和中序遍历的结果中不包含重复的数字。例如输入的前序遍历序列为｛1，2，4，7，3，5，6，8｝和中序遍历为{4,7,2,1,5,3,6,8},则重建出二叉树并输出它的头结点。</p>
<p>解答：</p>
<ol>
<li>在二叉树的前序遍历序列中，第一个数字总是树的根节点的值。但在中序遍历中，根节点的值在序列的中间，左子树的结点的值位于根节点的值的左边，而右子树的结点的值位于根节点的右边。因此我们需要扫描中序遍历序列，才能找到根节点的值。<br>如图所示，前序遍历序列的第一个数字1就是根节点的值。扫描中序遍历序列，就能确定根节点的值的位置。根据中序遍历的特点，在根节点的值1前面3个数字都是左子树结点的值，位于1后面的数字都是右子树结点的值。</li>
<li>既然我们已经分别找到了左、右子树的前序遍历序列和中序遍历序列，我们可以用同样的方法分别去构建左右子树。也就是说，接下来的事情可以用递归的方法去完成。</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> offer;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">t6</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span> </span>&#123;</div><div class="line">		 <span class="keyword">public</span> <span class="keyword">int</span> value;  </div><div class="line">		 <span class="keyword">public</span> BinaryTreeNode leftNode;  </div><div class="line">		 <span class="keyword">public</span> BinaryTreeNode rightNode;  		      </div><div class="line">		 <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">()</span></span>&#123;  </div><div class="line">		          </div><div class="line">		 &#125;  </div><div class="line">		 <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;  </div><div class="line">		     <span class="keyword">this</span>.value = value ;  </div><div class="line">		     <span class="keyword">this</span>.leftNode = <span class="keyword">null</span>;  </div><div class="line">		     <span class="keyword">this</span>.rightNode = <span class="keyword">null</span>;  </div><div class="line">		 &#125;  </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">    <span class="comment">/**  </span></div><div class="line">     *   </div><div class="line">     * <span class="doctag">@param</span> preOrder 前序遍历数组  </div><div class="line">     * <span class="doctag">@param</span> inOrder 中序遍历数组  </div><div class="line">     * <span class="doctag">@param</span> length 数组长度  </div><div class="line">     * <span class="doctag">@return</span> 根结点  </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BinaryTreeNode <span class="title">Construct</span><span class="params">(<span class="keyword">int</span>[] preOrder, <span class="keyword">int</span>[] inOrder,<span class="keyword">int</span> length)</span></span>&#123;  </div><div class="line">        <span class="keyword">if</span> (preOrder == <span class="keyword">null</span> || inOrder == <span class="keyword">null</span> || length &lt;= <span class="number">0</span>) &#123;  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="keyword">return</span> ConstructCore(preOrder, <span class="number">0</span>, preOrder.length - <span class="number">1</span>, inOrder, <span class="number">0</span>,inOrder.length - <span class="number">1</span>);  </div><div class="line">        &#125; <span class="keyword">catch</span> (InvalidPutException e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/**  </span></div><div class="line">     *   </div><div class="line">     * <span class="doctag">@param</span> PreOrder  </div><div class="line">     *            前序遍历序列  </div><div class="line">     * <span class="doctag">@param</span> startPreIndex  </div><div class="line">     *            前序序列开始位置  </div><div class="line">     * <span class="doctag">@param</span> endPreIndex  </div><div class="line">     *            前序序列结束位置  </div><div class="line">     * <span class="doctag">@param</span> InOrder  </div><div class="line">     *            中序遍历序列  </div><div class="line">     * <span class="doctag">@param</span> startInIndex  </div><div class="line">     *            中序序列开始位置  </div><div class="line">     * <span class="doctag">@param</span> endInIndex  </div><div class="line">     *            中序序列结束位置  </div><div class="line">     * <span class="doctag">@return</span> 根结点  </div><div class="line">     * <span class="doctag">@throws</span> InvalidPutException  </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BinaryTreeNode <span class="title">ConstructCore</span><span class="params">(<span class="keyword">int</span>[] preOrder,<span class="keyword">int</span> startPreIndex, <span class="keyword">int</span> endPreIndex,   </span></span></div><div class="line">            <span class="keyword">int</span>[] inOrder,<span class="keyword">int</span> startInIndex, <span class="keyword">int</span> endInIndex) <span class="keyword">throws</span> InvalidPutException &#123;  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> rootValue = preOrder[startPreIndex];  </div><div class="line">        System.out.println(<span class="string">"rootValue = "</span> + rootValue);  </div><div class="line">        BinaryTreeNode root = <span class="keyword">new</span> BinaryTreeNode(rootValue);  </div><div class="line">  </div><div class="line">        <span class="comment">// 只有一个元素  </span></div><div class="line">        <span class="keyword">if</span> (startPreIndex == endPreIndex) &#123;  </div><div class="line">            <span class="keyword">if</span> (startInIndex == endInIndex  </div><div class="line">                    &amp;&amp; preOrder[startPreIndex] == inOrder[startInIndex]) &#123;  </div><div class="line">                System.out.println(<span class="string">"only one element"</span>);  </div><div class="line">                <span class="keyword">return</span> root;  </div><div class="line">            &#125; <span class="keyword">else</span> &#123;  </div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPutException();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="comment">// 在中序遍历中找到根结点的索引  </span></div><div class="line">        <span class="keyword">int</span> rootInIndex = startInIndex;  </div><div class="line">  </div><div class="line">        <span class="keyword">while</span> (rootInIndex &lt;= endInIndex &amp;&amp; inOrder[rootInIndex] != rootValue) &#123;  </div><div class="line">            ++rootInIndex;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="keyword">if</span> (rootInIndex == endInIndex &amp;&amp; inOrder[rootInIndex] != rootValue) &#123;  </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPutException();  </div><div class="line">  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> leftLength = rootInIndex - startInIndex;  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> leftPreOrderEndIndex = startPreIndex + leftLength;  </div><div class="line">  </div><div class="line">        <span class="keyword">if</span> (leftLength &gt; <span class="number">0</span>) &#123;  </div><div class="line">            <span class="comment">// 构建左子树  </span></div><div class="line">            root.leftNode = ConstructCore(preOrder, startPreIndex + <span class="number">1</span>,  </div><div class="line">                    leftPreOrderEndIndex, inOrder, startInIndex,  </div><div class="line">                    rootInIndex - <span class="number">1</span>);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="keyword">if</span> (leftLength &lt; endPreIndex - startPreIndex) &#123;  </div><div class="line">            <span class="comment">// 右子树有元素,构建右子树  </span></div><div class="line">            root.rightNode = ConstructCore(preOrder, leftPreOrderEndIndex + <span class="number">1</span>,  </div><div class="line">                    endPreIndex, inOrder, rootInIndex + <span class="number">1</span>, endInIndex);  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> root;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InvalidPutException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;  </div><div class="line">  </div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;  </div><div class="line">  </div><div class="line">    &#125; </div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPreOrder</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">return</span>;  </div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            System.out.print(root.value + <span class="string">" "</span>);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="keyword">if</span> (root.leftNode != <span class="keyword">null</span>) &#123;  </div><div class="line">            printPreOrder(root.leftNode);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="keyword">if</span> (root.rightNode != <span class="keyword">null</span>) &#123;  </div><div class="line">            printPreOrder(root.rightNode);  </div><div class="line">        &#125;  </div><div class="line">    &#125; </div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;   </div><div class="line">        <span class="keyword">int</span>[] preOrder=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;  </div><div class="line">        <span class="keyword">int</span>[] inOrder=&#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>&#125;;  </div><div class="line">         printPreOrder(Construct(preOrder, inOrder, preOrder.length));  </div><div class="line">    &#125;  </div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：输入某二叉树的前序遍历和中序遍历的结果，请重新构造出该二叉树。假设输入的前序遍历和中序遍历的结果中不包含重复的数字。例如输入的前序遍历序列为｛1，2，4，7，3，5，6，8｝和中序遍历为{4,7,2,1,5,3,6,8},则重建出二叉树并输出它的头结点。&lt;/p&gt;
&lt;p
    
    </summary>
    
      <category term="poffer" scheme="http://yoursite.com/categories/poffer/"/>
    
    
      <category term="poffer" scheme="http://yoursite.com/tags/poffer/"/>
    
  </entry>
  
  <entry>
    <title>面试题7：用两个栈实现队列</title>
    <link href="http://yoursite.com/2017/01/17/Poffer7/"/>
    <id>http://yoursite.com/2017/01/17/Poffer7/</id>
    <published>2017-01-17T12:19:24.000Z</published>
    <updated>2017-02-16T04:58:59.299Z</updated>
    
    <content type="html"><![CDATA[<p>题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail和deletedHead,分别完成在队列尾部插入节点和在队列头部删除节点的功能。</p>
<p>解答：</p>
<ol>
<li>我们通过一个具体的例子来分析该队列插入和删除元素的过程。首先插入一个元素a，不妨先把它插入到stack1，此时stack1 中的元素有｛a}，stack2为空。再压入两个元素b和c,还是插入到stack1中，此时stack1中的元素有｛a,b,c}，其中c位于栈顶，而stack2仍然为空。</li>
<li>这个时候，我们试着删除从队列中删除一个元素。按照队列先入先出的规则，由于a比b、c先插入到队列中，最先被删除的元素应该是a。元素a存储在stack1中，但并不在占顶上，因此不能直接被删除。注意到stack2我们还一直没有使用过，现在是让stack2发挥作用的时候了。如果我们把stack1中的元素逐个弹出并压入stack2，元素在stack2中的顺序正好和原来的stack1中的顺序相反。因此经过3次弹出stack1和压入stack2操作之后，stack1为空，而stack2中的元素是｛c,b,a}，这个时候就可以弹出stack2的栈顶a了。此时的stack1为空，而stack2的元素为{c,b}，其中在栈顶</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> offer;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Stack;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">t7</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> Stack&lt;String&gt; stack1= <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">	<span class="keyword">private</span> Stack&lt;String&gt; stack2= <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(String s)</span></span>&#123;</div><div class="line">		stack1.push(s);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function">String <span class="title">deleteHead</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">		<span class="keyword">if</span>(stack2.isEmpty())&#123;</div><div class="line">			<span class="keyword">while</span>(!stack1.isEmpty())&#123;</div><div class="line">				stack2.push(stack1.pop());</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(stack2.isEmpty())&#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> stack2.pop();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		t7 t= <span class="keyword">new</span> t7();</div><div class="line">		t.appendTail(<span class="string">"a"</span>);</div><div class="line">		t.appendTail(<span class="string">"b"</span>);</div><div class="line">		t.appendTail(<span class="string">"c"</span>);</div><div class="line">		System.out.println(t.deleteHead());</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两个队列模仿栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> offer;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">t7q</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> LinkedList&lt;String&gt; queue1=<span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">	<span class="keyword">private</span> LinkedList&lt;String&gt; queue2=<span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span></span>&#123;</div><div class="line">		String re=<span class="keyword">null</span>;</div><div class="line">		<span class="keyword">if</span>(queue1.size()==<span class="number">0</span>&amp;&amp;queue2.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">if</span>(queue2.size()==<span class="number">0</span>)&#123;</div><div class="line">			<span class="keyword">while</span>(queue1.size()&gt;<span class="number">0</span>)&#123;</div><div class="line">				re=queue1.removeFirst();</div><div class="line">				<span class="keyword">if</span>(queue1.size()!=<span class="number">0</span>)&#123;</div><div class="line">					queue2.addLast(re);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(queue1.size()==<span class="number">0</span>)&#123;</div><div class="line">			<span class="keyword">while</span>(queue2.size()&gt;<span class="number">0</span>)&#123;</div><div class="line">				re=queue2.removeFirst();</div><div class="line">				<span class="keyword">if</span>(queue2.size()!=<span class="number">0</span>)&#123;</div><div class="line">					queue1.addLast(re);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> re;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">push</span><span class="params">(String str)</span></span>&#123;  </div><div class="line">        <span class="keyword">if</span>(queue1.size() ==<span class="number">0</span> &amp;&amp; queue2.size() == <span class="number">0</span>)&#123;  </div><div class="line">            queue1.addLast(str);  </div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(queue1.size()!=<span class="number">0</span>)&#123;  </div><div class="line">            queue1.addLast(str);  </div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(queue2.size()!=<span class="number">0</span>)&#123;  </div><div class="line">            queue2.addLast(str);  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> str;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail和deletedHead,分别完成在队列尾部插入节点和在队列头部删除节点的功能。&lt;/p&gt;
&lt;p&gt;解答：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们通过一个具体的例子来分析该队列插入和删除元素的过程。首先插
    
    </summary>
    
      <category term="poffer" scheme="http://yoursite.com/categories/poffer/"/>
    
    
      <category term="poffer" scheme="http://yoursite.com/tags/poffer/"/>
    
  </entry>
  
  <entry>
    <title>面试题10：二进制中的1的个数</title>
    <link href="http://yoursite.com/2017/01/17/Poffer10/"/>
    <id>http://yoursite.com/2017/01/17/Poffer10/</id>
    <published>2017-01-17T12:19:24.000Z</published>
    <updated>2017-02-16T05:09:57.710Z</updated>
    
    <content type="html"><![CDATA[<p>题目：请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1，因此如果输入9，该函数输出2.</p>
<p>解答：把一个整数减去1，再和原整数做与运算，会把该整数最右边的一个1变成0.那么一个整数的二进制表示中有多少个1，就可以进行多少次运算。基于这种思路，我们可以写出这样的代码：</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> offer;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 1.请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。</div><div class="line"> * </div><div class="line"> * 2.相关题目，判断一个整数是不是2的整数次幂，一个整数如果是2的整数次幂，</div><div class="line"> * 他的二进制表示有且仅有一个1，那么把这个整数减去1在和它自己做运算，这个整数中唯一的1就变成0.</div><div class="line"> * </div><div class="line"> * 3.输入m和n，计算需要改变m的二进制表示中多少位才能得到n，可以分两步：第一步先求异或，m^n</div><div class="line"> * 第二部，求结果中1的位数。</div><div class="line"> * </div><div class="line"> * 4.：将一个整数减去1之后在和原来的整数做位与运算，得到的结果相当把整数的二进制表示的最后边的1变为0</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> neuly</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">t10</span> </span>&#123;</div><div class="line">	 <span class="function"><span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">numof1</span> <span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">		 <span class="keyword">int</span> count=<span class="number">0</span>;</div><div class="line">		 <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</div><div class="line">			 count++;</div><div class="line">			 n=(n-<span class="number">1</span>)&amp;n;</div><div class="line">		 &#125;</div><div class="line">		 <span class="keyword">return</span> count;</div><div class="line">	 &#125;</div><div class="line">	 </div><div class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		System.out.println(numof1(<span class="number">9</span>));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1，因此如果输入9，该函数输出2.&lt;/p&gt;
&lt;p&gt;解答：把一个整数减去1，再和原整数做与运算，会把该整数最右边的一个1变成0.那么一个整数的二进制表示中有多少个1，就可
    
    </summary>
    
      <category term="poffer" scheme="http://yoursite.com/categories/poffer/"/>
    
    
      <category term="poffer" scheme="http://yoursite.com/tags/poffer/"/>
    
  </entry>
  
  <entry>
    <title>network_tcp三次握手</title>
    <link href="http://yoursite.com/2017/01/16/network_TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2017/01/16/network_TCP三次握手和四次挥手状态变迁解析/</id>
    <published>2017-01-16T10:27:24.000Z</published>
    <updated>2017-02-07T09:17:36.541Z</updated>
    
    <content type="html"><![CDATA[<p>TCP是TCP/IP的传输层控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:</p>
<p>首先需要了解几个名词：tcp标志位,有6种分别为：SYN(synchronous建立联机) 、ACK(acknowledgement 确认) 、PSH(push传送) 、FIN(finish结束)、 RST(reset重置) 、URG(urgent紧急);</p>
<ul>
<li>URG 紧急指针，告诉接收TCP模块紧要指针域指着紧要数据。</li>
<li>ACK 置1时表示确认号（为合法，为0的时候表示数据段不包含确认信息，确认号被忽略。 </li>
<li>PSH 置1时请求的数据段在接收方得到后就可直接送到应用程序，而不必等到缓冲区满时才传送。 </li>
<li>RST 置1时重建连接。如果接收到RST位时候，通常发生了某些错误。 </li>
<li>SYN 置1时用来发起一个连接。 </li>
<li>FIN 置1时表示发端完成发送任务。用来释放连接，表明发送方已经没有数据发送了。</li>
<li>另外还有 Sequence number(顺序号码) 、Acknowledge number(确认号码)在建立握手过程中发送的序列号。</li>
</ul>
<p>主机A(client)和主机B(server)开始建立握手过程：</p>
<ul>
<li>第一次握手：主机A发送位码为syn＝1,随机产生seq number=10001的数据包到服务器，主机B由SYN=1知道，A要求建立联机，此时状态为SYN_SENT；</li>
<li>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=20001的包，此时状态由LISTEN变为SYN_RECV；</li>
<li>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功，双方状态ESTABLISHED。</li>
</ul>
<p>完成三次握手，主机A与主机B开始传送数据。</p>
<p>解释各状态的含意：</p>
<ul>
<li>CLOSED: 这个没什么好说的了，表示初始状态。 </li>
<li>LISTEN: 这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接了。 </li>
<li>SYN_RECV: 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本 上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态 时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。 </li>
<li>SYN_SENT: 这个状态与SYN_RECV遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状 态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。 </li>
<li>ESTABLISHED：这个容易理解了，表示连接已经建立了。 </li>
</ul>
<p>示意图：</p>
<p><img src="http://i.imgur.com/sNQUAgo.png" alt=""></p>
<p>SYN攻击</p>
<p>在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect).此时服务器处于Syn_RECV状态.当收到ACK后，服务器转入ESTABLISHED状态.</p>
<p>Syn攻击就是 攻击客户端 在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直 至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。</p>
<p>Syn攻击是一个典型的DDOS攻击。检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击.在Linux下可以如下命令检测是否被Syn攻击：</p>
<p>#netstat -n -p TCP | grep SYN_RECV</p>
<p>一般较新的TCP/IP协议栈都对这一过程进行修正来防范Syn攻击，修改tcp协议实现。主要方法有SynAttackProtect保护机制、SYN cookies技术、增加最大半连接和缩短超时时间等，但是不能完全防范syn攻击。</p>
<p>TCP 四次挥手</p>
<p>TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作。<br>解析各种状态含义：</p>
<ul>
<li>FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别 是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即 进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马 上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。 </li>
<li>FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。 </li>
<li>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。 </li>
<li>CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什 么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报 文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。 </li>
<li>CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对 方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。 </li>
<li>LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。</li>
<li>借用网上的示意图便于理解挥手过程 ：</li>
</ul>
<p><img src="http://i.imgur.com/S2kP5Vo.jpg" alt=""></p>
<p>整理网上知识点，有3个问题分析后得出的结论（不一定保证100%正确）：</p>
<p>1、 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？ </p>
<p>这 是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一 个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未 必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文 和FIN报文多数情况下都是分开发送的。 </p>
<p>2、 为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？</p>
<p>因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED 状态(就好比从SYN_SENT 状态到ESTABLISH 状态那样)，但是我们必须假想网络是不可靠的，你无法保证你(客户端)最后发送的ACK报文一定会被对方收到，就是说对方处于LAST_ACK 状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT 状态的作用就是用来重发可能丢失的ACK报文。</p>
<p>3、关闭TCP连接一定需要4次挥手吗?</p>
<p>不一定，4次挥手关闭TCP连接是最安全的做法。但在有些时候，我们不喜欢TIME_WAIT 状态(如当MSL数值设置过大导致服务器端有太多TIME_WAIT状态的TCP连接，减少这些条目数可以更快地关闭连接，为新连接释放更多资源)，这时我们可以通过设置SOCKET变量的SO_LINGER标志来避免SOCKET在close()之后进入TIME_WAIT状态，这时将通过发送RST强制终止TCP连接(取代正常的TCP四次握手的终止方式)。但这并不是一个很好的主意，TIME_WAIT 对于我们来说往往是有利的</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TCP是TCP/IP的传输层控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:&lt;/p&gt;
&lt;p&gt;首先需要了解几个名词：tcp标志位,有6种分别为：SYN(synchronous建立联机) 、ACK(acknowledgement 确认) 、PSH(push传送) 、
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>jvm-questions</title>
    <link href="http://yoursite.com/2017/01/16/jvm-questions/"/>
    <id>http://yoursite.com/2017/01/16/jvm-questions/</id>
    <published>2017-01-16T10:27:24.000Z</published>
    <updated>2017-02-07T09:14:21.625Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>内存模型以及分区，需要详细到每个区放什么。</p>
<p> 方法区 用于存储以被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p> 堆 存放对象实例，几乎所有的对象实例以及数组都要在这里分配内存。</p>
<p> 虚拟机栈 线程私有。每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息</p>
<p> 本地方法栈 虚拟机用到的Native方法服务</p>
<p> 程序计数器 它是一块较小的内存空间，它的作用可以看做是当先线程所执行的字节码的信号指示器。</p>
</li>
</ol>
<ol>
<li>堆里面的分区：Eden，survival from to，老年代，各自的特点。</li>
</ol>
<ol>
<li><p>对象创建方法，对象的内存分配，对象的访问定位。</p>
<p> 创建：new-&gt;检查这个指令参数是否能在常量池中定位到一个类的引用符号-&gt;判断这个类是否被加载、解析、初始化过-&gt;加载检查通过后，分配内存(指针碰撞，空闲列表)-&gt;对分配内存空间的动作进行同步处理（CAS配上失败重试、TLAB）-&gt;虚拟机需要将分配到的内存空间都初始化为零值-&gt;对对象进行必要的设置</p>
<p> 内存分配：对象头（header）、实例数据（Instance Data）、对其填充（Padding） </p>
<p> 对象访问： 句柄 直接访问；如果使用句柄访问的话，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据的具体各自的地址信息。</p>
</li>
<li><p>GC的两种判定方法：引用计数与引用链。</p>
<p> 对象死了么：引用计数算法；可达性分析算法（gc root）<br> java  GC ROOTS的对象包含以下几种<br> 虚拟机栈中引用的对象<br> 方法区中类静态属性引用的对象<br> 方法区中常量引用的对象<br> 本地方法栈种JNI（native方法）引用的对象</p>
</li>
</ol>
<ol>
<li><p>GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？</p>
<p> 标记清楚：分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。该算法的缺点是效率不高并且会产生不连续的内存碎片。</p>
<p> 把内存空间划为两个区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。优点：实现简单，运行高效。缺点：会浪费一定的内存。一般新生代采用这种算法</p>
<p> 标记阶段与标记清除算法一样。但后续并不是直接对可回收的对象进行清理，而是让所有存活对象都想一端移动，然后清理。优点是不会造成内存碎片</p>
<p> 新生代：复制算法 死得多 活的少<br> 老年代：标记整理 活得多 </p>
</li>
<li><p>GC收集器有哪些？CMS收集器与G1收集器的特点。</p>
<p> JVM中的垃圾收集一般都采用“分代收集”，不同的堆内存区域采用不同的收集算法，主要目的就是为了增加吞吐量或降低停顿时间。</p>
<ul>
<li>Serial收集器：新生代收集器，使用复制算法，使用一个线程进行GC，串行，其它工作线程暂停。</li>
<li>ParNew收集器：新生代收集器，使用复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停。使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。</li>
<li>Parallel Scavenge 收集器：吞吐量优先的垃圾回收器，作用在新生代，使用复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间。使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾。</li>
<li>Serial Old收集器：老年代收集器，单线程收集器，串行，使用标记整理算法，使用单线程进行GC，其它工作线程暂停。</li>
<li>Parallel Old收集器：吞吐量优先的垃圾回收器，作用在老年代，多线程，并行，多线程机制与Parallel Scavenge差不错，使用标记整理算法，在Parallel Old执行时，仍然需要暂停其它线程。</li>
<li>CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见Full GC和并发垃圾回收一节），当用户线程内存不足时，采用备用方案Serial Old收集。</li>
<li>GI收集器：cms的替代？ 并行于并发 分代收集 空间整合 可预测的停顿 </li>
</ul>
</li>
</ol>
<ol>
<li><p>Minor GC与Full GC分别在什么时候发生？</p>
<ul>
<li>为了分代垃圾回收，Java堆内存分为3代：新生代，老年代和永久代。</li>
<li>新的对象实例会优先分配在新生代，在经历几次Minor GC后(默认15次)，还存活的会被移至老年代(某些大对象会直接在老年代分配)。</li>
<li>永久代是否执行GC，取决于采用的JVM。</li>
<li>Minor GC发生在新生代，当Eden区没有足够空间时，会发起一次Minor GC，将Eden区中的存活对象移至Survivor区。Major GC发生在老年代，当升到老年代的对象大于老年代剩余空间时会发生Major GC。</li>
<li>发生Major GC时用户线程会暂停，会降低系统性能和吞吐量。</li>
</ul>
</li>
<li><p>几种常用的内存调试工具：jmap、jstack、jconsole。</p>
<ul>
<li>jps：进程状态工具</li>
<li>jmap：生成堆存储快照</li>
<li>jstack:对战跟踪工具</li>
<li>jconsole：一个可视化java见识和管理控制台</li>
</ul>
</li>
</ol>
<ol>
<li><p>类加载的五个过程：加载、验证、准备、解析、初始化。</p>
<p> 1.装载：</p>
<ul>
<li>(1).找到该类型的class文件，产生一个该类型的class文件二进制数据流(ClassLoader需要实现的loadClassData()方法)</li>
<li>(2).解析该二进制数据流为方法区内的数据结构</li>
<li>(3).创建一个该类型的java.lang.Class实例</li>
<li><p>在加载器的相关代码中可以看到，最终通过defineClass()创建一个Java类型对象(Class对象)。</p>
<p>2.验证：<br>class文件校验器需要四趟独立的扫描来完成验证工作，其中：</p>
<p>第一趟扫描在装载时进行，会对class文件进行结构检查，如</p>
<blockquote>
<p>(1).对魔数进行检查，以判断该文件是否是一个正常的class文件<br>(2).对主次版本号进行检查，以判断class文件是否与java虚拟机兼容。<br>(3).对class文件的长度和类型进行检查，避免class文件部分缺失或被附加内容。</p>
</blockquote>
<p>第二趟扫描在连接过程中进行，会对类型数据进行语义检查，主要检查各个类的二进制兼容性(主要是查看超类和子类的关系)和类本身是否符合特定的语义条件</p>
<blockquote>
<p>(1).final类不能拥有子类<br>(2).final方法不能被重写(覆盖)<br>(3).子类和超类之间没有不兼容的方法声明<br>(4).检查常量池入口类型是否一致(如CONSTANT_Class常量池的内容是否指向一个CONSTANT_Utf8字符串常量池)<br>(5).检查常量池的所有特殊字符串，以确定它们是否是其所属类型的实例，以及是否符合特定的上下文无关语法、格式</p>
</blockquote>
<p>第三趟扫描为字节码验证，其验证内容和实现较为复杂，主要检验字节码是否可以被java虚拟机安全地执行。</p>
<p>第四趟扫描在解析过程中进行，为对符号引用的验证。在动态连接过程中，通过保存在常量池的符号引用查找被引用的类、接口、字段、方法时，在把符号引用替换成直接引用时，首先需要确认查找的元素真正存在，然后需要检查访问权限、查找的元素是否是静态类成员而非实例成员。</p>
<p>3.准备：</p>
<p>为类变量分配内存、设置默认初始值(内存设置初始值，而非对类变量真正地进行初始化，即类中声明int i = 5，但实际上这里是分配内存并设置初始值为0)</p>
<p>4.解析：</p>
<p>在类的常量池中寻找类、接口、字段、方法的符号引用，将这些符号引用替换成直接引用</p>
<p>5.初始化</p>
<p>对类变量赋予指定的初始值(这个时候int i = 5就必须赋予i以初值5)。这个初始值的给定方式有两种，一种是通过类变量的初始化语句，一种是静态初始化语句。而这些初始化语句都将被Java编译器一起放在方法中。<br>如前面所述，一个类的初始化需要初始化其直接超类，并递归初始化其祖先类，初始化是通过调用类的初始化方法完成的。此外，对于接口，并不需要初始化其父接口，而只需要执行该接口的接口初始化方法就可以了。</p>
</li>
</ul>
</li>
</ol>
<ol>
<li>双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。</li>
</ol>
<p>启动类加载器Bootstrap ClassLoader  javahome/lib<br>↑<br>扩展类加载器Extension ClassLoader  /lib/ext<br>↑<br>应用程序类加载器ApplicationClassLoader 用户类路径<br>↑<br>自定义类加载器</p>
<ol>
<li>分派：静态分派与动态分派。</li>
</ol>
<p>JVM过去过来就问了这么些问题，没怎么变，内存模型和GC算法这块问得比较多，可以在网上多找几篇博客来看看。<br>推荐书籍：《深入理解java虚拟机》</p>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;内存模型以及分区，需要详细到每个区放什么。&lt;/p&gt;
&lt;p&gt; 方法区 用于存储以被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。&lt;/p&gt;
&lt;p&gt; 堆 存放对象实例，几乎所有的对象实例以及数组都要在这里分配内存。&lt;/p&gt;
&lt;p&gt; 虚拟机栈 
    
    </summary>
    
      <category term="jvm" scheme="http://yoursite.com/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jv_collections1-list</title>
    <link href="http://yoursite.com/2017/01/14/jv-collections1-list/"/>
    <id>http://yoursite.com/2017/01/14/jv-collections1-list/</id>
    <published>2017-01-14T12:51:12.000Z</published>
    <updated>2017-02-07T09:12:12.818Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
</feed>
