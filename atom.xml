<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lyp&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-15T11:45:43.324Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Loren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL3之服务器性能剖析</title>
    <link href="http://yoursite.com/2017/03/15/MySQL3%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/"/>
    <id>http://yoursite.com/2017/03/15/MySQL3之服务器性能剖析/</id>
    <published>2017-03-15T12:52:12.000Z</published>
    <updated>2017-03-15T11:45:43.324Z</updated>
    
    <content type="html"><![CDATA[<p>关于mysql服务器性能，可能需要关注的点会比较多，如：如何确认服务器是否达到了性能最佳的状态，找出某条语句为什么执行不够快，以及诊断被用户描述成“停顿“,“堆积“或者“卡死“的某些间歇性疑难故障。这看起来很不简单。但是事实证明，有一个简单的方法能够从噪声中发现苗头。</p>
<p>这个方法就是专注于测量服务器的时间花费在哪里，使用的技术则是性能剖析。</p>
<p>mysql性能的问题，可能不同人会有不同的说法。例如：每秒查询数，cpu利用率，可扩展性  等等。</p>
<p>每个人在不同场景对性能有不同的理解。</p>
<p>但在这我们将给出一个正式的定义：</p>
<p>mysql性能指的是完成某件任务所需要的时间的度量，换句话说，性能即响应时间.</p>
<p>性能优化就是在一定得工作负载下尽可能的降低响应时间。</p>
<p>有人认为性能优化是降低cpu利用率，这是一个误解。资源是用来消耗并用来工作的，所以有时候消耗更多的资源能够加快查询速度。cpu利用率只是一种现象，而不是很好的可度量的目标。</p>
<p>同样，如果把性能优化仅仅看成提升每秒查询量，这其实只是吞吐量优化。吞吐量的提升可以看做性能优化的副产品。（吞吐量的定义是单位时间内的查询数量，这正好是我们对性能定义的倒数）</p>
<p>优化的第二原则：无法测量就无法有效的优化。所以，第一步应该测量时间花在什么地方。</p>
<p>不合适的测量：</p>
<p>　　在错误的时间启动和停止测量</p>
<p>　　测量的是聚合后的信息，而被捕是目标活动本身。</p>
<p>例如一个常见的错误是先查看慢查询，然后又去排查整个服务器的情况来判断问题的所在。</p>
<p>完成一项任务所需要的时间可以分为两部分：执行时间和等待时间。</p>
<p>剖析MySQL查询：</p>
<p>　　1.剖析服务器负载</p>
<p>　　　　捕获mysql的查询到日志文件中</p>
<p>　　　　分析查询日志</p>
<p>　　2.剖析单条查询</p>
<p>　　　　使用 show profile</p>
<p>　　　　使用 show status</p>
<p>　　　　使用 慢查询日志</p>
<p>　　3.使用性能剖析</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于mysql服务器性能，可能需要关注的点会比较多，如：如何确认服务器是否达到了性能最佳的状态，找出某条语句为什么执行不够快，以及诊断被用户描述成“停顿“,“堆积“或者“卡死“的某些间歇性疑难故障。这看起来很不简单。但是事实证明，有一个简单的方法能够从噪声中发现苗头。&lt;/p
    
    </summary>
    
      <category term="高性能mysql" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
    
      <category term="高性能mysql" scheme="http://yoursite.com/tags/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql6之查询性能优化</title>
    <link href="http://yoursite.com/2017/03/15/mysql6%E4%B9%8B%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/03/15/mysql6之查询性能优化/</id>
    <published>2017-03-15T12:52:12.000Z</published>
    <updated>2017-03-15T11:46:20.722Z</updated>
    
    <content type="html"><![CDATA[<p>前一章节讲解了如何设计库表结构及建索引。只有这些并不够。<br>本章主要介绍合理的查询设计。</p>
<h4 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h4><ol>
<li>是否向数据库请求了不需要的数据</li>
</ol>
<ul>
<li>查询不需要的记录（需要20条，查询了100）</li>
<li>多表关联时反悔了全部列 </li>
<li>总是去除所有列（select *）</li>
<li>重复查询相同的数据</li>
</ul>
<ol>
<li>在确定了查询只返回需要的数据以后，接下来看查询是否扫描了过多的数据、</li>
</ol>
<p>最简单的衡量查询的三个指标：</p>
<ul>
<li>响应时间（服务时间+排队时间）</li>
<li>扫描的行数</li>
<li>返回的行数</li>
</ul>
<h4 id="重构查询的方法"><a href="#重构查询的方法" class="headerlink" title="重构查询的方法"></a>重构查询的方法</h4><ol>
<li>一个复杂查询还是多个简单查询</li>
<li>切分查询</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">delete</span> <span class="keyword">from</span> messages <span class="keyword">where</span> created&lt; <span class="keyword">date_sub</span>(<span class="keyword">now</span>(),<span class="built_in">interval</span> <span class="number">3</span> <span class="keyword">month</span>);</div><div class="line"></div><div class="line">rows_affected=</div><div class="line"><span class="keyword">do</span>&#123;</div><div class="line">    rows_affected=do_query(</div><div class="line">    <span class="string">"delete from messages where &lt; date_sub(now(),interval 3 month) limit 10000</span></div><div class="line">    ")</div><div class="line">&#125; <span class="keyword">while</span> rows_affected&gt;<span class="number">0</span></div></pre></td></tr></table></figure>
<ol>
<li>分解关联查询</li>
</ol>
<ul>
<li>让缓存的效率更高</li>
<li>将查询分解后，执行单个查询可以减少锁的竞争</li>
<li>查询本身小老板也可能hi有所提升</li>
<li>可以减少荣誉记录。咋应用层做关联查询</li>
</ul>
<h4 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h4><p>客户端—通信协议—服务器（sql—查询缓存—解析器—解析树—预处理器—解析树<br>—查询优化器—查询执行计划—查询执行引擎—api接口调用—存储引擎—数据<br>）</p>
<p>根据以上步骤 下面分别描述。</p>
<ol>
<li>mysql客户端和服务器通信协议。</li>
</ol>
<p>通信协议是半双工的。要么是服务器向客户端发送，要么是客户端向服务器发送。</p>
<p>查询状态：</p>
<ul>
<li>sleep</li>
<li>query</li>
<li>locked</li>
<li>analyzing and statics</li>
<li>copying to tmp table [on disk]:线程正在执行查询，并且将结果及复制到一个临时表，</li>
<li>sorting result 正在对结果集进行排序</li>
<li>sending data</li>
</ul>
<ol>
<li>查询缓存</li>
</ol>
<p>如果查询缓存是打开的，mysql会优先检查这个查询是否命中查询缓存中的数据，这个检查是通过一个队大小写敏感的哈希查找实现的。查询和缓存中的查询及时只有一个字节不同，那也不会匹配缓存结果。进入下一阶段。</p>
<p>如果刚好命中查询缓存，会进行一次用户权限检查。没问题 返回。</p>
<ol>
<li>查询优化处理</li>
</ol>
<p>语法解析器和预处理：语法正确合法么？数据表数据列存在么？ 验证权限？</p>
<p>查询优化器：</p>
<p>一条查询可以有很多执行方法，都返回相同的结果，优化器的作用找出最好的执行计划。<br>基于成本的优化器、<br>优化策略：静态优化和动态优化。静态优化对解析树直接进行分析，完成优化。通过简单的代数变换将where换成另一等价形式。</p>
<p>能够处理的一些优化类型：</p>
<ul>
<li>重新定义关联表的顺序</li>
<li>将外链接变成内连接</li>
<li>利用等价变换原则</li>
<li><p>优化count min max等</p>
<p>  举例说明：如果查找一列的最小值，只要查询对应btree索引最左端的记录，mysql可以直接获取索引的第一行记录。在优化器生成执行计划的时候，就可以利用这一点。在btree索引中，优化器会将这个表达式当做一个常数暗袋。 最大值同上。<br>  “select tables optimized away”</p>
</li>
<li>预估并转化为常数表达式</li>
<li>覆盖索引扫描</li>
<li>子查询优化</li>
<li>提前终止查询</li>
<li>等值传播： 如果两个列通过登时关联，那么mysql能够把其中一个列的where条件传递到另一列上。</li>
</ul>
<p>执行计划</p>
<p>关联优化器 </p>
<p>排序优化</p>
<ol>
<li><p>查询执行引擎</p>
</li>
<li><p>返回结果给客户端</p>
</li>
</ol>
<p>mysql将结果集返回客户duan是一个增量逐步返回的结果。<br>结果集中的每一行都会以一个满足mysql客户端服务器通信协议的封包发送，再通过tcp协议进行传输。在tcp传输过程中，可能对mysql封包进行缓存然后批量传输。</p>
<h4 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h4><ul>
<li>count</li>
<li>关联查询 a和b用c列关联，优化顺序是ba，只需要在a上建索引就好，没用到的索引只会是负担。</li>
<li>优化子查询 尽量用关联插叙代替</li>
<li>优化group by 和distinct</li>
<li>优化limit： 使用索引覆盖扫描，延迟加载</li>
<li>优化sql_calc_found_rows</li>
<li>union</li>
<li>使用用户自定义变量</li>
</ul>
<h3 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h3><ol>
<li>使用mysql构建一个队列表。</li>
<li>计算两点之间的距离</li>
<li>使用用户自定义函数</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一章节讲解了如何设计库表结构及建索引。只有这些并不够。&lt;br&gt;本章主要介绍合理的查询设计。&lt;/p&gt;
&lt;h4 id=&quot;慢查询基础：优化数据访问&quot;&gt;&lt;a href=&quot;#慢查询基础：优化数据访问&quot; class=&quot;headerlink&quot; title=&quot;慢查询基础：优化数据访问&quot;&gt;
    
    </summary>
    
      <category term="高性能mysql" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
    
      <category term="高性能mysql" scheme="http://yoursite.com/tags/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql之简介</title>
    <link href="http://yoursite.com/2017/03/15/mysql1%E4%B9%8B%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2017/03/15/mysql1之简介/</id>
    <published>2017-03-15T12:52:12.000Z</published>
    <updated>2017-03-15T11:44:44.117Z</updated>
    
    <content type="html"><![CDATA[<p>如果能在头脑中构建衣服MySQL各组件之间如何协同工作的架构图，就会有助于深入了解MySQL服务器。</p>
<p>该架构分为三层：</p>
<p>　　最上层的服务并不是MySQL所独有的，大多数基于网络的客户/服务器的工具或者服务都有类似的架构。</p>
<p>　　第二层架构是MySQL比较有意思的部分。大多数MySQL的核心服务功能都在这一层，包括查询解析，分析，优化</p>
<p>　　缓存，以及所有的内置函数，所有的跨存储引擎的功能都在这一层实现： 存储过程，触发器，视图等。</p>
<p>　　第三层包含了存储引擎。存储引擎负责MySQL中数据的存储和提取。每个存储引擎都有它的优势和劣势。服务器通过</p>
<p>　　API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。</p>
<p>　　存储引擎API包含几十个底层函数，用于执行诸如”开始一个事务” 或者 “根据主键提取一行记录”等操作。</p>
<p>　　但存储引擎不会去解析SQL，不同存储引擎之间也不会相互通信，而只是简单的响应上层服务器的请求。<br>　　<br>　　<br>然后让我们再来认识认识一些MySQL的基本概念。</p>
<ol>
<li>连接管理与安全性</li>
</ol>
<p>　　每个客户端连接都会服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。</p>
<p>　　服务器会负责缓存线程，因为不需要为每一个新建的连接创建或者销毁线程。</p>
<p>　　客户端连接MySQL服务器是需要进行验证的。</p>
<p>2.优化和执行</p>
<p>　　MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行优化， 包括重写查询，决定表的读取顺序，以及选择合适的索引等。</p>
<p>　　用户还可以通过特殊的关键字提示（hint）优化器来影响它的决策过程。（后续都会有详细介绍）</p>
<p>　　优化器并不关心表使用的是什么存储引擎，但存储引擎对优化查询是有影响的。</p>
<p>3.并发控制</p>
<p>　　MySQL在多个查询需要在同一时刻修改数据，都会产生并发控制的问题。</p>
<p>　　MySQL在两个不同的层面存在并发控制：服务器层和存储引擎层。</p>
<p>4.读写锁</p>
<p>　　并发控制的一种很简单的解决方案，就是读写锁。在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。</p>
<p>　　这两种类型的锁通常被称为共享锁和排他锁，也叫读锁和写锁。</p>
<p>　　锁的具体概念如下：读锁是共享的，或者说是互相不阻塞的。写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁。</p>
<p>5.锁粒度</p>
<p>　　表锁</p>
<p>　　行级锁 （innoDB和XtraDB以及其他一些存储引擎中实现了行级锁，行级锁只在存储引擎层实现，MySQL服务器层没有实现）</p>
<p>6.事务</p>
<p>　　ACID：</p>
<p>　　原子性（atomicity），一致性（consistency），隔离性（isolation），持久性（durability）</p>
<p>7.隔离级别</p>
<p>　　READ UNCOMMITED（未提交读）</p>
<p>　　READ COMMITTE（提交读）</p>
<p>　　REPEATABLE READ（可重复读）</p>
<p>　　SERIALIZABLE(可串行化)</p>
<p>8.死锁</p>
<p>9.事务日志</p>
<p>　　它可以帮助提高事务的效率。它减少随机磁盘I/O。</p>
<p>　　目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（write-Ahead Logging），修改数据需要写两次磁盘。</p>
<p>　　（在事务提交后，如果直接写入数据，就会产生大量的随机磁盘I/O.</p>
<p>　　如果使用事务日志，首先将日志写入磁盘，是顺序磁盘I/O，开销会比较小，其次在真正需要写入数据的时候，存储引擎会做相关的顺序优化，尽量减少</p>
<p>　　I/O的产生，然后再慢慢地刷回到磁盘。）</p>
<ol>
<li>存储引擎</li>
</ol>
<p>　　InnoDB引擎</p>
<p>　　MyISAM引擎　　</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果能在头脑中构建衣服MySQL各组件之间如何协同工作的架构图，就会有助于深入了解MySQL服务器。&lt;/p&gt;
&lt;p&gt;该架构分为三层：&lt;/p&gt;
&lt;p&gt;　　最上层的服务并不是MySQL所独有的，大多数基于网络的客户/服务器的工具或者服务都有类似的架构。&lt;/p&gt;
&lt;p&gt;　　第二层
    
    </summary>
    
      <category term="高性能mysql" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
    
      <category term="高性能mysql" scheme="http://yoursite.com/tags/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql7之高级特性</title>
    <link href="http://yoursite.com/2017/03/15/mysql7%E4%B9%8B%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2017/03/15/mysql7之高级特性/</id>
    <published>2017-03-15T12:52:12.000Z</published>
    <updated>2017-03-15T11:51:49.141Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-分区表"><a href="#1-分区表" class="headerlink" title="1.分区表"></a>1.分区表</h3><p>对用户来说，分区表示一个独立的逻辑表，但是底层由多个物理子表组成。</p>
<p>实现分区的代码实际上是对一组底层表的句柄对象的封装。对分区表的请求，都会通过句柄对象转换成对存储引擎的接口调用。</p>
<p>MYSQL 实现分区表的方式-》 对底层表的封装 -》意味着索引也是按照分区的子表定义，而没有全局索引。</p>
<p>mysql实现分区表的方式–对地层表的封装–意味着索引也是按照分区的字表定义的。</p>
<p>分区的一个主要目的是 将数据按照一个较粗的粒度分在不同的表中。</p>
<p>分区表的索引只是在各个底层表各自加上一个完全相同的索引。之于存储引擎，分区表的底层表与普通表没有区别。</p>
<p>分区表的原理：</p>
<p>select :当查询一个分区表的时候，分区表先打开并锁住所有的底层表，优化器线盘短是否可以过滤部分分区，然后在调用对应的存储引擎接口访问各个分区的数据。</p>
<p>insert：当写入一条记录时，分区层先打开并锁住所有的底层表，然后确定哪个分区接受这条记录。再将记录写入到对应底层表中。</p>
<p>delete和update同上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">CREATE TABLE <span class="title">sales</span> <span class="params">(</span></span></div><div class="line">　　order_date DATETIME NOT NULL,</div><div class="line">　　-- Other columns omitted</div><div class="line">) ENGINE=<span class="function">InnoDB PARTITION BY <span class="title">RANGE</span><span class="params">(YEAR(order_date)</span>) <span class="params">(</span></span></div><div class="line">PARTITION p_2010 VALUES LESS THAN (<span class="number">2010</span>),</div><div class="line">PARTITION p_2011 VALUES LESS <span class="title">THAN</span> <span class="params">(<span class="number">2011</span>)</span>,</div><div class="line">PARTITION p_2012 VALUES LESS <span class="title">THAN</span> <span class="params">(<span class="number">2012</span>)</span>,</div><div class="line">PARTITION p_catchall VALUES LESS THAN MAXVALUE );</div></pre></td></tr></table></figure>
<h3 id="2-视图"><a href="#2-视图" class="headerlink" title="2.视图"></a>2.视图</h3><p>视图：</p>
<ul>
<li>视图本身是一个虚拟表，不存放任何数据。</li>
<li>在使用sql语句访问视图的时候，它返回的数据是Mysql从其他表生成的。</li>
<li>视图和表在同一个命名空间，MySQL在很多地方低于视图和表是同样对待的。</li>
<li>不过视图和表也有不同，例如，不能对视图创建触发器，也不呢过使用drop table 命令删除视图</li>
</ul>
<p>实现算法：</p>
<p>merge: 合并算法，尽可能使用这个</p>
<p>Temptable：临时表算法。如果视图中高寒GROUP BU, DISTINCT, 任何聚合函数, UNION, 子查询等<br>　　只要无法在原表记录和视图记录建立一一映射的场景中，mysql都将用临时表算法实现视图。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">view</span> oceania <span class="keyword">as</span> </div><div class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> country <span class="keyword">where</span> continent=<span class="string">'oceania'</span></div><div class="line">    <span class="keyword">with</span> <span class="keyword">check</span> opition;</div><div class="line"><span class="keyword">select</span> code,<span class="keyword">name</span> <span class="keyword">from</span> oceania <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'australia'</span>;</div><div class="line"></div><div class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span> tmp_oca <span class="keyword">as</span> </div><div class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> country <span class="keyword">where</span> cotinent=<span class="string">'sss'</span>;</div></pre></td></tr></table></figure>
<h3 id="3-外键约束"><a href="#3-外键约束" class="headerlink" title="3.外键约束"></a>3.外键约束</h3><h3 id="4-在mysql内部存储代码"><a href="#4-在mysql内部存储代码" class="headerlink" title="4.在mysql内部存储代码"></a>4.在mysql内部存储代码</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-分区表&quot;&gt;&lt;a href=&quot;#1-分区表&quot; class=&quot;headerlink&quot; title=&quot;1.分区表&quot;&gt;&lt;/a&gt;1.分区表&lt;/h3&gt;&lt;p&gt;对用户来说，分区表示一个独立的逻辑表，但是底层由多个物理子表组成。&lt;/p&gt;
&lt;p&gt;实现分区的代码实际上是对一组底层表
    
    </summary>
    
      <category term="高性能mysql" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
    
      <category term="高性能mysql" scheme="http://yoursite.com/tags/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL2之schema设计优化</title>
    <link href="http://yoursite.com/2017/03/15/MySQL2%E4%B9%8Bschema%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/03/15/MySQL2之schema设计优化/</id>
    <published>2017-03-15T12:52:12.000Z</published>
    <updated>2017-03-15T11:45:24.980Z</updated>
    
    <content type="html"><![CDATA[<p>良好的逻辑设计和物理设计是高性能的基石，应该根据系统要执行的查询语句来设计 schema。这往往需要权衡各种因素。</p>
<p>例如：反范式的设计可以加快某些类型的查询，但同时可能使另一些类型的查询变慢。比如添加计数表和汇总表是一种很好的优化查询的方式，</p>
<p>但是这些表的维护成本会很高。MySQL独有的特性和实现细节对性能影响也很大。</p>
<p>选择优化的数据类型的简单原则：</p>
<p>　　1.更小的通常更好</p>
<p>　　　　一般情况下，应该尽量使用可以正确存储数据的最小数据类型。</p>
<p>　　2.简单就好</p>
<p>　　　　简单数据类型的操作通常需要更少的cpu周期。</p>
<p>　　3.尽量避免NULL</p>
<p>　　　　如果查询包含可为NULL的列，对mysql来说更难优化，因为可为NULL的列使得索引，索引统计，值比较都更复杂。</p>
<p>　　　　可为NULL的列会使用更多的存储空间，在MySQL里也需要特殊处理。</p>
<p>schema设计的第一步，那就是建表，建表的第一步呢就是设计字段，然而了解mysql的数据类型又对设计字段有莫大的帮助。</p>
<p>那我们先来了解mysql的基本数据类型吧。</p>
<p>1.整数类型</p>
<p>　　TINYINT, SMALLINT,MEDIUMINT,INT,BIGINT</p>
<p>　　8，16，24，32，64，位存储空间。</p>
<p>　　MySQL可为整数类型制定宽度，例如INT（11），但对大多数应用这是没意义的；它不会限制值合法范围。对于存储和计算来说</p>
<p>　　INT(1) 和 INT(20)是相同的</p>
<p>2.实数类型</p>
<p>　　FLOAT,DOUBLE,DECIMAL(精确计算用的)</p>
<p>3.字符串类型</p>
<p>　　VARCHARE</p>
<p>　　　　最常见的字符串类型。它比定长类型更节省空间，因为它仅适用必要的空间。有一种情况例外，如果MySQL表使用ROW_FORMAT=FIXED创建的话。</p>
<p>　　　　VARCHAR需要适用1或2个额外字节记录字符串的长度。如果列的最大长度小于等于255，则使用一个字节记录长度。</p>
<p>　　CHAR</p>
<p> 　　　　是定长的。MySQL总是根据定义的字符串分配足够的空间。当存储CHAR值时，MySQL会删除所有的末尾空格。</p>
<p>　　　　CHAR值会根据需要采用空格填充以方便比较。</p>
<p>　　　　CHAR适合存储很短的字符串。对于经常变更的数据，CHAR也比VARCHAR更好，因为定长CHAR类型不容易产生碎片。</p>
<p>　　BLOB和TEXT</p>
<p>　　　　BLOB和TEXT都是为存储很大数据而设计的字符串数据类型，分别采用二进制和字符方式存储。</p>
<p>　　使用枚举（ENUM）代替字符串类型</p>
<p>4.日期和时间类型</p>
<p>　　DATETIME</p>
<p>　　　　这个类型能保存大范围的值。从1001年到9999年，精度为妙。</p>
<p>　　TIMESTAMP</p>
<p> 　　　　存储空间小，并且会根据时区变化，有特殊的自动更新能力。精度为妙。</p>
<p>　　如果要存储比秒更小粒度的时间时，可以用bigint类型存储微秒级别的时间戳。</p>
<p>5.位数据类型</p>
<p>　　BIT</p>
<p>标识符的选择：</p>
<p>　　整数类型</p>
<p>　　　　整数通常是标识列的最好选择。因为他们很快，并且可以使用auto_increment</p>
<p>　　enum 和 set 类型</p>
<p>　　</p>
<p>　　字符串类型</p>
<p>　　　　如果可能，尽量避免使用字符串类型作为标识符，因为它们很消耗空间，并且通常比数字类型慢。</p>
<p>　　　　尤其在MyISAM表里使用字符串作为标识列时要特别小心。MyISAM默认对字符串使用压缩索引，这会使查询很慢。</p>
<p>　　　　对于完全’随机’的字符串也需要多加注意，例如md5(),sha1(),uuid()产生的字符串。</p>
<p>　　　　这些函数生成的新值会任意分布在很大的空间内，这会导致insert以及一些select语句变得很慢：</p>
<p>　　　　　　1.因为插入值会随机写到索引的不同位置，所以使得insert语句更慢。这会导致页分裂，磁盘随机访问，以及对于聚簇存储引擎产生聚簇索引碎片。</p>
<p>　　　　　　2.select语句会变得更慢，因为逻辑上相邻的行为分布在磁盘和内存的不同地方。</p>
<p>　　　　　　3.随机值会导致缓存对所有类型的查询语句效果都很差。</p>
<p>schema设计中的陷阱</p>
<p>　　1.太多的列</p>
<p>　　2.太多的关联</p>
<p>　　3.全能的枚举</p>
<p>　　</p>
<p>范式和反范式</p>
<p>　　三大范式：　　</p>
<p>　　　　1.必须有主键，列不可分　　</p>
<p>　　　　2.当一个表是复合主键时，非主键的字段不依赖于部分主键(即必须依赖于全部的主键字段)</p>
<p>　　　　3.关系模式R（U，F）中的所有非主属性对任何候选关键字都不存在传递依赖</p>
<p>　　反范式，顾名思义，不遵守三大范式。</p>
<p>　　首先我们来看看范式的优缺点：</p>
<p>　　优点：</p>
<p>　　　　范式化的更新操作通常比反范式快。</p>
<p>　　　　当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据</p>
<p>　　　　范式化的表通常很小，可以更好的放在内存里，所以执行操作会更快。</p>
<p>　　　　很少有多余的数据意味着检索列表数据更少需要DISTINCT或者GROUP BY语句。</p>
<p>　　缺点：</p>
<p>　　　　过度依赖关联。这不但代价昂贵，也可能使一些索引策略无效。</p>
<p>　　反范式优缺点：</p>
<p>　　　　因为所有的数据在一张表中，可以很好的避免关联。</p>
<p>　　　　如果不需要关联，则对大部分查询最差的情况，即使没有使用索引，是全表扫描，当数据比内存大时这可能比关联要快得多，</p>
<p>　　　　因为这样避免了随机I/O。</p>
<p>　　　　单独的表能更好的使用索引策略。</p>
<p>　混用范式和反范式才是schema设计的主流。</p>
<p>缓存表和汇总表</p>
<p>　　方便查询，不易维护。</p>
<p>物化视图</p>
<p>　　</p>
<p>计数器表</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;良好的逻辑设计和物理设计是高性能的基石，应该根据系统要执行的查询语句来设计 schema。这往往需要权衡各种因素。&lt;/p&gt;
&lt;p&gt;例如：反范式的设计可以加快某些类型的查询，但同时可能使另一些类型的查询变慢。比如添加计数表和汇总表是一种很好的优化查询的方式，&lt;/p&gt;
&lt;p&gt;但
    
    </summary>
    
      <category term="高性能mysql" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
    
      <category term="高性能mysql" scheme="http://yoursite.com/tags/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql5之创建高性能的索引</title>
    <link href="http://yoursite.com/2017/03/15/mysql5%E4%B9%8B%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2017/03/15/mysql5之创建高性能的索引/</id>
    <published>2017-03-15T12:52:12.000Z</published>
    <updated>2017-03-15T11:45:58.200Z</updated>
    
    <content type="html"><![CDATA[<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ol>
<li><p>btree</p>
<p> 对索引列是顺序组织存储的，并且每一个叶子页到根的距离相同。B-Tree对索引是顺序组织存储的，所以很适合查找范围数据。<br>　　B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。索引还可以用于查询中的 order by 操作。<br>　　<br>　　一些限制：<br>　　- 如果不是安装索引的最左列开始查找，则无法使用索引<br>　　- 不能跳过索引中的列<br>　　- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找
　　</p>
</li>
<li><p>hash</p>
<p> 哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。<br> 哈希索引只需存储对应的哈希值，所以索引结构十分紧凑，使查找很快</p>
<p> 一些限制：</p>
<ul>
<li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行</li>
<li>哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序</li>
<li>哈希索引只支持等值比较查询</li>
</ul>
</li>
<li><p>创建自定义哈希索引</p>
</li>
</ol>
<h3 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h3><h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><p>如果查询中的列不是独立的，则MySQL就不会使用索引。“独立的列”是指索引的列不能是表达式的一部分，也不是函数的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt;SELECT actor_id FROM sakila.actor WHERE actor_id + 1 =5;</div><div class="line">mysql&gt;SELECt ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAY(date_col) &lt;= 10;</div></pre></td></tr></table></figure>
<h4 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h4><p>有时候需要索引很长的字符列，这会让索引变得大且慢。一个策略是前面提到过的模拟哈希索引。但有时候这样做还不够，通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率，但这样会降低索引的选择性。索引的选择性是指，不重复的索引值(也称为基数，cardinality)和数据表的记录总数(#T)的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高。唯一索引的选择性是1，这是最好的索引选择性，性能是最好的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">key</span>(col_name(prefix_length));</div></pre></td></tr></table></figure>
<h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><p>一个常见错误就是，为每个列创建独立索引，或者按照错误的顺序创建多列索引。在多个列上创建索引大部分情况下并不能提高MySQL的查询性能。MySQL 5.0 及更新的版本引入了索引合并策略（index merge），查询能够同时使用这两个单列索引进行扫描，并将结果进行合并。这种算法有三个变种：OR 条件的联合（union）， AND 条件的相交（intersection），组合前两种情况的联合及相交。</p>
<h4 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h4><p>在一个多列的 B-Tree 索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。索引可以安装升序或者降序进行扫描，以满足精确符合列顺序的 order by, group by, distinct 等子句的查询需求。考虑索引列的顺序时，将选择性最高的列放到索引列最前列，但通常不如避免随机 IO 和排序重要。性能不只是依赖于所有索引列的选择性，也和值的分布有关。（ 需要总和考虑选择性、基数、排序、分组、范围条件、值分布等因素 ）</p>
<h4 id="聚族索引"><a href="#聚族索引" class="headerlink" title="聚族索引"></a>聚族索引</h4><p>聚族索引（Oracle 里对应的是 索引组织表，index-organized table, IOT）并不是一种单独的索引类型，而是一种数据存储方式。</p>
<p>当表有聚族索引时，它的数据行实际上是存放在索引的叶子页中。聚族表示数据行和相邻的键值紧凑地存储在一起。聚族索引的叶子页包含了行的全部数据，但是节点页只包含了索引列。</p>
<p>聚族索引的优点:</p>
<ul>
<li>以把相关的数据保存在一起。（利用数据的临近性）</li>
<li>数据访问更快。由于索引和数据都在同一个 B-Tree 中，从聚族索引获取数据比非聚族索引要快。</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li>
</ul>
<p>聚族索引的缺点：</p>
<ul>
<li>插入速度严重依赖于插入顺序。按照聚族列的顺序插入是最快的方式。</li>
<li>更新聚族索引列的代价很高，因为 InnoDB 将强制每个被更新的行移动到新的位置。</li>
<li>基于聚族索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂（page split）的问题。</li>
<li>聚族索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续。</li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>通过覆盖索引来优化。</p>
<h4 id="使用索引扫描来排序"><a href="#使用索引扫描来排序" class="headerlink" title="使用索引扫描来排序"></a>使用索引扫描来排序</h4><p>MySQL通过两种方式生成有序结果：通过排序操作，或，按索引顺序扫描。当 Explain的结果中 type 为index，就说明MySQL用了索引扫描来做排序了。</p>
<h4 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(</div><div class="line">    <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</div><div class="line">    a <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    b <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    <span class="keyword">unique</span>(<span class="keyword">id</span>),</div><div class="line">    <span class="keyword">index</span>(<span class="keyword">id</span>)</div><div class="line">) <span class="keyword">engine</span> =<span class="keyword">innodb</span></div></pre></td></tr></table></figure>
<p>一个经验不足的用户可能是想幢见一个主键，先加上唯一限制，然后再加上索引以供查询使用，事实上，唯一索引和主键限制都是通过索引实现的，上面的写法实际上创建了三个重复的索引。</p>
<p>冗余索引和重复所以有一些不同，如果创建了索引（a，b） 再创建a，就是冗余的。</p>
<h3 id="优化案例"><a href="#优化案例" class="headerlink" title="优化案例"></a>优化案例</h3><p>一个在线约惠王占，用户列表有很多咧，包括国家，地区城市性别，眼睛颜色等。网站比徐支持上面的这些特征的各种组合来搜索用户。还要允许根据用户的最后在线时间，其他会员对用户的评分等做排序并对结果进行排序，如何设计索引？</p>
<ol>
<li><p>支持多种过滤条件(利用in来使用索引，从而恶意匹配到后面的部分)<br>sex in(“m”,”f”) age放到最后面，因为是范围匹配。</p>
</li>
<li><p>避免多个范围条件</p>
</li>
</ol>
<p>例如 last_online&gt;date_sub(now(), interval 7 day) and age between 18 and 25</p>
<p>mysql无法同时使用last_online和age索引。</p>
<ol>
<li>优化排序</li>
</ol>
<p>对于一些选择性非常低的列，可以增加一些也输得索引来做排序，比如可以创建（sex，rating）索引用于下面的查询。</p>
<p>即使如厕，使用limit到哦后面的页数 也会很慢。可以使用延迟关联来优化。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> &lt;cols&gt; <span class="keyword">from</span> <span class="keyword">profiles</span> <span class="keyword">inner</span> <span class="keyword">join</span> (</div><div class="line">    <span class="keyword">select</span> &lt;primary <span class="keyword">key</span> cols&gt; <span class="keyword">from</span> <span class="keyword">profiles</span> </div><div class="line">    <span class="keyword">where</span> x.sex=<span class="string">'m'</span> <span class="keyword">order</span> <span class="keyword">by</span> rating <span class="keyword">limit</span> <span class="number">100000</span>,<span class="number">10</span></div><div class="line">) <span class="keyword">as</span> x <span class="keyword">using</span> (&lt;primary <span class="keyword">key</span> cols&gt;)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;索引类型&quot;&gt;&lt;a href=&quot;#索引类型&quot; class=&quot;headerlink&quot; title=&quot;索引类型&quot;&gt;&lt;/a&gt;索引类型&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;btree&lt;/p&gt;
&lt;p&gt; 对索引列是顺序组织存储的，并且每一个叶子页到根的距离相同。B-Tree对索引是
    
    </summary>
    
      <category term="高性能mysql" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
    
      <category term="高性能mysql" scheme="http://yoursite.com/tags/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
  </entry>
  
  <entry>
    <title>java面试宝典注意点</title>
    <link href="http://yoursite.com/2017/03/02/java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>http://yoursite.com/2017/03/02/java面试宝典注意点/</id>
    <published>2017-03-02T01:38:44.000Z</published>
    <updated>2017-03-03T10:34:10.303Z</updated>
    
    <content type="html"><![CDATA[<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ol>
<li><p>字符串对象池的作用？</p>
</li>
<li><p>stringbuffer stringbuild？</p>
</li>
<li><p>如何使用指定的字符集创建对象？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String a=&quot;中文&quot;;</div><div class="line">String b= new String(a.getbytes(),&quot;UTF-8&quot;);</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ol>
<li><p>java 数组是一个类么？<br>本质上是一个类。</p>
</li>
<li><p>数组拷贝？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arrays.copyof();</div><div class="line">system.arraycopy();</div></pre></td></tr></table></figure>
</li>
<li><p>iterator迭代器</p>
</li>
<li>比较器 comparable comparator</li>
<li>vector 和 arraylist的区别</li>
<li>hashmap hashtable</li>
<li>集合使用泛型的好处 （可以达到元素类型明确的目的，避免手动类型转换）</li>
<li>符合什么条件的数据集合可以使用foreach ？ 数组或者实现iterable</li>
</ol>
<h4 id="io"><a href="#io" class="headerlink" title="io"></a>io</h4><ol>
<li><p>文件复制</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String inputpath, String outpath)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		File rfile = <span class="keyword">new</span> File(inputpath);<span class="comment">//读取的文件</span></div><div class="line">		File wfile = <span class="keyword">new</span> File(outpath);<span class="comment">//写入的文件</span></div><div class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(rfile)));</div><div class="line">		BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(wfile,<span class="keyword">true</span>)));</div><div class="line">		<span class="keyword">for</span>(String line = br.readLine(); line != <span class="keyword">null</span>; line = br.readLine())&#123;</div><div class="line">		   bw.write(line);</div><div class="line">		   bw.newLine();</div><div class="line">		   bw.flush();</div><div class="line">		&#125;</div><div class="line">		bw.close();</div><div class="line">		br.close();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>随机存取文件  RandomAccessFile</p>
</li>
<li><p>字节流的处理方式<br> 字节流处理单位是byte，操作byte数组，通过read和write方法进行操作。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span>[] buff=nnew <span class="keyword">byte</span>[<span class="number">256</span>];</div><div class="line"><span class="keyword">int</span> len=<span class="number">0</span>;</div><div class="line"><span class="keyword">while</span>((len=fin.read(buff))&gt;<span class="number">0</span>)&#123;</div><div class="line">	fout.write(buff,<span class="number">0</span>,len);&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>字符流的处理方式</p>
</li>
<li>序列化？ java.io.serializable Externalizable</li>
</ol>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ol>
<li>编写一个生产者消费者模型</li>
<li>线程池怎么使用？ threadpoolexecutor</li>
</ol>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><ol>
<li>反射的原理？</li>
<li>反射。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span>.<span class="title">forname</span>().<span class="title">newInstance</span>()</span>;</div><div class="line">constructor(Student) con=<span class="class"><span class="keyword">class</span>.<span class="title">forname</span>().<span class="title">getconstructor</span>(<span class="title">String</span>.<span class="title">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</div><div class="line">con.newInstance(<span class="string">"zzz"</span>,<span class="number">1</span>);</div><div class="line">Class clazz=obj.getclass();</div><div class="line">field f=clazz.getDeclaredField(<span class="string">"ss"</span>);</div><div class="line">f.setaccessible（<span class="keyword">true</span>）;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h4><ol>
<li><p>tcp协议的特点</p>
<p> 面向连接的 可靠地 基于字节流的运输层通信协议。</p>
<p> 应用层向tcp层发送8位字节表示的数据流，然后tcp吧数据流分割成适当长度的报文段，之后tcp把结果传给ip层，有他通过网络将包传送给接收端实体的tcp层。tcp为了保证不发生丢包，采用一种精确地确认机制，一旦发送失败将提供重新发送的机会。可以保证数据的可靠传输。</p>
<p> tcp提供一种端口机制，用于区分各种网络应用程序。</p>
</li>
<li><p>java中tcp变成模型</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">serversocket ss = <span class="keyword">new</span> serversocket(<span class="number">8080</span>);</div><div class="line">socket  socket=ss.accept();</div><div class="line">outputstream os=socket.getoutputstream();</div><div class="line">inputstream is=socket.getinputstream();</div></pre></td></tr></table></figure>
</li>
<li><p>udp的特点</p>
<p> 面向数据包的传输层协议，不提供对ip协议的可靠机制 流控制和错误恢复机制。 他的头部包含比较少的字节，比tcp负载消耗少，熟读快、</p>
<p> udp是一个无连接的协议。传输数据之前源端和终端不建立连接，当它想传送石就简单的去抓送来自应用程序的数据，并尽可能块的把它扔到网络上。<br> 不需要维护连接状态，包括收发状态。字节开销少。</p>
</li>
<li><p>udp编程模型</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">datagramsocket ds= <span class="keyword">new</span> datagramsocket(<span class="number">9999</span>);</div><div class="line"><span class="keyword">byte</span>[] buff= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">datagrampacket dp= <span class="keyword">new</span> datagrampacket(buff,<span class="number">1024</span>);</div><div class="line">ds.receive(dp)</div></pre></td></tr></table></figure>
</li>
<li><p>如何创建tcp通信的服务器端的多线程模型</p>
</li>
<li>用tcp通信模型创建一个web服务器</li>
<li></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;字符串对象池的作用？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;stringbuffer stri
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍15-nio1</title>
    <link href="http://yoursite.com/2017/02/27/15-javanio/"/>
    <id>http://yoursite.com/2017/02/27/15-javanio/</id>
    <published>2017-02-27T12:52:12.000Z</published>
    <updated>2017-02-27T08:30:22.464Z</updated>
    
    <content type="html"><![CDATA[<p>在Java1.4之前的I/O系统中，提供的都是面向流的I/O系统，系统一次一个字节地处理数据，一个输入流产生一个字节的数据，一个输出流消费一个字节的数据，面向流的I/O速度非常慢，而在Java 1.4中推出了NIO，这是一个面向块的I/O系统，系统以块的方式处理处理，每一个操作在一步中产生或者消费一个数据库，按块处理要比按字节处理数据快的多。</p>
<p>在NIO中有几个核心对象需要掌握：缓冲区（Buffer）、通道（Channel）、选择器（Selector）。</p>
<h4 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h4><p>缓冲区实际上是一个容器对象，更直接的说，其实就是一个数组，在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的； 在写入数据时，它也是写入到缓冲区中的；任何时候访问 NIO 中的数据，都是将它放到缓冲区中。</p>
<p>在NIO中，所有的缓冲区类型都继承于抽象类Buffer，最常用的就是ByteBuffer.继承关系如下：</p>
<ul>
<li>buffer<ul>
<li>bytebuffer - mappedbytedbuffer </li>
<li>charbuffer</li>
<li>doublebuffer</li>
<li>floatbuffer</li>
<li>intbuffer</li>
<li>longbuffer</li>
<li>shortbuffer</li>
</ul>
</li>
</ul>
<h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><p>通道是一个对象，通过它可以读取和写入数据，当然了所有数据都通过Buffer对象来处理。我们永远不会将字节直接写入通道中，相反是将数据写入包含一个或者多个字节的缓冲区。同样不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</p>
<h4 id="使用NIO读取数据"><a href="#使用NIO读取数据" class="headerlink" title="使用NIO读取数据"></a>使用NIO读取数据</h4><p>一个简单的读写例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> nio;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">niotest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		write();</div><div class="line">		FileInputStream fin= <span class="keyword">new</span> FileInputStream(<span class="string">"e:\\test.txt"</span>);</div><div class="line">		FileChannel fc= fin.getChannel();</div><div class="line">		</div><div class="line">		ByteBuffer buffer=ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">		</div><div class="line">		fc.read(buffer);</div><div class="line">		</div><div class="line">		buffer.flip();</div><div class="line">		</div><div class="line">		<span class="keyword">while</span>(buffer.remaining()&gt;<span class="number">0</span>)&#123;</div><div class="line">			<span class="keyword">byte</span> b=buffer.get();</div><div class="line">			System.out.print((<span class="keyword">char</span>)b);</div><div class="line">		&#125;</div><div class="line">		fin.close();</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">		<span class="keyword">byte</span> message[] = &#123; <span class="number">83</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">32</span>,  </div><div class="line">		        <span class="number">98</span>, <span class="number">121</span>, <span class="number">116</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">46</span> &#125;;</div><div class="line">		FileOutputStream fout = <span class="keyword">new</span> FileOutputStream( <span class="string">"e:\\test.txt"</span> );  </div><div class="line">        </div><div class="line">        FileChannel fc = fout.getChannel();  </div><div class="line">          </div><div class="line">        ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );  </div><div class="line">          </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;message.length; ++i) &#123;  </div><div class="line">            buffer.put( message[i] );  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        buffer.flip();  </div><div class="line">          </div><div class="line">        fc.write( buffer );  </div><div class="line">          </div><div class="line">        fout.close();  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java1.4之前的I/O系统中，提供的都是面向流的I/O系统，系统一次一个字节地处理数据，一个输入流产生一个字节的数据，一个输出流消费一个字节的数据，面向流的I/O速度非常慢，而在Java 1.4中推出了NIO，这是一个面向块的I/O系统，系统以块的方式处理处理，每一个
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍16-nio2</title>
    <link href="http://yoursite.com/2017/02/27/15-javanio2/"/>
    <id>http://yoursite.com/2017/02/27/15-javanio2/</id>
    <published>2017-02-27T12:52:12.000Z</published>
    <updated>2017-02-27T08:44:34.886Z</updated>
    
    <content type="html"><![CDATA[<p>在第一篇中，我们介绍了NIO中的两个核心对象：缓冲区和通道，在谈到缓冲区时，我们说缓冲区对象本质上是一个数组，但它其实是一个特殊的数组，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况，如果我们使用get()方法从缓冲区获取数据或者使用put()方法把数据写入缓冲区，都会引起缓冲区状态的变化。本文为NIO使用及原理分析的第二篇，将会分析NIO中的Buffer对象。</p>
<p>在缓冲区中，最重要的属性有下面三个，它们一起合作完成对缓冲区内部状态的变化跟踪：</p>
<ul>
<li>position：指定了下一个将要被写入或者读取的元素索引，它的值由get()/put()方法自动更新，在新创建一个Buffer对象时，position被初始化为0。</li>
<li>limit：指定还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。</li>
<li>capacity：指定了可以存储在缓冲区中的最大数据容量，实际上，它指定了底层数组的大小，或者至少是指定了准许我们使用的底层数组的容量。<br>以上四个属性值之间有一些相对大小的关系：0 &lt;= position &lt;= limit &lt;= capacity。如果我们创建一个新的容量大小为10的ByteBuffer对象，在初始化的时候，position设置为0，limit和 capacity被设置为10，在以后使用ByteBuffer对象过程中，capacity的值不会再发生变化，而其它两个个将会随着使用而变化。</li>
</ul>
<h4 id="变化过程"><a href="#变化过程" class="headerlink" title="变化过程"></a>变化过程</h4><p>以上四个属性值之间有一些相对大小的关系：0 &lt;= position &lt;= limit &lt;= capacity。如果我们创建一个新的容量大小为10的ByteBuffer对象，在初始化的时候，position设置为0，limit和 capacity被设置为10，在以后使用ByteBuffer对象过程中，capacity的值不会再发生变化，而其它两个个将会随着使用而变化、</p>
<p>现在我们可以从通道中读取一些数据到缓冲区中，注意从通道读取数据，相当于往缓冲区中写入数据。如果读取4个自己的数据，则此时position的值为4，即下一个将要被写入的字节索引为4，而limit仍然是10</p>
<p>下一步把读取的数据写入到输出通道中，相当于从缓冲区中读取数据，在此之前，必须调用flip()方法，该方法将会完成两件事情：</p>
<ol>
<li>把limit设置为当前的position值 </li>
<li>把position设置为0</li>
</ol>
<p>由于position被设置为0，所以可以保证在下一步输出时读取到的是缓冲区中的第一个字节，而limit被设置为当前的position，可以保证读取的数据正好是之前写入到缓冲区中的数据，</p>
<p>现在调用get()方法从缓冲区中读取数据写入到输出通道，这会导致position的增加而limit保持不变，但position不会超过limit的值，所以在读取我们之前写入到缓冲区中的4个自己之后，position和limit的值都为4</p>
<p>在从缓冲区中读取数据完毕后，limit的值仍然保持在我们调用flip()方法时的值，调用clear()方法能够把所有的状态变化设置为初始化时的值。</p>
<p>实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> nio;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</div><div class="line"><span class="keyword">import</span> java.nio.Buffer;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">niotest2</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(String step, Buffer buffer)</span> </span>&#123;  </div><div class="line">        System.out.println(step + <span class="string">" : "</span>);  </div><div class="line">        System.out.print(<span class="string">"capacity: "</span> + buffer.capacity() + <span class="string">", "</span>);  </div><div class="line">        System.out.print(<span class="string">"position: "</span> + buffer.position() + <span class="string">", "</span>);  </div><div class="line">        System.out.println(<span class="string">"limit: "</span> + buffer.limit());  </div><div class="line">        System.out.println();  </div><div class="line">    &#125;  </div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		FileInputStream fin=<span class="keyword">new</span> FileInputStream(<span class="string">"e:\\test.txt"</span> );</div><div class="line">		FileChannel fc=fin.getChannel();</div><div class="line">		</div><div class="line">		ByteBuffer buffer= ByteBuffer.allocate(<span class="number">10</span>);</div><div class="line">		output(<span class="string">"初始化"</span>, buffer);</div><div class="line">		</div><div class="line">		fc.read(buffer);  </div><div class="line">        output(<span class="string">"调用read()"</span>, buffer);</div><div class="line">        </div><div class="line">        buffer.flip();  </div><div class="line">        output(<span class="string">"调用flip()"</span>, buffer);  </div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (buffer.remaining() &gt; <span class="number">0</span>) &#123;  </div><div class="line">            <span class="keyword">byte</span> b = buffer.get();  </div><div class="line">            <span class="comment">// System.out.print(((char)b));  </span></div><div class="line">        &#125;  </div><div class="line">        output(<span class="string">"调用get()"</span>, buffer); </div><div class="line">        </div><div class="line">        buffer.clear();  </div><div class="line">        output(<span class="string">"调用clear()"</span>, buffer);  </div><div class="line">  </div><div class="line">        fin.close();  </div><div class="line">		</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>result:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">初始化 : </div><div class="line">capacity: <span class="number">10</span>, position: <span class="number">0</span>, limit: <span class="number">10</span></div><div class="line"></div><div class="line">调用read() : </div><div class="line">capacity: <span class="number">10</span>, position: <span class="number">10</span>, limit: <span class="number">10</span></div><div class="line"></div><div class="line">调用flip() : </div><div class="line">capacity: <span class="number">10</span>, position: <span class="number">0</span>, limit: <span class="number">10</span></div><div class="line"></div><div class="line">调用get() : </div><div class="line">capacity: <span class="number">10</span>, position: <span class="number">10</span>, limit: <span class="number">10</span></div><div class="line"></div><div class="line">调用clear() : </div><div class="line">capacity: <span class="number">10</span>, position: <span class="number">0</span>, limit: <span class="number">10</span></div></pre></td></tr></table></figure>
<p>转载：<a href="http://blog.csdn.net/wuxianglong/article/details/6612246" target="_blank" rel="external">http://blog.csdn.net/wuxianglong/article/details/6612246</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在第一篇中，我们介绍了NIO中的两个核心对象：缓冲区和通道，在谈到缓冲区时，我们说缓冲区对象本质上是一个数组，但它其实是一个特殊的数组，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况，如果我们使用get()方法从缓冲区获取数据或者使用put()方法把数据写入缓
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍15-nio 总结</title>
    <link href="http://yoursite.com/2017/02/27/15-javanio5/"/>
    <id>http://yoursite.com/2017/02/27/15-javanio5/</id>
    <published>2017-02-27T12:52:12.000Z</published>
    <updated>2017-02-27T10:29:49.608Z</updated>
    
    <content type="html"><![CDATA[<p>Java NIO 由以下几个核心部分组成：</p>
<ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>
<p>下面是JAVA NIO中的一些主要Channel的实现：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>正如你所看到的，这些通道涵盖了UDP 和 TCP 网络IO，以及文件IO。</p>
<p>以下是Java NIO里关键的Buffer实现：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如，在一个聊天服务器中。</p>
<p>要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。</p>
<p>总结：</p>
<p>为什么使用nio？</p>
<p>NIO 的创建目的是为了让 Java 程序员可以实现高速 I/O 而无需编写自定义的本机代码。NIO 将最耗时的 I/O 操作(即填充和提取缓冲区)转移回操作系统，因而可以极大地提高速度。</p>
<p>文件读写实例:</p>
<p><a href="http://blog.csdn.net/chenleixing/article/details/44207469" target="_blank" rel="external">http://blog.csdn.net/chenleixing/article/details/44207469</a></p>
<p>nio和io比较分析：</p>
<p>NIO 设计背后的基石：反应器模式，用于事件多路分离和分派的体系结构模式。 </p>
<p>反应器（Reactor）：用于事件多路分离和分派的体系结构模式 </p>
<p>通常的，对一个文件描述符指定的文件或设备, 有两种工作方式: 阻塞 与非阻塞 。所谓阻塞方式的意思是指, 当试图对该文件描述符进行读写时, 如果当时没有东西可读,或者暂时不可写, 程序就进入等待 状态, 直到有东西可读或者可写为止。而对于非阻塞状态, 如果没有东西可读, 或者不可写, 读写函数马上返回, 而不会等待 。 </p>
<p>一种常用做法是：每建立一个Socket连接时，同时创建一个新线程对该Socket进行单独通信（采用阻塞的方式通信）。这种方式具有很高的响应速度，并且控制起来也很简单，在连接数较少的时候非常有效，但是如果对每一个连接都产生一个线程的无疑是对系统资源的一种浪费，如果连接数较多将会出现资源不足的情况。 </p>
<p>另一种较高效的做法是：服务器端保存一个Socket连接列表，然后对这个列表进行轮询，如果发现某个Socket端口上有数据可读时（读就绪），则调用该socket连接的相应读操作；如果发现某个 Socket端口上有数据可写时（写就绪），则调用该socket连接的相应写操作；如果某个端口的Socket连接已经中断，则调用相应的析构方法关闭该端口。这样能充分利用服务器资源，效率得到了很大提高。 </p>
<p>转自：<a href="http://javag.javaeye.com/blog/221641" target="_blank" rel="external">http://javag.javaeye.com/blog/221641</a> </p>
<p>传统的阻塞式IO，每个连接必须要开一个线程来处理，并且没处理完线程不能退出。 </p>
<p>非阻塞式IO，由于基于反应器模式，用于事件多路分离和分派的体系结构模式，所以可以利用线程池来处理。事件来了就处理，处理完了就把线程归还。而传统阻塞方式不能使用线程池来处理，假设当前有10000个连接，非阻塞方式可能用1000个线程的线程池就搞定了，而传统阻塞方式就需要开10000个来处理。如果连接数较多将会出现资源不足的情况。非阻塞的核心优势就在这里。 </p>
<p>为什么会这样，下面就对他们做进一步细致具体的分析： </p>
<p>首先，我们来分析传统阻塞式IO的瓶颈在哪里。在连接数不多的情况下，传统IO编写容易方便使用。但是随着连接数的增多，问题传统IO就不行了。因为前面说过，传统IO处理每个连接都要消耗一个线程，而程序的效率当线程数不多时是随着线程数的增加而增加，但是到一定的数量之后，是随着线程数的增加而减少。这里我们得出结论，传统阻塞式IO的瓶颈在于不能处理过多的连接。 </p>
<p>然后，非阻塞式IO的出现的目的就是为了解决这个瓶颈。而非阻塞式IO是怎么实现的呢？非阻塞IO处理连接的线程数和连接数没有联系，也就是说处理 10000个连接非阻塞IO不需要10000个线程，你可以用1000个也可以用2000个线程来处理。因为非阻塞IO处理连接是异步的。当某个连接发送请求到服务器，服务器把这个连接请求当作一个请求”事件”，并把这个”事件”分配给相应的函数处理。我们可以把这个处理函数放到线程中去执行，执行完就把线程归还。这样一个线程就可以异步的处理多个事件。而阻塞式IO的线程的大部分时间都浪费在等待请求上了。 </p>
<p>所谓阻塞式IO流，就是指在从数据流当中读写数据的的时候，阻塞当前线程，直到IO流可以<br>重新使用为止，你也可以使用流的avaliableBytes()函数看看当前流当中有多少字节可以读取，这样<br>就不会再阻塞了。 </p>
<p>实例连接：<br><a href="http://blog.csdn.net/zmx729618/article/details/51859456" target="_blank" rel="external">http://blog.csdn.net/zmx729618/article/details/51859456</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java NIO 由以下几个核心部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Channels&lt;/li&gt;
&lt;li&gt;Buffers&lt;/li&gt;
&lt;li&gt;Selectors&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是JAVA NIO中的一些主要Channel的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;F
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍15-nio4</title>
    <link href="http://yoursite.com/2017/02/27/15-javanio4/"/>
    <id>http://yoursite.com/2017/02/27/15-javanio4/</id>
    <published>2017-02-27T12:52:12.000Z</published>
    <updated>2017-02-27T10:29:25.281Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中介绍了关于缓冲区的一些细节内容，现在终于可以进入NIO中最有意思的部分非阻塞I/O。通常在进行同步I/O操作时，如果读取数据，代码会阻塞直至有 可供读取的数据。同样，写入调用将会阻塞直至数据能够写入。传统的Server/Client模式会基于TPR（Thread per Request）,服务器会为每个客户端请求建立一个线程，由该线程单独负责处理一个客户请求。这种模式带来的一个问题就是线程数量的剧增，大量的线程会增大服务器的开销。大多数的实现为了避免这个问题，都采用了线程池模型，并设置线程池线程的最大数量，这由带来了新的问题，如果线程池中有200个线程，而有200个用户都在进行大文件下载，会导致第201个用户的请求无法及时处理，即便第201个用户只想请求一个几KB大小的页面</p>
<p>NIO中非阻塞I/O采用了基于Reactor模式的工作方式，I/O调用不会被阻塞，相反是注册感兴趣的特定I/O事件，如可读数据到达，新的套接字连接等等，在发生特定事件时，系统再通知我们。NIO中实现非阻塞I/O的核心对象就是Selector，Selector就是注册各种I/O事件地 方，而且当那些事件发生时，就是这个对象告诉我们所发生的事件。</p>
<p>当有读或写等任何注册的事件发生时，可以从Selector中获得相应的SelectionKey，同时从 SelectionKey中可以找到发生的事件和该事件所发生的具体的SelectableChannel，以获得客户端发送过来的数据。关于 SelectableChannel的可以参考Java NIO使用及原理分析（一）<br>使用NIO中非阻塞I/O编写服务器处理程序，大体上可以分为下面三个步骤：</p>
<ol>
<li>向Selector对象注册感兴趣的事件 </li>
<li>从Selector中获取感兴趣的事件 </li>
<li>根据不同的事件进行相应的处理</li>
</ol>
<p>接下来我们用一个简单的示例来说明整个过程。首先是向Selector对象注册感兴趣的事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 注册事件 </div><div class="line"> * */  </div><div class="line"><span class="function"><span class="keyword">protected</span> Selector <span class="title">getSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </div><div class="line">    <span class="comment">// 创建Selector对象  </span></div><div class="line">    Selector sel = Selector.open();  </div><div class="line">      </div><div class="line">    <span class="comment">// 创建可选择通道，并配置为非阻塞模式  </span></div><div class="line">    ServerSocketChannel server = ServerSocketChannel.open();  </div><div class="line">    server.configureBlocking(<span class="keyword">false</span>);  </div><div class="line">      </div><div class="line">    <span class="comment">// 绑定通道到指定端口  </span></div><div class="line">    ServerSocket socket = server.socket();  </div><div class="line">    InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(port);  </div><div class="line">    socket.bind(address);  </div><div class="line">      </div><div class="line">    <span class="comment">// 向Selector中注册感兴趣的事件  </span></div><div class="line">    server.register(sel, SelectionKey.OP_ACCEPT);   </div><div class="line">    <span class="keyword">return</span> sel;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建了ServerSocketChannel对象，并调用configureBlocking()方法，配置为非阻塞模式，接下来的三行代码把该通道绑定到指定端口，最后向Selector中注册事件，此处指定的是参数是OP_ACCEPT，即指定我们想要监听accept事件，也就是新的连接发 生时所产生的事件，对于ServerSocketChannel通道来说，我们唯一可以指定的参数就是OP_ACCEPT。<br>从Selector中获取感兴趣的事件，即开始监听，进入内部循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 开始监听 </div><div class="line"> * */   </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;   </div><div class="line">    System.out.println(<span class="string">"listen on "</span> + port);  </div><div class="line">    <span class="keyword">try</span> &#123;   </div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;   </div><div class="line">            <span class="comment">// 该调用会阻塞，直到至少有一个事件发生  </span></div><div class="line">            selector.select();   </div><div class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();  </div><div class="line">            Iterator&lt;SelectionKey&gt; iter = keys.iterator();  </div><div class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;   </div><div class="line">                SelectionKey key = (SelectionKey) iter.next();   </div><div class="line">                iter.remove();   </div><div class="line">                process(key);   </div><div class="line">            &#125;   </div><div class="line">        &#125;   </div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;   </div><div class="line">        e.printStackTrace();  </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在非阻塞I/O中，内部循环模式基本都是遵循这种方式。首先调用select()方法，该方法会阻塞，直到至少有一个事件发生，然后再使用selectedKeys()方法获取发生事件的SelectionKey，再使用迭代器进行循环。<br>最后一步就是根据不同的事件，编写相应的处理代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 根据不同的事件做处理 </div><div class="line"> * */  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>&#123;  </div><div class="line">    <span class="comment">// 接收请求  </span></div><div class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;  </div><div class="line">        ServerSocketChannel server = (ServerSocketChannel) key.channel();  </div><div class="line">        SocketChannel channel = server.accept();  </div><div class="line">        channel.configureBlocking(<span class="keyword">false</span>);  </div><div class="line">        channel.register(selector, SelectionKey.OP_READ);  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 读信息  </span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;  </div><div class="line">        SocketChannel channel = (SocketChannel) key.channel();   </div><div class="line">        <span class="keyword">int</span> count = channel.read(buffer);   </div><div class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;   </div><div class="line">            buffer.flip();   </div><div class="line">            CharBuffer charBuffer = decoder.decode(buffer);   </div><div class="line">            name = charBuffer.toString();   </div><div class="line">            SelectionKey sKey = channel.register(selector, SelectionKey.OP_WRITE);   </div><div class="line">            sKey.attach(name);   </div><div class="line">        &#125; <span class="keyword">else</span> &#123;   </div><div class="line">            channel.close();   </div><div class="line">        &#125;   </div><div class="line">        buffer.clear();   </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 写事件  </span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;  </div><div class="line">        SocketChannel channel = (SocketChannel) key.channel();   </div><div class="line">        String name = (String) key.attachment();   </div><div class="line">          </div><div class="line">        ByteBuffer block = encoder.encode(CharBuffer.wrap(<span class="string">"Hello "</span> + name));   </div><div class="line">        <span class="keyword">if</span>(block != <span class="keyword">null</span>)  </div><div class="line">        &#123;  </div><div class="line">            channel.write(block);  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span>  </div><div class="line">        &#123;  </div><div class="line">            channel.close();  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">     &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>zhuanzai:<a href="http://blog.csdn.net/wuxianglong/article/details/6612282" target="_blank" rel="external">http://blog.csdn.net/wuxianglong/article/details/6612282</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中介绍了关于缓冲区的一些细节内容，现在终于可以进入NIO中最有意思的部分非阻塞I/O。通常在进行同步I/O操作时，如果读取数据，代码会阻塞直至有 可供读取的数据。同样，写入调用将会阻塞直至数据能够写入。传统的Server/Client模式会基于TPR（Threa
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍15-nio3</title>
    <link href="http://yoursite.com/2017/02/27/15-javanio3/"/>
    <id>http://yoursite.com/2017/02/27/15-javanio3/</id>
    <published>2017-02-27T12:52:12.000Z</published>
    <updated>2017-02-27T09:42:01.792Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中介绍了缓冲区内部对于状态变化的跟踪机制，而对于NIO中缓冲区来说，还有很多的内容值的学习，如缓冲区的分片与数据共享，只读缓冲区等。在本文中我们来看一下缓冲区一些更细节的内容。</p>
<h4 id="缓冲区的分配"><a href="#缓冲区的分配" class="headerlink" title="缓冲区的分配"></a>缓冲区的分配</h4><p>在前面的几个例子中，我们已经看过了，在创建一个缓冲区对象时，会调用静态方法allocate()来指定缓冲区的容量，其实调用 allocate()相当于创建了一个指定大小的数组，并把它包装为缓冲区对象。或者我们也可以直接将一个现有的数组，包装为缓冲区对象，如下示例代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferWrap</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span>  </span></div><div class="line">    &#123;  </div><div class="line">        <span class="comment">// 分配指定大小的缓冲区  </span></div><div class="line">        ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">10</span>);  </div><div class="line">          </div><div class="line">        <span class="comment">// 包装一个现有的数组  </span></div><div class="line">        <span class="keyword">byte</span> array[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];  </div><div class="line">        ByteBuffer buffer2 = ByteBuffer.wrap( array );  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="缓冲区分片"><a href="#缓冲区分片" class="headerlink" title="缓冲区分片"></a>缓冲区分片</h4><p>在NIO中，除了可以分配或者包装一个缓冲区对象外，还可以根据现有的缓冲区对象来创建一个子缓冲区，即在现有缓冲区上切出一片来作为一个新的缓冲区，但现有的缓冲区与创建的子缓冲区在底层数组层面上是数据共享的，也就是说，子缓冲区相当于是现有缓冲区的一个视图窗口。调用slice()方法可以创建一个子缓冲区，让我们通过例子来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.nio.*;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        ByteBuffer buffer = ByteBuffer.allocate( <span class="number">10</span> );  </div><div class="line">          </div><div class="line">        <span class="comment">// 缓冲区中的数据0-9  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buffer.capacity(); ++i) &#123;  </div><div class="line">            buffer.put( (<span class="keyword">byte</span>)i );  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        <span class="comment">// 创建子缓冲区  </span></div><div class="line">        buffer.position( <span class="number">3</span> );  </div><div class="line">        buffer.limit( <span class="number">7</span> );  </div><div class="line">        ByteBuffer slice = buffer.slice();  </div><div class="line">          </div><div class="line">        <span class="comment">// 改变子缓冲区的内容  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;slice.capacity(); ++i) &#123;  </div><div class="line">            <span class="keyword">byte</span> b = slice.get( i );  </div><div class="line">            b *= <span class="number">10</span>;  </div><div class="line">            slice.put( i, b );  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        buffer.position( <span class="number">0</span> );  </div><div class="line">        buffer.limit( buffer.capacity() );  </div><div class="line">          </div><div class="line">        <span class="keyword">while</span> (buffer.remaining()&gt;<span class="number">0</span>) &#123;  </div><div class="line">            System.out.println( buffer.get() );  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在该示例中，分配了一个容量大小为10的缓冲区，并在其中放入了数据0-9，而在该缓冲区基础之上又创建了一个子缓冲区，并改变子缓冲区中的内容，从最后输出的结果来看，只有子缓冲区“可见的”那部分数据发生了变化，并且说明子缓冲区与原缓冲区是数据共享的，输出结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">30</div><div class="line">40</div><div class="line">50</div><div class="line">60</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td></tr></table></figure>
<h4 id="只读缓存区"><a href="#只读缓存区" class="headerlink" title="只读缓存区"></a>只读缓存区</h4><p>只读缓冲区非常简单，可以读取它们，但是不能向它们写入数据。可以通过调用缓冲区的asReadOnlyBuffer()方法，将任何常规缓冲区转 换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区，并与原缓冲区共享数据，只不过它是只读的。如果原缓冲区的内容发生了变化，只读缓冲区的内容也随之发生变化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.nio.*;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        ByteBuffer buffer = ByteBuffer.allocate( <span class="number">10</span> );  </div><div class="line">          </div><div class="line">        <span class="comment">// 缓冲区中的数据0-9  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buffer.capacity(); ++i) &#123;  </div><div class="line">            buffer.put( (<span class="keyword">byte</span>)i );  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="comment">// 创建只读缓冲区  </span></div><div class="line">        ByteBuffer readonly = buffer.asReadOnlyBuffer();  </div><div class="line">          </div><div class="line">        <span class="comment">// 改变原缓冲区的内容  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buffer.capacity(); ++i) &#123;  </div><div class="line">            <span class="keyword">byte</span> b = buffer.get( i );  </div><div class="line">            b *= <span class="number">10</span>;  </div><div class="line">            buffer.put( i, b );  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        readonly.position(<span class="number">0</span>);  </div><div class="line">        readonly.limit(buffer.capacity());  </div><div class="line">          </div><div class="line">        <span class="comment">// 只读缓冲区的内容也随之改变  </span></div><div class="line">        <span class="keyword">while</span> (readonly.remaining()&gt;<span class="number">0</span>) &#123;  </div><div class="line">            System.out.println( readonly.get());  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果尝试修改只读缓冲区的内容，则会报ReadOnlyBufferException异常。只读缓冲区对于保护数据很有用。在将缓冲区传递给某个 对象的方法时，无法知道这个方法是否会修改缓冲区中的数据。创建一个只读的缓冲区可以保证该缓冲区不会被修改。只可以把常规缓冲区转换为只读缓冲区，而不能将只读的缓冲区转换为可写的缓冲区。</p>
<h4 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h4><p>直接缓冲区是为加快I/O速度，使用一种特殊方式为其分配内存的缓冲区，JDK文档中的描述为：给定一个直接字节缓冲区，Java虚拟机将尽最大努 力直接对它执行本机I/O操作。也就是说，它会在每一次调用底层操作系统的本机I/O操作之前(或之后)，尝试避免将缓冲区的内容拷贝到一个中间缓冲区中 或者从一个中间缓冲区中拷贝数据。要分配直接缓冲区，需要调用allocateDirect()方法，而不是allocate()方法，使用方式与普通缓冲区并无区别，如下面的拷贝文件示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;  </div><div class="line"><span class="keyword">import</span> java.nio.*;  </div><div class="line"><span class="keyword">import</span> java.nio.channels.*;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        String infile = <span class="string">"c:\\test.txt"</span>;  </div><div class="line">        FileInputStream fin = <span class="keyword">new</span> FileInputStream( infile );  </div><div class="line">        FileChannel fcin = fin.getChannel();  </div><div class="line">          </div><div class="line">        String outfile = String.format(<span class="string">"c:\\testcopy.txt"</span>);  </div><div class="line">        FileOutputStream fout = <span class="keyword">new</span> FileOutputStream( outfile );      </div><div class="line">        FileChannel fcout = fout.getChannel();  </div><div class="line">          </div><div class="line">        <span class="comment">// 使用allocateDirect，而不是allocate  </span></div><div class="line">        ByteBuffer buffer = ByteBuffer.allocateDirect( <span class="number">1024</span> );  </div><div class="line">          </div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </div><div class="line">            buffer.clear();  </div><div class="line">              </div><div class="line">            <span class="keyword">int</span> r = fcin.read( buffer );  </div><div class="line">              </div><div class="line">            <span class="keyword">if</span> (r==-<span class="number">1</span>) &#123;  </div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">            &#125;  </div><div class="line">              </div><div class="line">            buffer.flip();  </div><div class="line">              </div><div class="line">            fcout.write( buffer );  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内存映射文件I/O</p>
<p>内存映射文件I/O是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的I/O快的多。内存映射文件I/O是通过使文件中的数据出现为 内存数组的内容来完成的，这其中听起来似乎不过就是将整个文件读到内存中，但是事实上并不是这样。一般来说，只有文件中实际读取或者写入的部分才会映射到内存中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中介绍了缓冲区内部对于状态变化的跟踪机制，而对于NIO中缓冲区来说，还有很多的内容值的学习，如缓冲区的分片与数据共享，只读缓冲区等。在本文中我们来看一下缓冲区一些更细节的内容。&lt;/p&gt;
&lt;h4 id=&quot;缓冲区的分配&quot;&gt;&lt;a href=&quot;#缓冲区的分配&quot; clas
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍13-reference</title>
    <link href="http://yoursite.com/2017/02/25/13-%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2017/02/25/13-引用/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T07:38:47.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>Java从1.2版本开始引入了4种引用，这4种引用的级别由高到低依次为：</p>
<p>   强引用  &gt;  软引用  &gt;  弱引用  &gt;  虚引用</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>⑴强引用（StrongReference）</p>
<pre><code>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。
</code></pre><p>⑵软引用（SoftReference）</p>
<pre><code>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。
</code></pre><p>⑶弱引用（WeakReference）</p>
<pre><code>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。

弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。
</code></pre><p>⑷虚引用（PhantomReference）</p>
<pre><code>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。
</code></pre><p>转载：<a href="http://www.cnblogs.com/skywang12345/p/3154474.html" target="_blank" rel="external">http://www.cnblogs.com/skywang12345/p/3154474.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;reference&quot;&gt;&lt;a href=&quot;#reference&quot; class=&quot;headerlink&quot; title=&quot;reference&quot;&gt;&lt;/a&gt;reference&lt;/h1&gt;&lt;p&gt;Java从1.2版本开始引入了4种引用，这4种引用的级别由高到低依次为：&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍6-hashset&amp;hashmap</title>
    <link href="http://yoursite.com/2017/02/25/6-HashSet%20and%20HashMap/"/>
    <id>http://yoursite.com/2017/02/25/6-HashSet and HashMap/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T06:25:52.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashSet-and-HashMap"><a href="#HashSet-and-HashMap" class="headerlink" title="HashSet and HashMap"></a>HashSet and HashMap</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>之所以把<em>HashSet</em>和<em>HashMap</em>放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<strong><em>HashSet</em>里面有一个<em>HashMap</em>（适配器模式）</strong>。因此本文将重点分析<em>HashMap</em>。</p>
<p><em>HashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素；除该类未实现同步外，其余跟<code>Hashtable</code>大致相同；跟<em>TreeMap</em>不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个<em>HashMap</em>的顺序可能会不同。<br>根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式（Open addressing），另一种是冲突链表方式（Separate chaining with linked lists）。<strong>Java <em>HashMap</em>采用的是冲突链表方式</strong>。<br><img src="../PNGFigures/HashMap_base.png" alt="HashMap_base"></p>
<p>从上图容易看出，如果选择合适的哈希函数，<code>put()</code>和<code>get()</code>方法可以在常数时间内完成。但在对<em>HashMap</em>进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将<em>HashMap</em>的初始大小设的过大。</p>
<p>有两个参数可以影响<em>HashMap</em>的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p>
<p>将对象放入到<em>HashMap</em>或<em>HashSet</em>中时，有两个方法需要特别关心：<code>hashCode()</code>和<code>equals()</code>。<strong><code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”</strong>。所以，如果要将自定义的对象放入到<code>HashMap</code>或<code>HashSet</code>中，需要<em>@Override</em><code>hashCode()</code>和<code>equals()</code>方法。</p>
<h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.getValue()</code>。因此<code>getEntry()</code>是算法的核心。<br>算法思想是首先通过<code>hash()</code>函数得到对应<code>bucket</code>的下标，然后依次遍历冲突链表，通过<code>key.equals(k)</code>方法来判断是否是要找的那个<code>entry</code>。<br><img src="../PNGFigures/HashMap_getEntry.png" alt="HashMap_getEntry"><br>上图中<code>hash(k)&amp;(table.length-1)</code>等价于<code>hash(k)%table.length</code>，原因是<em>HashMap</em>要求<code>table.length</code>必须是2的指数，因此<code>table.length-1</code>就是二进制低位全是1，跟<code>hash(k)</code>相与会将哈希值的高位全抹掉，剩下的就是余数了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//getEntry()方法</span></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">	......</div><div class="line">	<span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-<span class="number">1</span>)];<span class="comment">//得到冲突链表</span></div><div class="line">         e != <span class="keyword">null</span>; e = e.next) &#123;<span class="comment">//依次遍历冲突链表中的每个entry</span></div><div class="line">        Object k;</div><div class="line">        <span class="comment">//依据equals()方法判断是否相等</span></div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h2><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>，插入方式为<strong>头插法</strong>。<br><img src="../PNGFigures/HashMap_addEntry.png" alt="HashMap_addEntry"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//addEntry()</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</div><div class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">//自动扩容，并重新哈希</span></div><div class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</div><div class="line">        bucketIndex = hash &amp; (table.length-<span class="number">1</span>);<span class="comment">//hash%table.length</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//在冲突链表头部插入新的entry</span></div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到<code>key</code>值对应的<code>entry</code>，然后删除该<code>entry</code>（修改链表的相应引用）。查找过程跟<code>getEntry()</code>过程类似。<br><img src="../PNGFigures/HashMap_removeEntryForKey.png" alt="HashMap_removeEntryForKey"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//removeEntryForKey()</span></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">	......</div><div class="line">	<span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//hash&amp;(table.length-1)</span></div><div class="line">    Entry&lt;K,V&gt; prev = table[i];<span class="comment">//得到冲突链表</span></div><div class="line">    Entry&lt;K,V&gt; e = prev;</div><div class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">//遍历冲突链表</span></div><div class="line">        Entry&lt;K,V&gt; next = e.next;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<span class="comment">//找到要删除的entry</span></div><div class="line">            modCount++; size--;</div><div class="line">            <span class="keyword">if</span> (prev == e) table[i] = next;<span class="comment">//删除的是冲突链表的第一个entry</span></div><div class="line">            <span class="keyword">else</span> prev.next = next;</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">        &#125;</div><div class="line">        prev = e; e = next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p>前面已经说过<em>HashSet</em>是对<em>HashMap</em>的简单包装，对<em>HashSet</em>的函数调用都会转换成合适的<em>HashMap</em>方法，因此<em>HashSet</em>的实现非常简单，只有不到300行代码。这里不再赘述。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//HashSet是对HashMap的简单包装</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">&#123;</div><div class="line">	......</div><div class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;<span class="comment">//HashSet里面有一个HashMap</span></div><div class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//简单的方法转换</span></div><div class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HashSet-and-HashMap&quot;&gt;&lt;a href=&quot;#HashSet-and-HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashSet and HashMap&quot;&gt;&lt;/a&gt;HashSet and HashMap&lt;/h1&gt;&lt;h1 i
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍7-linkedhashset &amp; linkedhashmap</title>
    <link href="http://yoursite.com/2017/02/25/7-LinkedHashSet%20and%20LinkedHashMap/"/>
    <id>http://yoursite.com/2017/02/25/7-LinkedHashSet and LinkedHashMap/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T06:26:21.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LinkedHashSet-and-LinkedHashMap"><a href="#LinkedHashSet-and-LinkedHashMap" class="headerlink" title="LinkedHashSet and LinkedHashMap"></a>LinkedHashSet and LinkedHashMap</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>如果你已看过前面关于<em>HashSet</em>和<em>HashMap</em>，以及<em>TreeSet</em>和<em>TreeMap</em>的讲解，一定能够想到本文将要讲解的<em>LinkedHashSet</em>和<em>LinkedHashMap</em>其实也是一回事。<em>LinkedHashSet</em>和<em>LinkedHashMap</em>在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<strong><em>LinkedHashSet</em>里面有一个<em>LinkedHashMap</em>（适配器模式）</strong>。因此本文将重点分析<em>LinkedHashMap</em>。</p>
<p><em>LinkedHashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素。从名字上可以看出该容器是<em>linked list</em>和<em>HashMap</em>的混合体，也就是说它同时满足<em>HashMap</em>和<em>linked list</em>的某些特性。<strong>可将<em>LinkedHashMap</em>看作采用<em>linked list</em>增强的<em>HashMap</em>。</strong></p>
<p><img src="../PNGFigures/LinkedHashMap_base.png" alt="LinkedHashMap_base.png"></p>
<p>事实上<em>LinkedHashMap</em>是<em>HashMap</em>的直接子类，<strong>二者唯一的区别是<em>LinkedHashMap</em>在<em>HashMap</em>的基础上，采用双向链表（doubly-linked list）的形式将所有<code>entry</code>连接起来，这样是为保证元素的迭代顺序跟插入顺序相同</strong>。上图给出了<em>LinkedHashMap</em>的结构图，主体部分跟<em>HashMap</em>完全一样，多了<code>header</code>指向双向链表的头部（是一个哑元），<strong>该双向链表的迭代顺序就是<code>entry</code>的插入顺序</strong>。</p>
<p>除了可以保迭代历顺序，这种结构还有一个好处：<strong>迭代<em>LinkedHashMap</em>时不需要像<em>HashMap</em>那样遍历整个<code>table</code>，而只需要直接遍历<code>header</code>指向的双向链表即可</strong>，也就是说<em>LinkedHashMap</em>的迭代时间就只跟<code>entry</code>的个数相关，而跟<code>table</code>的大小无关。</p>
<p>有两个参数可以影响<em>LinkedHashMap</em>的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p>
<p>将对象放入到<em>LinkedHashMap</em>或<em>LinkedHashSet</em>中时，有两个方法需要特别关心：<code>hashCode()</code>和<code>equals()</code>。<strong><code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”</strong>。所以，如果要将自定义的对象放入到<code>LinkedHashMap</code>或<code>LinkedHashSet</code>中，需要<em>@Override</em><code>hashCode()</code>和<code>equals()</code>方法。</p>
<p>通过如下方式可以得到一个跟源<em>Map</em> <strong>迭代顺序</strong>一样的<em>LinkedHashMap</em>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Map m)</span> </span>&#123;</div><div class="line">    Map copy = <span class="keyword">new</span> LinkedHashMap(m);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>出于性能原因，<em>LinkedHashMap</em>是非同步的（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将<em>LinkedHashMap</em>包装成（wrapped）同步的：</p>
<p><code>Map m = Collections.synchronizedMap(new LinkedHashMap(...));</code></p>
<h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>。该方法跟<code>HashMap.get()</code>方法的流程几乎完全一样，读者可自行<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md#get" target="_blank" rel="external">参考前文</a>，这里不再赘述。</p>
<h2 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h2><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>get()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>。</p>
<p>注意，这里的<strong>插入有两重含义</strong>：</p>
<blockquote>
<ol>
<li>从<code>table</code>的角度看，新的<code>entry</code>需要插入到对应的<code>bucket</code>里，当有哈希冲突时，采用头插法将新的<code>entry</code>插入到冲突链表的头部。</li>
<li>从<code>header</code>的角度看，新的<code>entry</code>需要插入到双向链表的尾部。</li>
</ol>
</blockquote>
<p><img src="../PNGFigures/LinkedHashMap_addEntry.png" alt="LinkedHashMap_addEntry.png"></p>
<p><code>addEntry()</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LinkedHashMap.addEntry()</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</div><div class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">// 自动扩容，并重新哈希</span></div><div class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</div><div class="line">        bucketIndex = hash &amp; (table.length-<span class="number">1</span>);<span class="comment">// hash%table.length</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 1.在冲突链表头部插入新的entry</span></div><div class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</div><div class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, old);</div><div class="line">    table[bucketIndex] = e;</div><div class="line">    <span class="comment">// 2.在双向链表的尾部插入新的entry</span></div><div class="line">    e.addBefore(header);</div><div class="line">    size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中用到了<code>addBefore()</code>方法将新<code>entry e</code>插入到双向链表头引用<code>header</code>的前面，这样<code>e</code>就成为双向链表中的最后一个元素。<code>addBefore()</code>的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LinkedHashMap.Entry.addBefor()，将this插入到existingEntry的前面</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</div><div class="line">    after  = existingEntry;</div><div class="line">    before = existingEntry.before;</div><div class="line">    before.after = <span class="keyword">this</span>;</div><div class="line">    after.before = <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码只是简单修改相关<code>entry</code>的引用而已。</p>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到<code>key</code>值对应的<code>entry</code>，然后删除该<code>entry</code>（修改链表的相应引用）。查找过程跟<code>get()</code>方法类似。</p>
<p>注意，这里的<strong>删除也有两重含义</strong>：</p>
<blockquote>
<ol>
<li>从<code>table</code>的角度看，需要将该<code>entry</code>从对应的<code>bucket</code>里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。</li>
<li>从<code>header</code>的角度来看，需要将该<code>entry</code>从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。</li>
</ol>
</blockquote>
<p><img src="../PNGFigures/LinkedHashMap_removeEntryForKey.png" alt="LinkedHashMap_removeEntryForKey.png"></p>
<p><code>removeEntryForKey()</code>对应的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LinkedHashMap.removeEntryForKey()，删除key值对应的entry</span></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">	......</div><div class="line">	<span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">// hash&amp;(table.length-1)</span></div><div class="line">    Entry&lt;K,V&gt; prev = table[i];<span class="comment">// 得到冲突链表</span></div><div class="line">    Entry&lt;K,V&gt; e = prev;</div><div class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">// 遍历冲突链表</span></div><div class="line">        Entry&lt;K,V&gt; next = e.next;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<span class="comment">// 找到要删除的entry</span></div><div class="line">            modCount++; size--;</div><div class="line">            <span class="comment">// 1. 将e从对应bucket的冲突链表中删除</span></div><div class="line">            <span class="keyword">if</span> (prev == e) table[i] = next;</div><div class="line">            <span class="keyword">else</span> prev.next = next;</div><div class="line">            <span class="comment">// 2. 将e从双向链表中删除</span></div><div class="line">            e.before.after = e.after;</div><div class="line">            e.after.before = e.before;</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">        &#125;</div><div class="line">        prev = e; e = next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h1><p>前面已经说过<em>LinkedHashSet</em>是对<em>LinkedHashMap</em>的简单包装，对<em>LinkedHashSet</em>的函数调用都会转换成合适的<em>LinkedHashMap</em>方法，因此<em>LinkedHashSet</em>的实现非常简单，这里不再赘述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</div><div class="line">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</div><div class="line">    ......</div><div class="line">    <span class="comment">// LinkedHashSet里面有一个LinkedHashMap</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</div><div class="line">    &#125;</div><div class="line">	......</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//简单的方法转换</span></div><div class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LinkedHashSet-and-LinkedHashMap&quot;&gt;&lt;a href=&quot;#LinkedHashSet-and-LinkedHashMap&quot; class=&quot;headerlink&quot; title=&quot;LinkedHashSet and LinkedHashMa
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍9-WeakHashMap</title>
    <link href="http://yoursite.com/2017/02/25/9-WeakHashMap/"/>
    <id>http://yoursite.com/2017/02/25/9-WeakHashMap/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T06:27:03.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>在Java集合框架系列文章的最后，笔者打算介绍一个特殊的成员：<em>WeakHashMap</em>，从名字可以看出它是某种 <em>Map</em>。它的特殊之处在于 <em>WeakHashMap</em> 里的<code>entry</code>可能会被GC自动删除，即使程序员没有调用<code>remove()</code>或者<code>clear()</code>方法。</p>
<p>更直观的说，当使用 <em>WeakHashMap</em> 时，即使没有显示的添加或删除任何元素，也可能发生如下情况：</p>
<blockquote>
<ul>
<li>调用两次<code>size()</code>方法返回不同的值；</li>
<li>两次调用<code>isEmpty()</code>方法，第一次返回<code>false</code>，第二次返回<code>true</code>；</li>
<li>两次调用<code>containsKey()</code>方法，第一次返回<code>true</code>，第二次返回<code>false</code>，尽管两次使用的是同一个<code>key</code>；</li>
<li>两次调用<code>get()</code>方法，第一次返回一个<code>value</code>，第二次返回<code>null</code>，尽管两次使用的是同一个对象。</li>
</ul>
</blockquote>
<p>遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉？其实不然，<strong><em>WeekHashMap</em> 的这个特点特别适用于需要缓存的场景</strong>。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。</p>
<p>要明白 <em>WeekHashMap</em> 的工作原理，还需要引入一个概念：<strong>弱引用（WeakReference）</strong>。我们都知道Java中内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，<strong>是否有有效的引用指向该对象</strong>。如果没有有效引用指向该对象（基本意味着不存在访问该对象的方式），那么该对象就是可回收的。这里的<strong>“有效引用”</strong>并不包括<strong>弱引用</strong>。也就是说，<strong>虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收</strong>。</p>
<p><em>WeakHashMap</em> 内部是通过弱引用来管理<code>entry</code>的，弱引用的特性对应到 <em>WeakHashMap</em> 上意味着什么呢？<strong>将一对<code>key, value</code>放入到 <em>WeakHashMap</em> 里并不能避免该<code>key</code>值被GC回收，除非在 <em>WeakHashMap</em> 之外还有对该<code>key</code>的强引用</strong>。</p>
<p>关于强引用，弱引用等概念以后再具体讲解，这里只需要知道Java中引用也是分种类的，并且不同种类的引用对GC的影响不同就够了。</p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>WeakHashMap的存储结构类似于HashMap，读者可自行<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md" target="_blank" rel="external">参考前文</a>，这里不再赘述。</p>
<p>关于强弱引用的管理方式，博主将会另开专题单独讲解。</p>
<h1 id="Weak-HashSet"><a href="#Weak-HashSet" class="headerlink" title="Weak HashSet?"></a>Weak HashSet?</h1><p>如果你看过前几篇关于 <em>Map</em> 和 <em>Set</em> 的讲解，一定会问：既然有 <em>WeekHashMap</em>，是否有 <em>WeekHashSet</em> 呢？答案是没有:( 。不过Java <em>Collections</em>工具类给出了解决方案，<code>Collections.newSetFromMap(Map&lt;E,Boolean&gt; map)</code>方法可以将任何 <em>Map</em>包装成一个<em>Set</em>。通过如下方式可以快速得到一个 <em>Weak HashSet</em>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将WeakHashMap包装成一个Set</span></div><div class="line">Set&lt;Object&gt; weakHashSet = Collections.newSetFromMap(</div><div class="line">        <span class="keyword">new</span> WeakHashMap&lt;Object, Boolean&gt;());</div></pre></td></tr></table></figure>
<p>不出你所料，<code>newSetFromMap()</code>方法只是对传入的 <em>Map</em>做了简单包装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Collections.newSetFromMap()用于将任何Map包装成一个Set</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">newSetFromMap</span><span class="params">(Map&lt;E, Boolean&gt; map)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SetFromMap&lt;&gt;(map);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SetFromMap</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;E, Boolean&gt; m;  <span class="comment">// The backing map</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;E&gt; s;       <span class="comment">// Its keySet</span></div><div class="line">    SetFromMap(Map&lt;E, Boolean&gt; map) &#123;</div><div class="line">        <span class="keyword">if</span> (!map.isEmpty())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Map is non-empty"</span>);</div><div class="line">        m = map;</div><div class="line">        s = map.keySet();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123;        m.clear(); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> m.size(); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> m.isEmpty(); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> m.containsKey(o); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span>   </span>&#123; <span class="keyword">return</span> m.remove(o) != <span class="keyword">null</span>; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123; <span class="keyword">return</span> m.put(e, Boolean.TRUE) == <span class="keyword">null</span>; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> s.iterator(); &#125;</div><div class="line">    <span class="keyword">public</span> Object[] toArray()         &#123; <span class="keyword">return</span> s.toArray(); &#125;</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a)     &#123; <span class="keyword">return</span> s.toArray(a); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> s.toString(); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>             </span>&#123; <span class="keyword">return</span> s.hashCode(); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span>   </span>&#123; <span class="keyword">return</span> o == <span class="keyword">this</span> || s.equals(o); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;<span class="keyword">return</span> s.containsAll(c);&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>   </span>&#123;<span class="keyword">return</span> s.removeAll(c);&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>   </span>&#123;<span class="keyword">return</span> s.retainAll(c);&#125;</div><div class="line">    <span class="comment">// addAll is the only inherited implementation</span></div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>至此<em>Java Collections Framework Internals</em>系列已经全部讲解完毕，希望这几篇简短的博文能够帮助各位读者对Java容器框架建立基本的理解。通过这里可以返回<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/0-Introduction.md" target="_blank" rel="external">本系列文章目录</a></p>
<p>如果对各位有哪怕些微的帮助，博主将感到非常高兴！如果博文中有任何的纰漏和谬误，欢迎各位博友指正。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;WeakHashMap&quot;&gt;&lt;a href=&quot;#WeakHashMap&quot; class=&quot;headerlink&quot; title=&quot;WeakHashMap&quot;&gt;&lt;/a&gt;WeakHashMap&lt;/h1&gt;&lt;h1 id=&quot;总体介绍&quot;&gt;&lt;a href=&quot;#总体介绍&quot; class=&quot;
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍0</title>
    <link href="http://yoursite.com/2017/02/25/0-Introduction/"/>
    <id>http://yoursite.com/2017/02/25/0-Introduction/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T06:28:11.977Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="http://www.cnblogs.com/CarpenterLee/" target="_blank" rel="external">http://www.cnblogs.com/CarpenterLee/</a></p>
<h1 id="Java-Collections-Framework-Internals"><a href="#Java-Collections-Framework-Internals" class="headerlink" title="Java Collections Framework Internals"></a>Java Collections Framework Internals</h1><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>关于<em>C++标准模板库(Standard Template Library, STL)</em>的书籍和资料有很多，关于<em>Java集合框架(Java Collections Framework, JCF)</em>的资料却很少，甚至很难找到一本专门介绍它的书籍，这给Java学习者们带来不小的麻烦。我深深的不解其中的原因。<strong>虽然JCF设计参考了STL，但其定位不是Java版的STL，而是要实现一个精简紧凑的容器框架</strong>，对STL的介绍自然不能替代对JCF的介绍。</p>
<p>本系列文章主要从<strong>数据结构和算法</strong>层面分析JCF中List, Set, Map, Stack, Queue等典型容器，<strong>结合生动图解和源代码，帮助读者对Java集合框架建立清晰而深入的理解</strong>。本文并不特意介绍Java的语言特性，但会在需要的时候做出简洁的解释。</p>
<h1 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h1><p>具体内容安排如下：</p>
<ol>
<li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/1-Overview.md" target="_blank" rel="external">Overview</a> 对Java Collections Framework，以及Java语言特性做出基本介绍。</li>
<li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md" target="_blank" rel="external">ArrayList</a> 结合源码对<em>ArrayList</em>进行讲解。</li>
<li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/3-LinkedList.md" target="_blank" rel="external">LinkedList</a> 结合源码对<em>LinkedList</em>进行讲解。</li>
<li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/4-Stack%20and%20Queue.md" target="_blank" rel="external">Stack and Queue</a> 以<em>AarryDeque</em>为例讲解<em>Stack</em>和<em>Queue</em>。</li>
<li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/5-TreeSet%20and%20TreeMap.md" target="_blank" rel="external">TreeSet and TreeMap</a> 结合源码对<em>TreeSet</em>和<em>TreeMap</em>进行讲解。</li>
<li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md" target="_blank" rel="external">HashSet and HashMap</a> 结合源码对<em>HashSet</em>和<em>HashMap</em>进行讲解。</li>
<li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/7-LinkedHashSet%20and%20LinkedHashMap.md" target="_blank" rel="external">LinkedHashSet and LinkedHashMap</a> 结合源码对<em>LinkedHashSet</em>和<em>LinkedHashMap</em>进行讲解。</li>
<li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md" target="_blank" rel="external">PriorityQueue</a> 结合源码对<em>PriorityQueue</em>进行讲解。</li>
<li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/9-WeakHashMap.md" target="_blank" rel="external">WeakHashMap</a> 对<em>WeakHashMap</em>做出基本介绍。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;http://www.cnblogs.com/CarpenterLee/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/CarpenterLee/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Ja
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍10-fail-fast</title>
    <link href="http://yoursite.com/2017/02/25/10-failfast/"/>
    <id>http://yoursite.com/2017/02/25/10-failfast/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T06:48:31.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h1><h4 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h4><p>fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。<br>例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p>
<p>在详细介绍fail-fast机制的原理之前，先通过一个示例来认识fail-fast。</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.*;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * @desc java集合中Fast-Fail的测试程序。</div><div class="line"> *</div><div class="line"> *   fast-fail事件产生的条件：当多个线程对Collection进行操作时，若其中某一个线程通过iterator去遍历集合时，该集合的内容被其他线程所改变；则会抛出ConcurrentModificationException异常。</div><div class="line"> *   fast-fail解决办法：通过util.concurrent集合包下的相应类去处理，则不会产生fast-fail事件。</div><div class="line"> *</div><div class="line"> *   本例中，分别测试ArrayList和CopyOnWriteArrayList这两种情况。ArrayList会产生fast-fail事件，而CopyOnWriteArrayList不会产生fast-fail事件。</div><div class="line"> *   (01) 使用ArrayList时，会产生fast-fail事件，抛出ConcurrentModificationException异常；定义如下：</div><div class="line"> *            private static List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line"> *   (02) 使用时CopyOnWriteArrayList，不会产生fast-fail事件；定义如下：</div><div class="line"> *            private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;();</div><div class="line"> *</div><div class="line"> * @author skywang</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastFailTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">    <span class="comment">//private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;();</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    </div><div class="line">        <span class="comment">// 同时启动两个线程对list进行操作！</span></div><div class="line">        <span class="keyword">new</span> ThreadOne().start();</div><div class="line">        <span class="keyword">new</span> ThreadTwo().start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">""</span>);</div><div class="line"></div><div class="line">        String value = <span class="keyword">null</span>;</div><div class="line">        Iterator iter = list.iterator();</div><div class="line">        <span class="keyword">while</span>(iter.hasNext()) &#123;</div><div class="line">            value = (String)iter.next();</div><div class="line">            System.out.print(value+<span class="string">", "</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 向list中依次添加0,1,2,3,4,5，每添加一个数之后，就通过printAll()遍历整个list</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadOne</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span> (i&lt;<span class="number">6</span>) &#123;</div><div class="line">                list.add(String.valueOf(i));</div><div class="line">                printAll();</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 向list中依次添加10,11,12,13,14,15，每添加一个数之后，就通过printAll()遍历整个list</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTwo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">10</span>;</div><div class="line">            <span class="keyword">while</span> (i&lt;<span class="number">16</span>) &#123;</div><div class="line">                list.add(String.valueOf(i));</div><div class="line">                printAll();</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>运行该代码，抛出异常java.util.ConcurrentModificationException！即，产生fail-fast事件！</p>
<p>结果说明：</p>
<ul>
<li>(01) FastFailTest中通过 new ThreadOne().start() 和 new ThreadTwo().start() 同时启动两个线程去操作list。<br>  ThreadOne线程：向list中依次添加0,1,2,3,4,5。每添加一个数之后，就通过printAll()遍历整个list。<br>  ThreadTwo线程：向list中依次添加10,11,12,13,14,15。每添加一个数之后，就通过printAll()遍历整个list。</li>
<li>(02) 当某一个线程遍历list的过程中，list的内容被另外一个线程所改变了；就会抛出ConcurrentModificationException异常，产生fail-fast事件。</li>
</ul>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>fail-fast机制，是一种错误检测机制。它只能被用来检测错误，因为JDK并不保证fail-fast机制一定会发生。若在多线程环境下使用fail-fast机制的集合，建议使用“java.util.concurrent包下的类”去取代“java.util包下的类”。<br>所以，本例中只需要将ArrayList替换成java.util.concurrent包下对应的类即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;String&gt;();</div></pre></td></tr></table></figure>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>产生fail-fast事件，是通过抛出ConcurrentModificationException异常来触发的。<br>那么，ArrayList是如何抛出ConcurrentModificationException异常的呢?</p>
<p>我们知道，ConcurrentModificationException是在操作Iterator时抛出的异常。我们先看看Iterator的源码。ArrayList的Iterator是在父类AbstractList.java中实现的。代码如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.util;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// AbstractList中唯一的属性</span></div><div class="line">    <span class="comment">// 用来记录List修改的次数：每修改一次(添加/删除等操作)，将modCount+1</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 返回List对应迭代器。实际上，是返回Itr对象。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Itr是Iterator(迭代器)的实现类</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">int</span> cursor = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 修改数的记录值。</span></div><div class="line">        <span class="comment">// 每次新建Itr()对象时，都会保存新建该对象时对应的modCount；</span></div><div class="line">        <span class="comment">// 以后每次遍历List中的元素的时候，都会比较expectedModCount和modCount是否相等；</span></div><div class="line">        <span class="comment">// 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。</span></div><div class="line">        <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> cursor != size();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// 获取下一个元素之前，都会判断“新建Itr对象时保存的modCount”和“当前的modCount”是否相等；</span></div><div class="line">            <span class="comment">// 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。</span></div><div class="line">            checkForComodification();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                E next = get(cursor);</div><div class="line">                lastRet = cursor++;</div><div class="line">                <span class="keyword">return</span> next;</div><div class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</div><div class="line">                checkForComodification();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (lastRet == -<span class="number">1</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">            checkForComodification();</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                AbstractList.<span class="keyword">this</span>.remove(lastRet);</div><div class="line">                <span class="keyword">if</span> (lastRet &lt; cursor)</div><div class="line">                    cursor--;</div><div class="line">                lastRet = -<span class="number">1</span>;</div><div class="line">                expectedModCount = modCount;</div><div class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从中，我们可以发现在调用 next() 和 remove()时，都会执行 checkForComodification()。若 “modCount 不等于 expectedModCount”，则抛出ConcurrentModificationException异常，产生fail-fast事件。</p>
<p>要搞明白 fail-fast机制，我们就要需要理解什么时候“modCount 不等于 expectedModCount”！<br>从Itr类中，我们知道 expectedModCount 在创建Itr对象时，被赋值为 modCount。通过Itr，我们知道：expectedModCount不可能被修改为不等于 modCount。所以，需要考证的就是modCount何时会被修改。</p>
<p>接下来，我们查看ArrayList的源码，来看看modCount是如何被修改的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.util;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// list中容量变化时，对应的同步函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">        <span class="keyword">if</span> (minCapacity &gt; oldCapacity) &#123;</div><div class="line">            Object oldData[] = elementData;</div><div class="line">            <span class="keyword">int</span> newCapacity = (oldCapacity * <span class="number">3</span>)/<span class="number">2</span> + <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (newCapacity &lt; minCapacity)</div><div class="line">                newCapacity = minCapacity;</div><div class="line">            <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">            elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// 添加元素到队列最后</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        <span class="comment">// 修改modCount</span></div><div class="line">        ensureCapacity(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        elementData[size++] = e;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// 添加元素到指定的位置</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(</div><div class="line">            <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size);</div><div class="line"></div><div class="line">        <span class="comment">// 修改modCount</span></div><div class="line">        ensureCapacity(size+<span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</div><div class="line">             size - index);</div><div class="line">        elementData[index] = element;</div><div class="line">        size++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 添加集合</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">        Object[] a = c.toArray();</div><div class="line">        <span class="keyword">int</span> numNew = a.length;</div><div class="line">        <span class="comment">// 修改modCount</span></div><div class="line">        ensureCapacity(size + numNew);  <span class="comment">// Increments modCount</span></div><div class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</div><div class="line">        size += numNew;</div><div class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line"></div><div class="line">    <span class="comment">// 删除指定位置的元素 </span></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        RangeCheck(index);</div><div class="line"></div><div class="line">        <span class="comment">// 修改modCount</span></div><div class="line">        modCount++;</div><div class="line">        E oldValue = (E) elementData[index];</div><div class="line"></div><div class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</div><div class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// 快速删除指定位置的元素 </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 修改modCount</span></div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                             numMoved);</div><div class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 清空集合</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 修改modCount</span></div><div class="line">        modCount++;</div><div class="line"></div><div class="line">        <span class="comment">// Let gc do its work</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">            elementData[i] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        size = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从中，我们发现：无论是add()、remove()，还是clear()，只要涉及到修改集合中的元素个数时，都会改变modCount的值。</p>
<p>接下来，我们再系统的梳理一下fail-fast是怎么产生的。步骤如下：</p>
<p>(01) 新建了一个ArrayList，名称为arrayList。<br>(02) 向arrayList中添加内容。<br>(03) 新建一个“线程a”，并在“线程a”中通过Iterator反复的读取arrayList的值。<br>(04) 新建一个“线程b”，在“线程b”中删除arrayList中的一个“节点A”。<br>(05) 这时，就会产生有趣的事件了。<br>       在某一时刻，“线程a”创建了arrayList的Iterator。此时“节点A”仍然存在于arrayList中，创建arrayList时，expectedModCount = modCount(假设它们此时的值为N)。<br>       在“线程a”在遍历arrayList过程中的某一时刻，“线程b”执行了，并且“线程b”删除了arrayList中的“节点A”。“线程b”执行remove()进行删除操作时，在remove()中执行了“modCount++”，此时modCount变成了N+1！</p>
<p>“线程a”接着遍历，当它执行到next()函数时，调用checkForComodification()比较“expectedModCount”和“modCount”的大小；而“expectedModCount=N”，“modCount=N+1”,这样，便抛出ConcurrentModificationException异常，产生fail-fast事件。</p>
<p>至此，我们就完全了解了fail-fast是如何产生的！<br>即，当多个线程对同一个集合进行操作的时候，某线程访问集合的过程中，该集合的内容被其他线程所改变(即其它线程通过add、remove、clear等方法，改变了modCount的值)；这时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p>
<h4 id="解决fail-fast失败的原理"><a href="#解决fail-fast失败的原理" class="headerlink" title="解决fail-fast失败的原理"></a>解决fail-fast失败的原理</h4><p>上面，说明了“解决fail-fast机制的办法”，也知道了“fail-fast产生的根本原因”。接下来，我们再进一步谈谈java.util.concurrent包中是如何解决fail-fast事件的。<br>还是以和ArrayList对应的CopyOnWriteArrayList进行说明。我们先看看CopyOnWriteArrayList的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.util.concurrent;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</div><div class="line"><span class="keyword">import</span> sun.misc.Unsafe;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// 返回集合对应的迭代器</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">   </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cursor;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</div><div class="line">            cursor = initialCursor;</div><div class="line">            <span class="comment">// 新建COWIterator时，将集合中的元素保存到一个新的拷贝数组中。</span></div><div class="line">            <span class="comment">// 这样，当原始集合的数据改变，拷贝数据中的值也不会变化。</span></div><div class="line">            snapshot = elements;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> cursor &lt; snapshot.length;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> cursor &gt; <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (! hasNext())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">            <span class="keyword">return</span> (E) snapshot[cursor++];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (! hasPrevious())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">            <span class="keyword">return</span> (E) snapshot[--cursor];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> cursor;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> cursor-<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从中，我们可以看出:</p>
<p>(01) 和ArrayList继承于AbstractList不同，CopyOnWriteArrayList没有继承于AbstractList，它仅仅只是实现了List接口。<br>(02) ArrayList的iterator()函数返回的Iterator是在AbstractList中实现的；而CopyOnWriteArrayList是自己实现Iterator。<br>(03) ArrayList的Iterator实现类中调用next()时，会“调用checkForComodification()比较‘expectedModCount’和‘modCount’的大小”；但是，CopyOnWriteArrayList的Iterator实现类中，没有所谓的checkForComodification()，更不会抛出ConcurrentModificationException异常！ </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;fail-fast&quot;&gt;&lt;a href=&quot;#fail-fast&quot; class=&quot;headerlink&quot; title=&quot;fail-fast&quot;&gt;&lt;/a&gt;fail-fast&lt;/h1&gt;&lt;h4 id=&quot;总体介绍&quot;&gt;&lt;a href=&quot;#总体介绍&quot; class=&quot;headerli
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍8-PriorityQueue</title>
    <link href="http://yoursite.com/2017/02/25/8-PriorityQueue/"/>
    <id>http://yoursite.com/2017/02/25/8-PriorityQueue/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T06:26:41.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>前面以Java <em>ArrayDeque</em>为例讲解了<em>Stack</em>和<em>Queue</em>，其实还有一种特殊的队列叫做<em>PriorityQueue</em>，即优先队列。<strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，<strong>元素大小的评判可以通过元素本身的自然顺序（<em>natural ordering</em>），也可以通过构造时传入的比较器</strong>（<em>Comparator</em>，类似于C++的仿函数）。</p>
<p>Java中<em>PriorityQueue</em>实现了<em>Queue</em>接口，不允许放入<code>null</code>元素；其通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为<em>PriorityQueue</em>的底层实现。</p>
<p><img src="../PNGFigures/PriorityQueue_base.png" alt="PriorityQueue_base.png"></p>
<p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：</p>
<p><code>leftNo = parentNo*2+1</code></p>
<p><code>rightNo = parentNo*2+2</code></p>
<p><code>parentNo = (nodeNo-1)/2</code></p>
<p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p>
<p><em>PriorityQueue</em>的<code>peek()</code>和<code>element</code>操作是常数时间，<code>add()</code>, <code>offer()</code>, 无参数的<code>remove()</code>以及<code>poll()</code>方法的时间复杂度都是<em>log(N)</em>。</p>
<h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="add-和offer"><a href="#add-和offer" class="headerlink" title="add()和offer()"></a>add()和offer()</h2><p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是<code>Queue</code>接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回<code>false</code>。对于<em>PriorityQueue</em>这两个方法其实没什么差别。</p>
<p><img src="../PNGFigures/PriorityQueue_offer.png" alt="PriorityQueue_offer.png"></p>
<p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//offer(E e)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//不允许放入null元素</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">int</span> i = size;</div><div class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</div><div class="line">        grow(i + <span class="number">1</span>);<span class="comment">//自动扩容</span></div><div class="line">    size = i + <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)<span class="comment">//队列原来为空，这是插入的第一个元素</span></div><div class="line">        queue[<span class="number">0</span>] = e;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        siftUp(i, e);<span class="comment">//调整</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中，扩容函数<code>grow()</code>类似于<code>ArrayList</code>里的<code>grow()</code>函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是<code>siftUp(int k, E x)</code>方法，该方法用于插入元素<code>x</code>并维持堆的特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//siftUp()</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">//parentNo = (nodeNo-1)/2</span></div><div class="line">        Object e = queue[parent];</div><div class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)<span class="comment">//调用比较器的比较方法</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        queue[k] = e;</div><div class="line">        k = parent;</div><div class="line">    &#125;</div><div class="line">    queue[k] = x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>新加入的元素<code>x</code>可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层与当前点的<code>parent</code>进行比较并交换，直到满足<code>x &gt;= queue[parent]</code>为止</strong>。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p>
<h2 id="element-和peek"><a href="#element-和peek" class="headerlink" title="element()和peek()"></a>element()和peek()</h2><p><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回<code>null</code>。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，<code>0</code>下标处的那个元素既是堆顶元素。所以<strong>直接返回数组<code>0</code>下标处的那个元素即可</strong>。</p>
<p><img src="../PNGFigures/PriorityQueue_peek.png" alt="PriorityQueue_peek.png"></p>
<p>代码也就非常简洁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//peek()</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">return</span> (E) queue[<span class="number">0</span>];<span class="comment">//0下标处的那个元素就是最小的那个</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="remove-和poll"><a href="#remove-和poll" class="headerlink" title="remove()和poll()"></a>remove()和poll()</h2><p><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p>
<p><img src="../PNGFigures/PriorityQueue_poll.png" alt="PriorityQueue_poll.png"><br>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> s = --size;</div><div class="line">    modCount++;</div><div class="line">    E result = (E) queue[<span class="number">0</span>];<span class="comment">//0下标处的那个元素就是最小的那个</span></div><div class="line">    E x = (E) queue[s];</div><div class="line">    queue[s] = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</div><div class="line">        siftDown(<span class="number">0</span>, x);<span class="comment">//调整</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码首先记录<code>0</code>下标处的元素，并用最后一个元素替换<code>0</code>下标位置的元素，之后调用<code>siftDown()</code>方法对堆进行调整，最后返回原来<code>0</code>下标处的那个元素（也就是最小的那个元素）。重点是<code>siftDown(int k, E x)</code>方法，该方法的作用是<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层向下与当前点的左右孩子中较小的那个交换，直到<code>x</code>小于或等于左右孩子中的任何一个为止</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//siftDown()</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</div><div class="line">    	<span class="comment">//首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span></div><div class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;<span class="comment">//leftNo = parentNo*2+1</span></div><div class="line">        Object c = queue[child];</div><div class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</div><div class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</div><div class="line">            c = queue[child = right];</div><div class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        queue[k] = c;<span class="comment">//然后用c取代原来的值</span></div><div class="line">        k = child;</div><div class="line">    &#125;</div><div class="line">    queue[k] = x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h2><p><code>remove(Object o)</code>方法用于删除队列中跟<code>o</code>相等的某一个元素（如果有多个相等，只删除一个），该方法不是<em>Queue</em>接口内的方法，而是<em>Collection</em>接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次<code>siftDown()</code>即可。此处不再赘述。</p>
<p><img src="../PNGFigures/PriorityQueue_remove2.png" alt="PriorityQueue_remove2.png"></p>
<p>具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//remove(Object o)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">	<span class="comment">//通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span></div><div class="line">    <span class="keyword">int</span> i = indexOf(o);</div><div class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span> s = --size;</div><div class="line">    <span class="keyword">if</span> (s == i) <span class="comment">//情况1</span></div><div class="line">        queue[i] = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        E moved = (E) queue[s];</div><div class="line">        queue[s] = <span class="keyword">null</span>;</div><div class="line">        siftDown(i, moved);<span class="comment">//情况2</span></div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PriorityQueue&quot;&gt;&lt;a href=&quot;#PriorityQueue&quot; class=&quot;headerlink&quot; title=&quot;PriorityQueue&quot;&gt;&lt;/a&gt;PriorityQueue&lt;/h1&gt;&lt;h1 id=&quot;总体介绍&quot;&gt;&lt;a href=&quot;#总体介绍&quot;
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍12-iterator</title>
    <link href="http://yoursite.com/2017/02/25/12-iterator/"/>
    <id>http://yoursite.com/2017/02/25/12-iterator/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T07:18:10.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h1><p>转载:<a href="http://www.cnblogs.com/skywang12345/p/3310887.html" target="_blank" rel="external">http://www.cnblogs.com/skywang12345/p/3310887.html</a></p>
<h4 id="Iterator和Enumeration区别"><a href="#Iterator和Enumeration区别" class="headerlink" title="Iterator和Enumeration区别"></a>Iterator和Enumeration区别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.util;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Enumeration</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">nextElement</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">package</span> java.util;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(01) 函数接口不同</p>
<pre><code>Enumeration只有2个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。
Iterator只有3个函数接口。Iterator除了能读取集合的数据之外，也能数据进行删除操作。
</code></pre><p>(02) Iterator支持fail-fast机制，而Enumeration不支持。</p>
<pre><code>Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK 1.0中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步。
而Iterator 是JDK 1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iterator&quot;&gt;&lt;a href=&quot;#iterator&quot; class=&quot;headerlink&quot; title=&quot;iterator&quot;&gt;&lt;/a&gt;iterator&lt;/h1&gt;&lt;p&gt;转载:&lt;a href=&quot;http://www.cnblogs.com/skywang1234
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
</feed>
