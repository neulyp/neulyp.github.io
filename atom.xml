<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lyp&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-22T16:31:40.867Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Loren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCPIP-应用层4-远程登录telnet&amp;ssh</title>
    <link href="http://yoursite.com/2017/03/22/TCPIP-%E5%BA%94%E7%94%A8%E5%B1%824-%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95telnet&amp;ssh/"/>
    <id>http://yoursite.com/2017/03/22/TCPIP-应用层4-远程登录telnet&amp;ssh/</id>
    <published>2017-03-22T15:24:42.000Z</published>
    <updated>2017-03-22T16:31:40.867Z</updated>
    
    <content type="html"><![CDATA[<p>远程登录: telnet ssh</p>
<h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>telnet 是终端网络 terminal network的缩写、telnet能够建立一条道远程系统的连接，使得本地终端就好像连接到远程系统上一样。</p>
<p>分时系统</p>
<ul>
<li>本地登录</li>
<li>远程登录</li>
</ul>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\32.png" alt="image"></p>
<p>网络虚拟中断nvt：telnet客户吧来自本地终端的字符转换为nvt形式，交付给网络。telnet服务器把nvt形式的数据转换为远程计算机可接受的形式。</p>
<p>telnet存在安全问题。虽然徐亚登录名和密码。但是还是能比较容易获得到口令。</p>
<h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><p>安全外壳 secure shell； 更安全</p>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\33.jpg" alt="image"></p>
<p>ssh运输层协议（ssh-trans）;因为tcp不是按全额运输层协议，所以ssh首先使用在tcp智商能够构建安全信道的协议，这个新的层是一个独立的协议，成为ssh-trans</p>
<p>当这个协议的软件实现被调用后，他的客户程序和服务器程序先利用tcp简历一条不安全的连接，在相互交换安全参数。在tcp上简历一条安全的信道。</p>
<h3 id="文件传输协议（ftp-tftp）"><a href="#文件传输协议（ftp-tftp）" class="headerlink" title="文件传输协议（ftp tftp）"></a>文件传输协议（ftp tftp）</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;远程登录: telnet ssh&lt;/p&gt;
&lt;h3 id=&quot;telnet&quot;&gt;&lt;a href=&quot;#telnet&quot; class=&quot;headerlink&quot; title=&quot;telnet&quot;&gt;&lt;/a&gt;telnet&lt;/h3&gt;&lt;p&gt;telnet 是终端网络 terminal network的
    
    </summary>
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/categories/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/tags/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>TCPIP-传输层4-tcp2之连接</title>
    <link href="http://yoursite.com/2017/03/22/TCPIP-%E4%BC%A0%E8%BE%93%E5%B1%824-tcp2%E4%B9%8B%E8%BF%9E%E6%8E%A5/"/>
    <id>http://yoursite.com/2017/03/22/TCPIP-传输层4-tcp2之连接/</id>
    <published>2017-03-22T15:24:42.000Z</published>
    <updated>2017-03-22T15:38:12.303Z</updated>
    
    <content type="html"><![CDATA[<p>ps：首先，tcp的行为对ip来说是不知道的。</p>
<p>在tcp中，面向连接的传输需要经过三个阶段，简历连接，数据传输，连接终止。</p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>TCP是TCP/IP的传输层控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:</p>
<p>首先需要了解几个名词：tcp标志位,有6种分别为：SYN(synchronous建立联机) 、ACK(acknowledgement 确认) 、PSH(push传送) 、FIN(finish结束)、 RST(reset重置) 、URG(urgent紧急);</p>
<ul>
<li>URG 紧急指针，告诉接收TCP模块紧要指针域指着紧要数据。</li>
<li>ACK 置1时表示确认号（为合法，为0的时候表示数据段不包含确认信息，确认号被忽略。 </li>
<li>PSH 置1时请求的数据段在接收方得到后就可直接送到应用程序，而不必等到缓冲区满时才传送。 </li>
<li>RST 置1时重建连接。如果接收到RST位时候，通常发生了某些错误。 </li>
<li>SYN 置1时用来发起一个连接。 </li>
<li>FIN 置1时表示发端完成发送任务。用来释放连接，表明发送方已经没有数据发送了。</li>
<li>另外还有 Sequence number(顺序号码) 、Acknowledge number(确认号码)在建立握手过程中发送的序列号。</li>
</ul>
<p>主机A(client)和主机B(server)开始建立握手过程：</p>
<ul>
<li>第一次握手：主机A发送位码为syn＝1,随机产生seq number=10001的数据包到服务器，主机B由SYN=1知道，A要求建立联机，此时状态为SYN_SENT；</li>
<li>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=20001的包，此时状态由LISTEN变为SYN_RECV；</li>
<li>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功，双方状态ESTABLISHED。</li>
</ul>
<p>完成三次握手，主机A与主机B开始传送数据。</p>
<p><img src="http://i.imgur.com/sNQUAgo.png" alt=""></p>
<p><strong>syn洪泛攻击</strong></p>
<p>当一个或多个而已的攻击者向某台服务器发送大量的syn报文段。并通过伪造报文段中的源ip地址来假装每一个报文段来自不同的客户时，这个问题就发生了。</p>
<p>一些策略：限定在指定时间内的连接请求次数，有些则吧来自不希望的原地址的数据报过滤掉。最近使用的一种策略是通过使用cookie，做到推迟资源分配，知道服务器核实是有效连接。在分配资源、</p>
<h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><ul>
<li>推送数据</li>
</ul>
<p>我们知道，发送tcp利用缓存从发送应用程序传来的数据流，接受tcp也有缓存。并在接受应用程序就绪或者接受tcp认为方便的时候，交付这些数据。这种灵活性提高了tcp的效率。但有的场合希望立马收到回复。可以使用球球推送操作。</p>
<ul>
<li>紧急数据</li>
</ul>
<h3 id="连接终止"><a href="#连接终止" class="headerlink" title="连接终止"></a>连接终止</h3><p>目前，大多数tcp实现允许在连接终止时有两种选择：三向握手和具有半关闭选项的四向握手。</p>
<ul>
<li>三向握手</li>
</ul>
<ol>
<li>正常情况下，客户tcp收到客户进程发来的关闭命令，就发送一个fin为1的报文。也可以包含最后一块数据</li>
<li>服务器收到fin 通知进程，发送第二个报恩段 fin+ack。</li>
<li>客户端发送最后一个报文段，ack 不消耗序号。</li>
</ol>
<ul>
<li>半关闭<br>在tcp中，连接的乙方停止发送数据，单仍然可以接收数据，称之为半关闭。</li>
</ul>
<ol>
<li>客户端发送一个fin，</li>
<li>服务器发送一个ack表示接受这个半关闭。但是服务器仍可以发送数据，</li>
<li>当服务器处理完数据，发送完毕后，发送一个fin，</li>
<li>客户端收到后，发送一个ack</li>
</ol>
<h3 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h3><p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\8.jpg" alt="image"></p>
<p>tcp的各种状态</p>
<ul>
<li>closed 没有连接</li>
<li>listen 收到了被动打开：等待syn</li>
<li>syn-send 已发送syn，等待ack</li>
<li>syn-rcvd 已发送 syn+ack；等待ack</li>
<li>established 连接简历：数据传送在进行</li>
<li>fin-wait-1 第一个fin已发送，等待ack</li>
<li>fin-wait-2 对第一个fin的ack已收到，等待第二个fin</li>
<li>close-wait 收到第一个fin 已发送ack 等待应用程序关闭</li>
<li>time-wait 收到第二个fin 已发送ack 等待2msl超时</li>
<li>last-ack 已发送第二个fin 等待ack</li>
<li>closing 双方都决定同时关闭</li>
</ul>
<p><img src="http://i.imgur.com/rGy9bR8.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ps：首先，tcp的行为对ip来说是不知道的。&lt;/p&gt;
&lt;p&gt;在tcp中，面向连接的传输需要经过三个阶段，简历连接，数据传输，连接终止。&lt;/p&gt;
&lt;h3 id=&quot;建立连接&quot;&gt;&lt;a href=&quot;#建立连接&quot; class=&quot;headerlink&quot; title=&quot;建立连接&quot;&gt;&lt;/
    
    </summary>
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/categories/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/tags/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>面试</title>
    <link href="http://yoursite.com/2017/03/22/%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2017/03/22/面试/</id>
    <published>2017-03-22T15:24:42.000Z</published>
    <updated>2017-03-22T15:30:42.887Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/categories/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/tags/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>TCPIP-传输层3-tcp1之概述</title>
    <link href="http://yoursite.com/2017/03/22/TCPIP-%E4%BC%A0%E8%BE%93%E5%B1%823-tcp1%E4%B9%8B%E6%A6%82%E8%BF%B0(1)/"/>
    <id>http://yoursite.com/2017/03/22/TCPIP-传输层3-tcp1之概述(1)/</id>
    <published>2017-03-22T15:24:42.000Z</published>
    <updated>2017-03-22T15:35:36.858Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>本章主要介绍一下几个目标</p>
<ol>
<li>介绍tcp这个能够提供可靠地流交付服务的协议</li>
<li>介绍tcp和udp的特点比较</li>
<li>定义tcp报文段的格式及其字段</li>
<li>tcp如何提供面向连接的服务</li>
<li>tcp状态转换图</li>
<li>tcp的流量控制和差错控制窗口</li>
<li>tcp计时器</li>
</ol>
<p> <img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\3.jpg" alt="image"></p>
<p>和udp不一样，tcp是一个面向流的协议。</p>
<h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><ol>
<li>发送缓存和接收缓存</li>
</ol>
<p>因为发送进程和接受进程可能已不同的速度写入数据和读取数据，因此tcp需要用缓存存储数据。<br>一个发送缓存和一个接收缓存。</p>
<p> <img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\4.jpg" alt="image"></p>
<p>发送方：</p>
<ul>
<li>白色区域是空槽</li>
<li>深灰色是已经发送出去但还没有得到确认的字节</li>
<li>灰色表示将要发送的字节</li>
</ul>
<p>接收方：</p>
<ul>
<li>白色区域包含的空槽江北从网络中接受的字节填入。</li>
<li>灰色区域包含的是已经接收到的字节，这些字节将被接收进城读取。当一个字节被接受进程读取后，相应的槽就可以被回收，加入到空槽中。</li>
</ul>
<ol>
<li><p>报文段<br>ip层作为tcp的服务提供者，他必须以分组为单位发送数据，而不是字节。在传输层，tcp把若干字节组成一个分组，称之为报文段。</p>
</li>
<li><p>全双工通信</p>
</li>
</ol>
<p>数据可以同一时间双向流动。</p>
<ol>
<li>面向连接的服务</li>
<li>可靠地服务<br>tcp通过确认机制来检查数据是否安全完好的到达。</li>
</ol>
<p>tcp的特点：</p>
<ol>
<li>编号系统</li>
</ol>
<ul>
<li>字节号（0~2^32-1）：在流量控制和差错控制中都要用到字节编号</li>
<li>序号：字节被边上号以后，给每一个要发送的报文段指派一个序号。就是报文段中第一个数据字节的序号。//1KB=1024B=1024byte=8192bit</li>
<li>确认号：指他期望接受的下一个字节的编号。（它吧收到的最后一个完好的字节的编号加一为确认号）</li>
</ul>
<ol>
<li>流量控</li>
<li>差错控制（tcp的差错控制是面向字节的）</li>
<li>拥塞控制</li>
</ol>
<p>在更详细的讨论tcp之前 我们先来看看tcp的组成。</p>
<h3 id="报文段"><a href="#报文段" class="headerlink" title="报文段"></a>报文段</h3><p>报文段包括了20~60字节的首部和数据。首部在没有选项的时候是20字节，如果有选项最多可达60字节。</p>
<p> <img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\5.jpg" alt="image"></p>
<ul>
<li>源端口地址： 这是一个16位的字段，定义了发送这个报文段的主机中的应用程序的端口号。</li>
<li>目的端口地址：这是一个16位的字段，定义了接受这个报文段主机的应用端口</li>
<li>序号：本报文段第一个数据字节的编号</li>
<li>确认号</li>
<li>首部长度：这个4位字段支出tcp首部一共有多少个4字节字，首部长度为20-60.所以该字节范围为5-15</li>
<li>保留：这是一个6位字段，保留为今后使用</li>
<li>控制：这个字段定义了6中不同的控制位或标志。这些位用在tcp的流量控制建立连接和终止，数据传输等方面。</li>
<li>窗口大小：这个字段定义的是发送tcp的窗口大小哦，以字节为单位。请注意这个字段是16位。也就是窗口的最大长度是65535字节。这个值是接收窗口，由接收方决定。</li>
<li>检验和：这个16位字段包含的是检验和。udp是否使用检验和是可选的。而tcp使用检验和则是强制的。</li>
<li>紧急指针：只有当紧急标志位置位的时候，这个字段才生效。此时报文段包含了而紧急数据。</li>
<li>选项：tcp首部中可以有多大40字节的可选信息。</li>
</ul>
<p>封装：</p>
<p>tcp报文段从应用层接收到数据。他本身北风撞到ip数据报中。</p>
<p> <img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\7.jpg" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;p&gt;本章主要介绍一下几个目标&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;介绍tcp这个能够提供可靠地流交付服务的协议&lt;/li&gt;
&lt;li&gt;介绍tcp和udp的特点
    
    </summary>
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/categories/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/tags/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>TCPIP-应用层5-http</title>
    <link href="http://yoursite.com/2017/03/22/TCPIP-%E5%BA%94%E7%94%A8%E5%B1%825-http/"/>
    <id>http://yoursite.com/2017/03/22/TCPIP-应用层5-http/</id>
    <published>2017-03-22T15:24:42.000Z</published>
    <updated>2017-03-22T16:33:44.238Z</updated>
    
    <content type="html"><![CDATA[<p>233…. http</p>
<h4 id="url"><a href="#url" class="headerlink" title="url"></a>url</h4><p>协议://主机：端口/路径</p>
<p>http方法：</p>
<ul>
<li>get</li>
<li>head 请求关于文档的信息，但不是这个文档本身</li>
<li>post</li>
<li>put 从服务器向客户发送一些请求</li>
<li>trace</li>
<li>connect</li>
<li>delete</li>
<li>options</li>
</ul>
<p>持续连接 1.1</p>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>cookie是被服务器产生 也是被服务器消耗的。</p>
<h4 id="http支持代理服务器"><a href="#http支持代理服务器" class="headerlink" title="http支持代理服务器"></a>http支持代理服务器</h4><p> 代理服务器是个计算机，他保留对最近请求的响应的副本。再由代理服务器的情况下，http吧请求发送给代理服务器，代理服务器检查他的高速缓存，有的话，返回，没的话，请求服务器，并把结果缓存，返回。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;233…. http&lt;/p&gt;
&lt;h4 id=&quot;url&quot;&gt;&lt;a href=&quot;#url&quot; class=&quot;headerlink&quot; title=&quot;url&quot;&gt;&lt;/a&gt;url&lt;/h4&gt;&lt;p&gt;协议://主机：端口/路径&lt;/p&gt;
&lt;p&gt;http方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get&lt;/l
    
    </summary>
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/categories/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/tags/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>TCPIP-传输层1-介绍</title>
    <link href="http://yoursite.com/2017/03/22/TCPIP-%E4%BC%A0%E8%BE%93%E5%B1%821-%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2017/03/22/TCPIP-传输层1-介绍/</id>
    <published>2017-03-22T15:24:42.000Z</published>
    <updated>2017-03-22T15:31:10.912Z</updated>
    
    <content type="html"><![CDATA[<p>本章主要介绍运输层的一些东西。分两个部分介绍 运输层服务和运输层协议。</p>
<h3 id="运输层服务"><a href="#运输层服务" class="headerlink" title="运输层服务"></a>运输层服务</h3><h4 id="进程到进程的通信"><a href="#进程到进程的通信" class="headerlink" title="进程到进程的通信"></a>进程到进程的通信</h4><p>运输层协议的首要任务是提供进程到进程的通信。<br>网络层负责计算机的通信（主机到主机）</p>
<p>端口： 0-65535</p>
<ul>
<li>熟知端口：0-1023 由icann指派和控制</li>
<li>注册端口：1024-49151 icann不指派 也不控制，但要到icann注册。</li>
<li>动态端口：19452-65535</li>
</ul>
<p>套接字地址：ip和端口的组合</p>
<ol>
<li>封装和解封</li>
<li>复用和分用<br> 当一个实体接受来自多个源的输入，成为复用。当一个实体将数据交付到多个源，成为分用。</li>
<li>流量控制<br> 当一个实体产生数据而另一个实体消耗数据。 （推送和拉取）</li>
<li><p>差错控制</p>
<ul>
<li>检测并丢弃损坏的分组</li>
<li>跟踪丢失和丢弃的分组并重传他们</li>
<li>识别重复的分组并丢弃他们</li>
<li><p>保存失序到达的组，知道缺失的分组全部到达。</p>
<p>序号.给每个分组进行编号</p>
<p>确认。计时器</p>
</li>
</ul>
</li>
<li><p>流量控制和差错控制的组合（滑动窗口）<br> 流量控制要使用两个缓存。因为序号是2^m的，所以0到2^m-1的序号可以表示一个环。缓存被表示为一组小个子，成为滑动窗口。<br> 在任何时候他们都占据了圆的一部分。</p>
</li>
<li><p>拥塞控制<br> 如果网络中分负载大于网络的容量，这个网络就有可能发生拥塞。拥塞控制指的是用来控制拥塞。</p>
</li>
<li>无连接和面向连接的服务<br> 不管是无连接还是面向连接。一个运输层协议的行为可以很好地用一个有限状态机表示。</li>
</ol>
<h3 id="运输层协议"><a href="#运输层协议" class="headerlink" title="运输层协议"></a>运输层协议</h3><ol>
<li>简单协议：什么都没有</li>
<li>停止等待协议： 差错检验 流量控制。但是必须等待ack，或者超时才能继续发送</li>
<li>返回n协议： 在等待的时候，仍然可以发送报文。</li>
<li>选择重传协议</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章主要介绍运输层的一些东西。分两个部分介绍 运输层服务和运输层协议。&lt;/p&gt;
&lt;h3 id=&quot;运输层服务&quot;&gt;&lt;a href=&quot;#运输层服务&quot; class=&quot;headerlink&quot; title=&quot;运输层服务&quot;&gt;&lt;/a&gt;运输层服务&lt;/h3&gt;&lt;h4 id=&quot;进程到进程的通信&quot;&gt;
    
    </summary>
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/categories/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/tags/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>TCPIP-传输层2-用户数据包协议（udp）</title>
    <link href="http://yoursite.com/2017/03/22/TCPIP-%E4%BC%A0%E8%BE%93%E5%B1%822-%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8D%8F%E8%AE%AE%EF%BC%88udp%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/22/TCPIP-传输层2-用户数据包协议（udp）/</id>
    <published>2017-03-22T15:24:42.000Z</published>
    <updated>2017-03-22T15:34:01.848Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要分为以下几个部分讲解。</p>
<ol>
<li>介绍udp</li>
<li>说明udp分组的格式</li>
<li>udp提供的服务</li>
<li>说明如何计算可选的检验和</li>
</ol>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>udp是一种无连接 不可靠的运输协议。</p>
<p>udp的分组叫做<strong>用户数据报</strong>，它有8个字节的固定首部。</p>
<p><img src="http://i.imgur.com/8JF1KSr.png" alt=""></p>
<ul>
<li>源端口号：源主机上运行的进程所使用的端口号</li>
<li>目的端口号：目的主机上进程所使用的端口号</li>
<li>总长度：这是一个16位的字段，它定义了用户数据报的总长度，首部加上数据。16位可定义的总长度是从0到65535字节。实际上总长度必须比这个数小，因为udp用户数据要放在总长度65535字节的ip数据报中。</li>
<li>检验和：这个字段用来检验整个数据报出现的差错。</li>
</ul>
<h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><ol>
<li><p>udp使用套接字提供进程到进程的服务。</p>
</li>
<li><p>无连接服务:udp提供无连接服务，意味着每一个用户数据报都是独立的数据报。</p>
</li>
<li>不提供流量控制</li>
<li>差错控制，除了检验和之外，没有其他机制、这就表示发送方并不知道报文是丢失了还是重复交付了，当接收方通过检验和检测出差错时，就悄悄地讲这个用户数据报丢掉。</li>
</ol>
<p>伪首部是封装用书包的那个ip分组的首部的一部分，其中有些字段要填入0</p>
<p>其中有一个协议字段是为了确保这个分组属于udp，值为17，如果这个值在传输过程中改变了，接收端计算检验和就可能检测出来，udp就会放弃这个分组。</p>
<ol>
<li>不提供拥塞控制</li>
<li>封装和解封</li>
</ol>
<p>当进程有报文要通过udp发送，他就把这个报文连同一堆套接字地址以及数据的长度传递给udp。udp收到数据后添加一个udp首部。然后udp把这个用户数据报连同套接字一起传递给ip。ip再加上自己的首部。在协议字段使用值17，支出该数据是从udp协议来的。然后再把这个ip传递给链路层，封装成帧，再传递给物理层。物理层把比特编码成电信号和光信号，发送到远程的机器上。</p>
<p>解封 过程和上述相反、</p>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\15.png" alt="image"></p>
<ol>
<li>排队<br>udp中，队列和端口相关联。</li>
</ol>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\16.png" alt="image"></p>
<p>在客户端，当一个进程启动时，他从操作系统哪里请求得到一个端口号。有些实现为每个进程创建一个如队列和一个出队列与之相关。</p>
<p>在服务器端，创建队列的机制是不同的，在最简单的形势下，服务器进程在它开始运行时就请求为他的熟知端口创建如队列和出队列。只要服务器进程一直运行，这些对列就一直是打开的、</p>
<p>所有发送给某个特定服务器程序的入报文，不管是来自相同的或者是不用的客户，都会被放入到一个队列。入队列可能会溢出。若发生溢出，udp就会丢弃这个用户数据报，并请求向客户发送端口不可达。</p>
<p>当服务器想要回答客户时，他就要在请求中之名的源端口把报文送到出队列。</p>
<ol>
<li>复用和分用</li>
</ol>
<p>主机上只有一个udp，但可能多个进程希望使用udp服务。那么udp进行复用和分用，<br>复用：在发送端根据指定不同的端口号来区分。分用，根据目的端口号，吧每一个报文交付给适当的进程。</p>
<ol>
<li>udp的应用</li>
</ol>
<ul>
<li>udp使用与只要求简单的请求-响应通信的进程。</li>
<li>udp适用于具有内部流量控制和差错控制机智的进程，例如简单文件传输协议（TFTP）</li>
<li>对于多播来说，udp是一个合适的运输协议。</li>
<li>适用于管理进程，如snmp</li>
<li>适用于某些路由选择更新协议。</li>
<li>适用于实时应用，他们不能容忍在就收报文的各个片段之间存在变化的时延。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要分为以下几个部分讲解。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;介绍udp&lt;/li&gt;
&lt;li&gt;说明udp分组的格式&lt;/li&gt;
&lt;li&gt;udp提供的服务&lt;/li&gt;
&lt;li&gt;说明如何计算可选的检验和&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class
    
    </summary>
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/categories/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/tags/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>网络层</title>
    <link href="http://yoursite.com/2017/03/22/TCPIP-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://yoursite.com/2017/03/22/TCPIP-网络层/</id>
    <published>2017-03-22T15:24:42.000Z</published>
    <updated>2017-03-22T15:38:46.721Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>网络层负责主机到主机的交付。并且在分组经过路由器时负责为其选择路由。</p>
<h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><ol>
<li>电路交换</li>
<li>分组交换</li>
</ol>
<p>来自上层的报文被分割成便于管理的一个个分组，再通过网络发送这些分组。豹纹的源点逐个发送分组，而其重点也逐个接受这些分组。当分组都到期之后，再交付给上层。</p>
<ul>
<li>无连接服务</li>
</ul>
<p>每个分组都是一个独立的个体</p>
<p>每个分组都选择路由时要根据包含在首部的信息：原地址和目的地址，路由器仅仅根据目的地址为期路由，原地址为用于该数据包被丢弃的时候，向源点发送差错信息。</p>
<ul>
<li>面向连接服务</li>
</ul>
<p>在面向连接的服务中，属于同一个报文的所有分组之间是有关联的。在一个豹纹的数据报被发送之前，应当首先建立一条徐连接已制定这些数据流通过的路径。在这种类型的服务中，分组不仅要包含原地址和目标地址，还要包含一个流标号。</p>
<p>要建立面向连接的服务必须经过以下三个阶段： 建链 数据传送 拆链。</p>
<p>各分组的转发依据包含在分组中的标号。<br><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\22.png" alt="image"></p>
<ol>
<li>其他问题</li>
</ol>
<ul>
<li>差错控制</li>
</ul>
<p>差错控制包括损坏，丢失以及重复的数据报进行检测的机制。</p>
<ul>
<li>流量控制</li>
</ul>
<p>用于调整源点发送的数据量以避免接收方超载。</p>
<ul>
<li>拥塞控制</li>
</ul>
<h3 id="ipv4"><a href="#ipv4" class="headerlink" title="ipv4"></a>ipv4</h3><p>ipv4是一个32位的地址。他们的唯一性表示了在每个地址仅能定义一个到因特网的链接。</p>
<ol>
<li>编址</li>
</ol>
<p>五类：abcde</p>
<ul>
<li>0 0-127</li>
<li>10 128-191</li>
<li>110 192-223</li>
<li>1110 224-239</li>
<li>1111 240-255</li>
</ul>
<ol>
<li>nat</li>
</ol>
<p>nat:网络地址转换 它提供了专用地址和全球地址之前的互相映射。同时支持虚拟专用网络。</p>
<p>nat路由器有一张转换表</p>
<p>使用ip地址池： 如果nat路由器仅仅使用一个全球地址，俺么在专用网路中一次只允许一台机器访问外部机器。<br>使用ip地址和端口地址：为了和外部服务器程序之间多对多的关系。</p>
<table>
<thead>
<tr>
<th>专用地址</th>
<th>专用端口</th>
<th>外部地址</th>
<th>外部端口</th>
<th>运输层协议</th>
</tr>
</thead>
<tbody>
<tr>
<td>172.18.3.1</td>
<td>1400</td>
<td>25.8.3.3</td>
<td>80</td>
<td>tcp</td>
</tr>
<tr>
<td>172.18.3.1</td>
<td>1401</td>
<td>25.8.3.3</td>
<td>80</td>
<td>tcp</td>
</tr>
</tbody>
</table>
<h3 id="ip分组的交付和转发"><a href="#ip分组的交付和转发" class="headerlink" title="ip分组的交付和转发"></a>ip分组的交付和转发</h3><p>交付是指在网络层的控制下，底层各个网络对分组的处理方式。</p>
<p>转发指的是把分组交付到下一站的方式。分为基于目的地址的转发和基于附加在分组上的标记和转发</p>
<h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>arp接受来自ip协议的逻辑地址，将其映射为响应的物理地址。然后把这个物理地址交给数据链路层。</p>
<p>当一个主机想要知道另一个主机的物理地址是，发送一个arp查询分组，这个分组包含了发送方得mac和ip地址，和目的主机的ip。因为发送不知道接收方的物理地址，所以这个查询分组会在网络上进行广播。</p>
<p>网络上每一个主机都接受并处理这个arp查询分组，但只有期待的接受者才能认出这是自己的ip，并返回一个arp分组，</p>
<h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>ipv4提供了不可靠和无连接的数据报交付。<br>有点：有效的利用网络资源。<br>缺点：缺少差错控制和辅助机制。</p>
<p>icmpv4就是为了补偿这两个缺点设计的。</p>
<p>icmp首先要封装成ip数据报，然后才被传递到下一层。</p>
<h3 id="单播"><a href="#单播" class="headerlink" title="单播"></a>单播</h3><h3 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;网络层负责主机到主机的交付。并且在分组经过路由器时负责为其选择路由。&lt;/p&gt;
&lt;h4 id=&quot;交换&quot;&gt;&lt;a href=&quot;#交换&quot; class
    
    </summary>
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/categories/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/tags/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>TCPIP-应用层3-dns</title>
    <link href="http://yoursite.com/2017/03/22/TCPIP-%E5%BA%94%E7%94%A8%E5%B1%823-dns/"/>
    <id>http://yoursite.com/2017/03/22/TCPIP-应用层3-dns/</id>
    <published>2017-03-22T15:24:42.000Z</published>
    <updated>2017-03-22T16:30:15.872Z</updated>
    
    <content type="html"><![CDATA[<h4 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h4><p>dns 的作用就是把应用层的主机名映射为网络层的ip地址。</p>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\31.jpg" alt="image"></p>
<ol>
<li>用户把主机名传给dns客户进程</li>
<li>文件传输客户进程吧这个主机名传给dns客户进程</li>
<li>dns客户利用已知的dns服务器的ip，向服务器发送报文，这个报文是指定了文件传送服务器名的查询报文</li>
<li>dns服务器吧这个ip地址交付给文件传送客户进程。</li>
<li>文件传送客户进程利用收到的ip地址进行传送文件访问服务器。</li>
</ol>
<h4 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h4><ul>
<li>平面名字空间</li>
<li>层次名字空间</li>
<li>域名空间</li>
</ul>
<p>域名空间所包含的信息必须保存下来。把信息分不到多台机器上，机器为dns服务器。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>把名字映射为地址，或者把地址映射为名字，成为名字地址解析。</p>
<ol>
<li>名字到地址的解析<br> 解析程序将域名给服务器，根据域名所属不同类（国家，类），先把这个域名发送给本地dns服务器解析，不能完成，在询问其他服务器、</li>
<li><p>地址到名字的映射<br> 客户想服务器发送ip地址寻找域名，成为PTR查询。dns使用反向域。<br> 132.34.45.121—-121.45.34.132.in-addr.arpa 在进行接受和解析</p>
</li>
<li><p>递归解析：表示解析程序期望服务器提供最终的解答。（表示服务器解决不了转发给另一个服务器）</p>
</li>
<li>迭代解析：（表示服务器解决不了，返回一个服务器ip地址，解析程序再去访问新的服务器）</li>
<li>高速缓存：当一个服务器向另一个服务器请求映射并受到响应后，返回信息给客户端之前，会存储在自己的高速缓存中，同一个客户或者请求同样的映射，就会先检查缓存，有的话返回，不过要把这个响应标记为未授权的。</li>
</ol>
<h4 id="dns报文"><a href="#dns报文" class="headerlink" title="dns报文"></a>dns报文</h4><p>dns有两种报文：查询报文和响应报文</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>dns可以使用udp也可以使用tcp。服务其实用的熟知端口都是53.当响应报文的长度小于512字节用udp。否则使用tcp、</p>
<h4 id="dns安全性？？"><a href="#dns安全性？？" class="headerlink" title="dns安全性？？"></a>dns安全性？？</h4><ol>
<li>攻击者可能会独处一个dns服务器的响应。以找出用户最长访问的站点的性质或者名称，此类信息可以被用来发现用户的特征。dns报文需要加密。</li>
<li>攻击者可能会截获一个dns服务器响应，创建一个全新的假冒响应。</li>
<li>攻击者可能会采用洪泛的方法使dns服务器超载。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;dns&quot;&gt;&lt;a href=&quot;#dns&quot; class=&quot;headerlink&quot; title=&quot;dns&quot;&gt;&lt;/a&gt;dns&lt;/h4&gt;&lt;p&gt;dns 的作用就是把应用层的主机名映射为网络层的ip地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;C:\Users\neuly.DESK
    
    </summary>
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/categories/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/tags/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>TCPIP-传输层5-tcp3之流量控制差错控制和拥塞控制</title>
    <link href="http://yoursite.com/2017/03/22/TCPIP-%E4%BC%A0%E8%BE%93%E5%B1%825-tcp3%E4%B9%8B%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2017/03/22/TCPIP-传输层5-tcp3之流量控制差错控制和拥塞控制/</id>
    <published>2017-03-22T15:24:42.000Z</published>
    <updated>2017-03-22T15:38:30.976Z</updated>
    
    <content type="html"><![CDATA[<p>在讨论流量 差错 阻塞之前。我们要先描述一下窗口。tcp为每个方向的数据传输各使用两个窗口。</p>
<h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><h4 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h4><p>发送窗口大小由接收方以及底层网络拥塞成都决定。图中描绘了打开 关闭 收缩。</p>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\9.jpg" alt="image"></p>
<p>注意事项：</p>
<ol>
<li>tcp中为字节编号。控制窗口的变量单位是以字节为单位的。</li>
<li>tcp只是用一个计数器。</li>
</ol>
<h4 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h4><p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\10.jpg" alt="image"></p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>平衡了生产者消费者之间的速度。</p>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\11.jpg" alt="image"></p>
<p>图中描述的数据走向是从发送进程乡下到达发送tcp，再从发送tcp到接受tcp，然后从接受不tcp向上到达接受进程。不过，流量控制的反馈走向是从接受tcp到发送tcp，以及从发送tcp向上到发送进程的。tcp的绝大多数实现都不提供从接受进程到接受tcp的流量控制反馈，而是让接受进程在准备就绪时去接受tcp哪里拉取数据。换言之，接受tcp控制了发送tcp。</p>
<p>为了实现流量控制，tcp强制发送方和接收方不断调整他们的窗口大小。</p>
<p>一个例子：<br><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\12.jpg" alt="image"></p>
<p>窗口关闭：<br>使发送窗口的右臂想做移动收缩是不希望的，但是有一个例外。接收端可以发送rwnd为0的报文来暂时关闭窗口。这种情况是由于接受方因某种原因在一段时间内不愿意从接受方接受任何数据。此时，发送方实际上并非真正的把窗口大小缩小了，只是暂定发送。直到收到一个新的通告为止。</p>
<p>糊涂窗口综合征：<br>加入tcp发送报文只包含一个字节的数据。那么意味着额外开销为41/1 （20个tcp首部 20个ip首部）。低效的。那么为了防指 就要强波发送tcp等待。怎么确定等待时间呢？</p>
<p>nagle算法：<br>1.发送tcp把他的第一个数据块发送出去，哪怕只有一个字节。<br>2.发送了第一个报文段后，发送tcp就能在输出缓存中积累数据等待，知道收到了tcp发来的确认。或者累计了足够多的 数据可以装成最大长度的报文段，这时，发送tcp就可以发送这个报文段了。<br>3.对省辖的传输，不断地重复步骤2.</p>
<h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>tcp使用差错控制来提供可靠性。差错控制包含以下的一些机制：检测和重传收到损伤的报文段，重传丢失的报文段，保存失序到达的报文段直至缺失的报文段到期，以及检测和丢弃重复的报文段。</p>
<p>tcp使用：检验和、确认、超时三个工具。</p>
<ol>
<li>每个报文段都有一个检验和字段。损伤就丢弃，病人伪是丢失了。</li>
<li>确认</li>
<li>重传</li>
<li>失序的报文段</li>
</ol>
<p>发送方tcp为每一条连接设置一个重传超时计数器。当计数器时间到，tcp发送队列中最前面的报文段，并重启计数器、</p>
<p>如果允许发送方更快的重传，而不用等待计时器超时，就能更有利于网络吞吐量。因此现在大多数实现都遵循收到三个重复ack就立刻重传丢失的报文段的规则。这一特性称为快重传。</p>
<p>失序的报文段</p>
<p>现在的tcp实现都不会丢弃失序到达的报文段，而是把这些报文段暂时保存下来，并把他们标记为失序报文段，直至缺失的报文段到期。</p>
<p>tcp数据传送的fsm</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>发送方有两个信息：接收方通告的窗口大小和拥塞窗口大小。窗口的真正大小去两者之中较小的一个。</p>
<p>tcp处理yongse一般策略是基于三个阶段：慢开始，拥塞避免，拥塞检测。</p>
<ul>
<li>慢开始： cwnd从1个报文段开始，每次ack回来，便想加，是一个指数级增大的。当窗口大小到达ssthresh（慢开始门限），该阶段就结束了，并进入下一个阶段。</li>
<li>拥塞避免：加法增大 当到达慢开始门限时，加法增加阶段就开始了。每当一争个“窗口”中的报文段都被确认后，拥塞窗口大小就增加1.</li>
<li>拥塞检查：乘法减小：如果拥塞发生，窗口大写哦就必须减少。<ol>
<li>如果计时器超时，出现拥塞可能性很大，某个报文段可能在网络中某处被抛弃了，后续报文段也没有消息。<br>a. 把门限值设置为当前窗口大小的一半<br>b. 把cwnd重新设置为一个报文段。<br>c. 再次从慢开始阶段开始。</li>
<li>如果是收到三个ack，那么出现拥塞可能性较小。某段可能被丢弃，但之后的几个安全到达，因为收到了三个重复ack，称之为快重传和快恢复。在这种情况下。tcp有以下反应<br>a. 把门限值设置为当前窗口值得一半<br>b. 把cwnd设置为门限值<br>c. 启动拥塞避免阶段。</li>
</ol>
</li>
</ul>
<p>小结：<br>给出一个例子。假设最大窗口大小的初始值是32个报文段。门限的初始值设置为16.在慢开始阶段，窗口从1开始增大，直到达到门限值。拥塞避免按照加法增大，当窗口发生超时现象，乘法减小过程开始生效，吧门限值减小到窗口大小的一半。</p>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\13.jpg" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在讨论流量 差错 阻塞之前。我们要先描述一下窗口。tcp为每个方向的数据传输各使用两个窗口。&lt;/p&gt;
&lt;h3 id=&quot;窗口&quot;&gt;&lt;a href=&quot;#窗口&quot; class=&quot;headerlink&quot; title=&quot;窗口&quot;&gt;&lt;/a&gt;窗口&lt;/h3&gt;&lt;h4 id=&quot;发送窗口&quot;&gt;&lt;a hr
    
    </summary>
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/categories/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/tags/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>TCPIP-应用层1-简介</title>
    <link href="http://yoursite.com/2017/03/22/TCPIP-%E5%BA%94%E7%94%A8%E5%B1%821-%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2017/03/22/TCPIP-应用层1-简介/</id>
    <published>2017-03-22T15:24:42.000Z</published>
    <updated>2017-03-22T15:39:06.089Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>无连接顺序服务器</li>
</ol>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\17.png" alt="image"></p>
<ol>
<li>面向连接的并发服务器</li>
</ol>
<p>服务器从熟知端口接受连接请求，客户端可逆在发送连接的时候访问这个熟知端口。而在建立连接后，服务器九尾该链接指派一个临时端口。以释放它自己的熟知端口。此后，数据的传输发生在两个临时的端口之间。此时熟知端口就空闲下来你为另一个客户建立连接。腰围若干个客户同时提供服务，服务器必须要创建子进程。服务器还必须要为每个连接简历一个队列。来自客户的报文段被保存在相应的队列里面。</p>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\18.png" alt="image"></p>
<ol>
<li>套接字</li>
</ol>
<p>应用层 –套接字接口–操作系统</p>
<p>应用程序如果想接入由tcp/ip协议族提供的服务，就必须使用在套接字接口中定义的指令、</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct socket&#123;</div><div class="line">    int family;</div><div class="line">    int type;</div><div class="line">    int protocol;</div><div class="line">    socketaddr local;</div><div class="line">    socketaddr remote;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>族：这个字段定义了一个协议族：ipv4 ipv6等等，<br>类型：定义了四种类型的套接字 sock_stream（tcp） sock_dgram（udp） sock_seqpacket（sctp） sock_raw（直接用于ip服务的应用）<br>协议：对于tcpip 设置为0<br>本地套接字地址：ip地址和端口地址的组合<br>远程套接字地址：ip地址和端口地址的组合</p>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\19.png" alt="image"></p>
<p>函数：</p>
<ul>
<li>socket</li>
<li>bind</li>
<li>connect</li>
<li>listen</li>
<li>accept</li>
<li>fock</li>
<li>send recv</li>
<li>sendto recvfrom</li>
<li>close</li>
</ul>
<ol>
<li>使用udp通信</li>
</ol>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\20.png" alt="image"></p>
<ol>
<li>使用tcp通信</li>
</ol>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\21.png" alt="image"> </p>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;无连接顺序服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\17.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;面向连接的并发服务器&lt;/li&gt;
&lt;/ol&gt;

    
    </summary>
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/categories/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/tags/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>TCPIP-应用层2-dhcp</title>
    <link href="http://yoursite.com/2017/03/22/TCPIP-%E5%BA%94%E7%94%A8%E5%B1%822-dhcp/"/>
    <id>http://yoursite.com/2017/03/22/TCPIP-应用层2-dhcp/</id>
    <published>2017-03-22T15:24:42.000Z</published>
    <updated>2017-03-22T15:39:31.503Z</updated>
    
    <content type="html"><![CDATA[<p>动态主机配置协议：dhcp</p>
<p>dhcp:当一台主机地洞后，如果认为自己应当连接到internet，又不知道自己ip.这时候dhcp就发挥作用了、</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态主机配置协议：dhcp&lt;/p&gt;
&lt;p&gt;dhcp:当一台主机地洞后，如果认为自己应当连接到internet，又不知道自己ip.这时候dhcp就发挥作用了、&lt;/p&gt;

    
    </summary>
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/categories/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/tags/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>tcp3之连接</title>
    <link href="http://yoursite.com/2017/03/17/tcp3%E4%B9%8B%E8%BF%9E%E6%8E%A5/"/>
    <id>http://yoursite.com/2017/03/17/tcp3之连接/</id>
    <published>2017-03-17T12:52:12.000Z</published>
    <updated>2017-03-17T07:38:12.607Z</updated>
    
    <content type="html"><![CDATA[<p>ps：首先，tcp的行为对ip来说是不知道的。</p>
<p>在tcp中，面向连接的传输需要经过三个阶段，简历连接，数据传输，连接终止。</p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>TCP是TCP/IP的传输层控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:</p>
<p>首先需要了解几个名词：tcp标志位,有6种分别为：SYN(synchronous建立联机) 、ACK(acknowledgement 确认) 、PSH(push传送) 、FIN(finish结束)、 RST(reset重置) 、URG(urgent紧急);</p>
<ul>
<li>URG 紧急指针，告诉接收TCP模块紧要指针域指着紧要数据。</li>
<li>ACK 置1时表示确认号（为合法，为0的时候表示数据段不包含确认信息，确认号被忽略。 </li>
<li>PSH 置1时请求的数据段在接收方得到后就可直接送到应用程序，而不必等到缓冲区满时才传送。 </li>
<li>RST 置1时重建连接。如果接收到RST位时候，通常发生了某些错误。 </li>
<li>SYN 置1时用来发起一个连接。 </li>
<li>FIN 置1时表示发端完成发送任务。用来释放连接，表明发送方已经没有数据发送了。</li>
<li>另外还有 Sequence number(顺序号码) 、Acknowledge number(确认号码)在建立握手过程中发送的序列号。</li>
</ul>
<p>主机A(client)和主机B(server)开始建立握手过程：</p>
<ul>
<li>第一次握手：主机A发送位码为syn＝1,随机产生seq number=10001的数据包到服务器，主机B由SYN=1知道，A要求建立联机，此时状态为SYN_SENT；</li>
<li>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=20001的包，此时状态由LISTEN变为SYN_RECV；</li>
<li>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功，双方状态ESTABLISHED。</li>
</ul>
<p>完成三次握手，主机A与主机B开始传送数据。</p>
<p><img src="http://i.imgur.com/sNQUAgo.png" alt=""></p>
<p>syn洪泛攻击</p>
<p>当一个或多个而已的攻击者向某台服务器发送大量的syn报文段。并通过伪造报文段中的源ip地址来假装每一个报文段来自不同的客户时，这个问题就发生了。</p>
<p>一些策略：限定在指定时间内的连接请求次数，有些则吧来自不希望的原地址的数据报过滤掉。最近使用的一种策略是通过使用cookie，做到推迟资源分配，知道服务器核实是有效连接。在分配资源、</p>
<h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><ul>
<li>推送数据</li>
<li>紧急数据</li>
</ul>
<h3 id="连接终止"><a href="#连接终止" class="headerlink" title="连接终止"></a>连接终止</h3><p>目前，大多数tcp实现允许在连接终止时有两种选择：三向握手和具有半关闭选项的四向握手。</p>
<ul>
<li><p>三向握手</p>
</li>
<li><p>半关闭<br>在tcp中，连接的乙方停止发送数据，单仍然可以接收数据，称之为半关闭。</p>
</li>
</ul>
<h3 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h3><p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\8.jpg" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ps：首先，tcp的行为对ip来说是不知道的。&lt;/p&gt;
&lt;p&gt;在tcp中，面向连接的传输需要经过三个阶段，简历连接，数据传输，连接终止。&lt;/p&gt;
&lt;h3 id=&quot;建立连接&quot;&gt;&lt;a href=&quot;#建立连接&quot; class=&quot;headerlink&quot; title=&quot;建立连接&quot;&gt;&lt;/
    
    </summary>
    
      <category term="tcp-ip协议族" scheme="http://yoursite.com/categories/tcp-ip%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="tcpip" scheme="http://yoursite.com/tags/tcpip/"/>
    
  </entry>
  
  <entry>
    <title>tcp1之概述</title>
    <link href="http://yoursite.com/2017/03/17/tcp1%E4%B9%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2017/03/17/tcp1之概述/</id>
    <published>2017-03-17T12:52:12.000Z</published>
    <updated>2017-03-17T07:37:34.320Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>本章主要介绍一下几个目标</p>
<ol>
<li>介绍tcp这个能够提供可靠地流交付服务的协议</li>
<li>介绍tcp和udp的特点比较</li>
<li>定义tcp报文段的格式及其字段</li>
<li>tcp如何提供面向连接的服务</li>
<li>tcp状态转换图</li>
<li>tcp的流量控制和差错控制窗口</li>
<li>tcp计时器</li>
</ol>
<p> <img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\3.jpg" alt="image"></p>
<h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><ol>
<li>发送缓存和接收缓存</li>
</ol>
<p>因为发送进程和接受进程可能已不同的速度写入数据和读取数据，因此tcp需要用缓存存储数据。<br>一个发送缓存和一个接收缓存。</p>
<p> <img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\4.jpg" alt="image"></p>
<p>发送方：</p>
<ul>
<li>白色区域是空槽</li>
<li>深灰色是已经发送出去但还没有得到确认的字节</li>
<li>灰色表示将要发送的字节</li>
</ul>
<p>接收方：</p>
<ul>
<li>白色区域包含的空槽江北从网络中接受的字节填入。</li>
<li>灰色区域包含的是已经接收到的字节，这些字节将被接收进城读取。当一个字节被接受进程读取后，相应的槽就可以被回收，加入到空槽中。</li>
</ul>
<ol>
<li><p>报文段<br>ip层作为tcp的服务提供者，他必须以分组为单位发送数据，而不是字节。在传输层，tcp把若干字节组成一个分组，称之为报文段。</p>
</li>
<li><p>全双工通信</p>
</li>
</ol>
<p>数据可以同一时间双向流动。</p>
<ol>
<li>面向连接的服务</li>
<li>可靠地服务<br>tcp通过确认机制来检查数据是否安全完好的到达。</li>
</ol>
<p>tcp的特点：</p>
<ol>
<li>编号系统</li>
</ol>
<ul>
<li>字节号（0~2^32-1）</li>
<li>序号：字节被边上号以后，给每一个要发送的报文段指派一个序号。就是报文段中第一个数据字节的序号。</li>
<li>确认号：指他期望接受的下一个字节的编号。（它吧收到的最后一个完好的字节的编号加一为确认号）</li>
</ul>
<ol>
<li>流量控</li>
<li>差错控制（tcp的差错控制是面向字节的）</li>
<li>拥塞控制</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;p&gt;本章主要介绍一下几个目标&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;介绍tcp这个能够提供可靠地流交付服务的协议&lt;/li&gt;
&lt;li&gt;介绍tcp和udp的特点
    
    </summary>
    
      <category term="tcp-ip协议族" scheme="http://yoursite.com/categories/tcp-ip%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="tcpip" scheme="http://yoursite.com/tags/tcpip/"/>
    
  </entry>
  
  <entry>
    <title>tcp之滑动窗口及拥塞控制</title>
    <link href="http://yoursite.com/2017/03/17/tcp%E4%B9%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8F%8A%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2017/03/17/tcp之滑动窗口及拥塞控制/</id>
    <published>2017-03-17T12:52:12.000Z</published>
    <updated>2017-03-22T16:34:54.642Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TCP的滑动窗口机制"><a href="#TCP的滑动窗口机制" class="headerlink" title="TCP的滑动窗口机制"></a>TCP的滑动窗口机制</h4><p>TCP这个协议是网络中使用的比较广泛，他是一个面向连接的可靠的传输协议。既然是一个可靠的传输协议就需要对数据进行确认。TCP协议里窗口机制有2种：一种是固定的窗口大小；一种是滑动的窗口。这个窗口大小就是我们一次传输几个数据。对所有数据帧按顺序赋予编号，发送方在发送过程中始终保持着一个发送窗口，只有落在发送窗口内的帧才允许被发送；同时接收方也维持着一个接收窗口，只有落在接收窗口内的帧才允许接收。这样通过调整发送方窗口和接收方窗口的大小可以实现流量控制。</p>
<p>TCP滑动窗口技术通过动态改变窗口大小来调节两台主机间数据传输。每个TCP/IP主机支持全双工数据传输，因此TCP有两个滑动窗口：一个用于接收数据，另一个用于发送数据。TCP使用肯定确认技术，其确认号指的是下一个所期待的字节。 假定发送方设备以每一次三个数据包的方式发送数据，也就是说，窗口大小为3。发送方发送序列号为1、2、3的三个数据包，接收方设备成功接收数据包，用序列号4确认。发送方设备收到确认，继续以窗口大小3发送数据。当接收方设备要求降低或者增大网络流量时，可以对窗口大小进行减小或者增加，本例降低窗口大小为2，每一次发送两个数据包。当接收方设备要求窗口大小为0，表明接收方已经接收了全部数据，或者接收方应用程序没有时间读取数据，要求暂停发送。发送方接收到携带窗口号为0的确认，停止这一方向的数据传输。</p>
<p>固定窗口的坏处：</p>
<p>假设窗口的大小是1，也是就每次只能发送一个数据只有接受方对这个数据进行确认了以后才能发送第2个数据。我们可以看到发送方每发送一个数据接受方就要给发送方一个ACK对这个数据进行确认。只有接受到了这个确认数据以后发送方才能传输下个数据。 这样我们考虑一下如果说窗口过小，那么当传输比较大的数据的时候需要不停的对数据进行确认，这个时候就会造成很大的延迟。如果说窗口的大小定义的过大。我们假设发送方一次发送100个数据。但是接收方只能处理50个数据。这样每次都会只对这50个数据进行确认。发送方下一次还是发送100个数据，但是接受方还是只能处理50个数据。这样就避免了不必要的数据来拥塞我们的链路。所以我们就引入了滑动窗口机制，窗口的大小并不是固定的而是根据我们之间的链路的带宽的大小，这个时候链路是否拥护塞。接受方是否能处理这么多数据了。</p>
<p>滑动窗口如何工作：<br><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\1.png" alt="image"></p>
<p>首先是第一次发送数据这个时候的窗口大小是根据链路带宽的大小来决定的。我们假设这个时候窗口的大小是3。这个时候接受方收到数据以后会对数据进行确认告诉发送方我下次希望手到的是数据是多少。这里我们看到接收方发送的ACK=3(这是发送方发送序列2的回答确认，下一次接收方期望接收到的是3序列信号)。这个时候发送方收到这个数据以后就知道我第一次发送的3个数据对方只收到了2个。就知道第3个数据对方没有收到。下次在发送的时候就从第3个数据开始发。这个时候窗口大小就变成了2 。 </p>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\2.png" alt="image"></p>
<p>看到接收方发送的ACK是5就表示他下一次希望收到的数据是5，发送方就知道我刚才发送的2个数据对方收了这个时候开始发送第5个数据。<br>这就是滑动窗口的工作机制，当链路变好了或者变差了这个窗口还会发生变话，并不是第一次协商好了以后就永远不变了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TCP的滑动窗口机制&quot;&gt;&lt;a href=&quot;#TCP的滑动窗口机制&quot; class=&quot;headerlink&quot; title=&quot;TCP的滑动窗口机制&quot;&gt;&lt;/a&gt;TCP的滑动窗口机制&lt;/h4&gt;&lt;p&gt;TCP这个协议是网络中使用的比较广泛，他是一个面向连接的可靠的传输协议。既然
    
    </summary>
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/categories/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="TCPIP协议族" scheme="http://yoursite.com/tags/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>tcp2之报文段</title>
    <link href="http://yoursite.com/2017/03/17/tcp2%E4%B9%8B%E6%8A%A5%E6%96%87%E6%AE%B5/"/>
    <id>http://yoursite.com/2017/03/17/tcp2之报文段/</id>
    <published>2017-03-17T12:52:12.000Z</published>
    <updated>2017-03-17T07:37:54.022Z</updated>
    
    <content type="html"><![CDATA[<p>在更详细的讨论tcp之前 我们先来看看tcp的组成。</p>
<h3 id="报文段"><a href="#报文段" class="headerlink" title="报文段"></a>报文段</h3><p>报文段包括了20~60字节的首部和数据。首部在没有选项的时候是20字节，如果有选项最多可达60字节。</p>
<p> <img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\5.jpg" alt="image"></p>
<ul>
<li>源端口地址： 这是一个16位的字段，定义了发送这个报文段的主机中的应用程序的端口号。</li>
<li>目的端口地址：这是一个16位的字段，定义了接受这个报文段主机的应用端口</li>
<li>序号：本报文段第一个数据字节的编号</li>
<li>确认号</li>
<li>首部长度：这个4位字段支出tcp首部一共有多少个4字节字，首部长度为20-60.所以该字节范围为5-15</li>
<li>保留：这是一个6位字段，保留为今后使用</li>
<li>控制：这个字段定义了6中不同的控制位或标志。这些位用在tcp的流量控制建立连接和终止，数据传输等方面。</li>
<li>窗口大小：这个字段定义的是发送tcp的窗口大小哦，以字节为单位。请注意这个字段是16位。也就是窗口的最大长度是65535字节。这个值是接收窗口，由接收方决定。</li>
<li>检验和：这个16位字段包含的是检验和。udp是否使用检验和是可选的。而tcp使用检验和则是强制的。</li>
<li>紧急指针：只有当紧急标志位置位的时候，这个字段才生效。此时报文段包含了而紧急数据。</li>
<li>选项：tcp首部中可以有多大40字节的可选信息。</li>
</ul>
<p>封装：</p>
<p>tcp报文段从应用层接收到数据。他本身北风撞到ip数据报中。</p>
<p> <img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\7.jpg" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在更详细的讨论tcp之前 我们先来看看tcp的组成。&lt;/p&gt;
&lt;h3 id=&quot;报文段&quot;&gt;&lt;a href=&quot;#报文段&quot; class=&quot;headerlink&quot; title=&quot;报文段&quot;&gt;&lt;/a&gt;报文段&lt;/h3&gt;&lt;p&gt;报文段包括了20~60字节的首部和数据。首部在没有选项的时候是2
    
    </summary>
    
      <category term="tcp-ip协议族" scheme="http://yoursite.com/categories/tcp-ip%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="tcpip" scheme="http://yoursite.com/tags/tcpip/"/>
    
  </entry>
  
  <entry>
    <title>tcp4之流量控制差错控制和拥塞控制</title>
    <link href="http://yoursite.com/2017/03/17/tcp4%E4%B9%8B%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%8F%92%E5%BA%A7%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2017/03/17/tcp4之流量控制插座控制和拥塞控制/</id>
    <published>2017-03-17T12:52:12.000Z</published>
    <updated>2017-03-17T07:38:40.700Z</updated>
    
    <content type="html"><![CDATA[<p>在讨论流量 差错 阻塞之前。我们要先描述一下窗口。tcp为每个方向的数据传输各使用两个窗口。</p>
<h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><h4 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h4><p>发送窗口大小由接收方以及底层网络拥塞成都决定。图中描绘了打开 关闭 收缩。</p>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\9.jpg" alt="image"></p>
<p>注意事项：</p>
<ol>
<li>tcp中为字节编号。控制窗口的变量单位是以字节为单位的。</li>
<li>tcp只是用一个计数器。</li>
</ol>
<h4 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h4><p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\10.jpg" alt="image"></p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>平衡了生产者消费者之间的速度。</p>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\11.jpg" alt="image"></p>
<p>图中描述的数据走向是从发送进程乡下到达发送tcp，再从发送tcp到接受tcp，然后从接受不tcp向上到达接受进程。不过，流量控制的反馈走向是从接受tcp到发送tcp，以及从发送tcp向上到发送进程的。tcp的绝大多数实现都不提供从接受进程到接受tcp的流量控制反馈，而是让接受进程在准备就绪时去接受tcp哪里拉取数据。换言之，接受tcp控制了发送tcp。</p>
<p>为了实现流量控制，tcp强制发送方和接收方不断调整他们的窗口大小。</p>
<p>一个例子：<br><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\12.jpg" alt="image"></p>
<p>窗口关闭：<br>使发送窗口的右臂想做移动收缩是不希望的，但是有一个例外。接收端可以发送rwnd为0的报文来暂时关闭窗口。这种情况是由于接受方因某种原因在一段时间内不愿意从接受方接受任何数据。此时，发送方实际上并非真正的把窗口大小缩小了，只是暂定发送。直到收到一个新的通告为止。</p>
<p>糊涂窗口综合征：<br>加入tcp发送报文只包含一个字节的数据。那么意味着额外开销为41/1 （20个tcp首部 20个ip首部）。低效的。那么为了防指 就要强波发送tcp等待。怎么确定等待时间呢？</p>
<p>nagle算法：<br>1.发送tcp把他的第一个数据块发送出去，哪怕只有一个字节。<br>2.发送了第一个报文段后，发送tcp就能在输出缓存中积累数据等待，知道收到了tcp发来的确认。或者累计了足够多的 数据可以装成最大长度的报文段，这时，发送tcp就可以发送这个报文段了。<br>3.对省辖的传输，不断地重复步骤2.</p>
<h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>tcp使用差错控制来提供可靠性。差错控制包含以下的一些机制：检测和重传收到损伤的报文段，重传丢失的报文段，保存失序到达的报文段直至缺失的报文段到期，以及检测和丢弃重复的报文段。</p>
<p>tcp使用：检验和、确认、超时三个工具。</p>
<ol>
<li>每个报文段都有一个检验和字段。损伤就丢弃，病人伪是丢失了。</li>
<li>确认</li>
<li>重传</li>
<li>失序的报文段</li>
</ol>
<p>发送方tcp为每一条连接设置一个重传超时计数器。当计数器时间到，tcp发送队列中最前面的报文段，并重启计数器、</p>
<p>如果允许发送方更快的重传，而不用等待计时器超时，就能更有利于网络吞吐量。因此现在大多数实现都遵循收到三个重复ack就立刻重传丢失的报文段的规则。这一特性称为快重传。</p>
<p>失序的报文段</p>
<p>现在的tcp实现都不会丢弃失序到达的报文段，而是把这些报文段暂时保存下来，并把他们标记为失序报文段，直至缺失的报文段到期。</p>
<p>tcp数据传送的fsm</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>发送方有两个信息：接收方通告的窗口大小和拥塞窗口大小。窗口的真正大小去两者之中较小的一个。</p>
<p>tcp处理yongse一般策略是基于三个阶段：慢开始，拥塞避免，拥塞检测。</p>
<ul>
<li>慢开始： cwnd从1个报文段开始，每次ack回来，便想加，是一个指数级增大的。当窗口大小到达ssthresh（慢开始门限），该阶段就结束了，并进入下一个阶段。</li>
<li>拥塞避免：加法增大 当到达慢开始门限时，加法增加阶段就开始了。每当一争个“窗口”中的报文段都被确认后，拥塞窗口大小就增加1.</li>
<li>拥塞检查：乘法减小：如果拥塞发生，窗口大写哦就必须减少。<ol>
<li>如果计时器超时，出现拥塞可能性很大，某个报文段可能在网络中某处被抛弃了，后续报文段也没有消息。<br>a. 把门限值设置为当前窗口大小的一半<br>b. 把cwnd重新设置为一个报文段。<br>c. 再次从慢开始阶段开始。</li>
<li>如果是收到三个ack，那么出现拥塞可能性较小。某段可能被丢弃，但之后的几个安全到达，因为收到了三个重复ack，称之为快重传和快恢复。在这种情况下。tcp有以下反应<br>a. 把门限值设置为当前窗口值得一半<br>b. 把cwnd设置为门限值<br>c. 启动拥塞避免阶段。</li>
</ol>
</li>
</ul>
<p>小结：<br>给出一个例子。假设最大窗口大小的初始值是32个报文段。门限的初始值设置为16.在慢开始阶段，窗口从1开始增大，直到达到门限值。拥塞避免按照加法增大，当窗口发生超时现象，乘法减小过程开始生效，吧门限值减小到窗口大小的一半。</p>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\13.jpg" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在讨论流量 差错 阻塞之前。我们要先描述一下窗口。tcp为每个方向的数据传输各使用两个窗口。&lt;/p&gt;
&lt;h3 id=&quot;窗口&quot;&gt;&lt;a href=&quot;#窗口&quot; class=&quot;headerlink&quot; title=&quot;窗口&quot;&gt;&lt;/a&gt;窗口&lt;/h3&gt;&lt;h4 id=&quot;发送窗口&quot;&gt;&lt;a hr
    
    </summary>
    
      <category term="tcp-ip协议族" scheme="http://yoursite.com/categories/tcp-ip%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="tcpip" scheme="http://yoursite.com/tags/tcpip/"/>
    
  </entry>
  
  <entry>
    <title>mysql7之高级特性</title>
    <link href="http://yoursite.com/2017/03/15/mysql7%E4%B9%8B%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2017/03/15/mysql7之高级特性/</id>
    <published>2017-03-15T12:52:12.000Z</published>
    <updated>2017-03-15T11:51:49.141Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-分区表"><a href="#1-分区表" class="headerlink" title="1.分区表"></a>1.分区表</h3><p>对用户来说，分区表示一个独立的逻辑表，但是底层由多个物理子表组成。</p>
<p>实现分区的代码实际上是对一组底层表的句柄对象的封装。对分区表的请求，都会通过句柄对象转换成对存储引擎的接口调用。</p>
<p>MYSQL 实现分区表的方式-》 对底层表的封装 -》意味着索引也是按照分区的子表定义，而没有全局索引。</p>
<p>mysql实现分区表的方式–对地层表的封装–意味着索引也是按照分区的字表定义的。</p>
<p>分区的一个主要目的是 将数据按照一个较粗的粒度分在不同的表中。</p>
<p>分区表的索引只是在各个底层表各自加上一个完全相同的索引。之于存储引擎，分区表的底层表与普通表没有区别。</p>
<p>分区表的原理：</p>
<p>select :当查询一个分区表的时候，分区表先打开并锁住所有的底层表，优化器线盘短是否可以过滤部分分区，然后在调用对应的存储引擎接口访问各个分区的数据。</p>
<p>insert：当写入一条记录时，分区层先打开并锁住所有的底层表，然后确定哪个分区接受这条记录。再将记录写入到对应底层表中。</p>
<p>delete和update同上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">CREATE TABLE <span class="title">sales</span> <span class="params">(</span></span></div><div class="line">　　order_date DATETIME NOT NULL,</div><div class="line">　　-- Other columns omitted</div><div class="line">) ENGINE=<span class="function">InnoDB PARTITION BY <span class="title">RANGE</span><span class="params">(YEAR(order_date)</span>) <span class="params">(</span></span></div><div class="line">PARTITION p_2010 VALUES LESS THAN (<span class="number">2010</span>),</div><div class="line">PARTITION p_2011 VALUES LESS <span class="title">THAN</span> <span class="params">(<span class="number">2011</span>)</span>,</div><div class="line">PARTITION p_2012 VALUES LESS <span class="title">THAN</span> <span class="params">(<span class="number">2012</span>)</span>,</div><div class="line">PARTITION p_catchall VALUES LESS THAN MAXVALUE );</div></pre></td></tr></table></figure>
<h3 id="2-视图"><a href="#2-视图" class="headerlink" title="2.视图"></a>2.视图</h3><p>视图：</p>
<ul>
<li>视图本身是一个虚拟表，不存放任何数据。</li>
<li>在使用sql语句访问视图的时候，它返回的数据是Mysql从其他表生成的。</li>
<li>视图和表在同一个命名空间，MySQL在很多地方低于视图和表是同样对待的。</li>
<li>不过视图和表也有不同，例如，不能对视图创建触发器，也不呢过使用drop table 命令删除视图</li>
</ul>
<p>实现算法：</p>
<p>merge: 合并算法，尽可能使用这个</p>
<p>Temptable：临时表算法。如果视图中高寒GROUP BU, DISTINCT, 任何聚合函数, UNION, 子查询等<br>　　只要无法在原表记录和视图记录建立一一映射的场景中，mysql都将用临时表算法实现视图。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">view</span> oceania <span class="keyword">as</span> </div><div class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> country <span class="keyword">where</span> continent=<span class="string">'oceania'</span></div><div class="line">    <span class="keyword">with</span> <span class="keyword">check</span> opition;</div><div class="line"><span class="keyword">select</span> code,<span class="keyword">name</span> <span class="keyword">from</span> oceania <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'australia'</span>;</div><div class="line"></div><div class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span> tmp_oca <span class="keyword">as</span> </div><div class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> country <span class="keyword">where</span> cotinent=<span class="string">'sss'</span>;</div></pre></td></tr></table></figure>
<h3 id="3-外键约束"><a href="#3-外键约束" class="headerlink" title="3.外键约束"></a>3.外键约束</h3><h3 id="4-在mysql内部存储代码"><a href="#4-在mysql内部存储代码" class="headerlink" title="4.在mysql内部存储代码"></a>4.在mysql内部存储代码</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-分区表&quot;&gt;&lt;a href=&quot;#1-分区表&quot; class=&quot;headerlink&quot; title=&quot;1.分区表&quot;&gt;&lt;/a&gt;1.分区表&lt;/h3&gt;&lt;p&gt;对用户来说，分区表示一个独立的逻辑表，但是底层由多个物理子表组成。&lt;/p&gt;
&lt;p&gt;实现分区的代码实际上是对一组底层表
    
    </summary>
    
      <category term="高性能mysql" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
    
      <category term="高性能mysql" scheme="http://yoursite.com/tags/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL2之schema设计优化</title>
    <link href="http://yoursite.com/2017/03/15/MySQL2%E4%B9%8Bschema%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/03/15/MySQL2之schema设计优化/</id>
    <published>2017-03-15T12:52:12.000Z</published>
    <updated>2017-03-15T11:45:24.980Z</updated>
    
    <content type="html"><![CDATA[<p>良好的逻辑设计和物理设计是高性能的基石，应该根据系统要执行的查询语句来设计 schema。这往往需要权衡各种因素。</p>
<p>例如：反范式的设计可以加快某些类型的查询，但同时可能使另一些类型的查询变慢。比如添加计数表和汇总表是一种很好的优化查询的方式，</p>
<p>但是这些表的维护成本会很高。MySQL独有的特性和实现细节对性能影响也很大。</p>
<p>选择优化的数据类型的简单原则：</p>
<p>　　1.更小的通常更好</p>
<p>　　　　一般情况下，应该尽量使用可以正确存储数据的最小数据类型。</p>
<p>　　2.简单就好</p>
<p>　　　　简单数据类型的操作通常需要更少的cpu周期。</p>
<p>　　3.尽量避免NULL</p>
<p>　　　　如果查询包含可为NULL的列，对mysql来说更难优化，因为可为NULL的列使得索引，索引统计，值比较都更复杂。</p>
<p>　　　　可为NULL的列会使用更多的存储空间，在MySQL里也需要特殊处理。</p>
<p>schema设计的第一步，那就是建表，建表的第一步呢就是设计字段，然而了解mysql的数据类型又对设计字段有莫大的帮助。</p>
<p>那我们先来了解mysql的基本数据类型吧。</p>
<p>1.整数类型</p>
<p>　　TINYINT, SMALLINT,MEDIUMINT,INT,BIGINT</p>
<p>　　8，16，24，32，64，位存储空间。</p>
<p>　　MySQL可为整数类型制定宽度，例如INT（11），但对大多数应用这是没意义的；它不会限制值合法范围。对于存储和计算来说</p>
<p>　　INT(1) 和 INT(20)是相同的</p>
<p>2.实数类型</p>
<p>　　FLOAT,DOUBLE,DECIMAL(精确计算用的)</p>
<p>3.字符串类型</p>
<p>　　VARCHARE</p>
<p>　　　　最常见的字符串类型。它比定长类型更节省空间，因为它仅适用必要的空间。有一种情况例外，如果MySQL表使用ROW_FORMAT=FIXED创建的话。</p>
<p>　　　　VARCHAR需要适用1或2个额外字节记录字符串的长度。如果列的最大长度小于等于255，则使用一个字节记录长度。</p>
<p>　　CHAR</p>
<p> 　　　　是定长的。MySQL总是根据定义的字符串分配足够的空间。当存储CHAR值时，MySQL会删除所有的末尾空格。</p>
<p>　　　　CHAR值会根据需要采用空格填充以方便比较。</p>
<p>　　　　CHAR适合存储很短的字符串。对于经常变更的数据，CHAR也比VARCHAR更好，因为定长CHAR类型不容易产生碎片。</p>
<p>　　BLOB和TEXT</p>
<p>　　　　BLOB和TEXT都是为存储很大数据而设计的字符串数据类型，分别采用二进制和字符方式存储。</p>
<p>　　使用枚举（ENUM）代替字符串类型</p>
<p>4.日期和时间类型</p>
<p>　　DATETIME</p>
<p>　　　　这个类型能保存大范围的值。从1001年到9999年，精度为妙。</p>
<p>　　TIMESTAMP</p>
<p> 　　　　存储空间小，并且会根据时区变化，有特殊的自动更新能力。精度为妙。</p>
<p>　　如果要存储比秒更小粒度的时间时，可以用bigint类型存储微秒级别的时间戳。</p>
<p>5.位数据类型</p>
<p>　　BIT</p>
<p>标识符的选择：</p>
<p>　　整数类型</p>
<p>　　　　整数通常是标识列的最好选择。因为他们很快，并且可以使用auto_increment</p>
<p>　　enum 和 set 类型</p>
<p>　　</p>
<p>　　字符串类型</p>
<p>　　　　如果可能，尽量避免使用字符串类型作为标识符，因为它们很消耗空间，并且通常比数字类型慢。</p>
<p>　　　　尤其在MyISAM表里使用字符串作为标识列时要特别小心。MyISAM默认对字符串使用压缩索引，这会使查询很慢。</p>
<p>　　　　对于完全’随机’的字符串也需要多加注意，例如md5(),sha1(),uuid()产生的字符串。</p>
<p>　　　　这些函数生成的新值会任意分布在很大的空间内，这会导致insert以及一些select语句变得很慢：</p>
<p>　　　　　　1.因为插入值会随机写到索引的不同位置，所以使得insert语句更慢。这会导致页分裂，磁盘随机访问，以及对于聚簇存储引擎产生聚簇索引碎片。</p>
<p>　　　　　　2.select语句会变得更慢，因为逻辑上相邻的行为分布在磁盘和内存的不同地方。</p>
<p>　　　　　　3.随机值会导致缓存对所有类型的查询语句效果都很差。</p>
<p>schema设计中的陷阱</p>
<p>　　1.太多的列</p>
<p>　　2.太多的关联</p>
<p>　　3.全能的枚举</p>
<p>　　</p>
<p>范式和反范式</p>
<p>　　三大范式：　　</p>
<p>　　　　1.必须有主键，列不可分　　</p>
<p>　　　　2.当一个表是复合主键时，非主键的字段不依赖于部分主键(即必须依赖于全部的主键字段)</p>
<p>　　　　3.关系模式R（U，F）中的所有非主属性对任何候选关键字都不存在传递依赖</p>
<p>　　反范式，顾名思义，不遵守三大范式。</p>
<p>　　首先我们来看看范式的优缺点：</p>
<p>　　优点：</p>
<p>　　　　范式化的更新操作通常比反范式快。</p>
<p>　　　　当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据</p>
<p>　　　　范式化的表通常很小，可以更好的放在内存里，所以执行操作会更快。</p>
<p>　　　　很少有多余的数据意味着检索列表数据更少需要DISTINCT或者GROUP BY语句。</p>
<p>　　缺点：</p>
<p>　　　　过度依赖关联。这不但代价昂贵，也可能使一些索引策略无效。</p>
<p>　　反范式优缺点：</p>
<p>　　　　因为所有的数据在一张表中，可以很好的避免关联。</p>
<p>　　　　如果不需要关联，则对大部分查询最差的情况，即使没有使用索引，是全表扫描，当数据比内存大时这可能比关联要快得多，</p>
<p>　　　　因为这样避免了随机I/O。</p>
<p>　　　　单独的表能更好的使用索引策略。</p>
<p>　混用范式和反范式才是schema设计的主流。</p>
<p>缓存表和汇总表</p>
<p>　　方便查询，不易维护。</p>
<p>物化视图</p>
<p>　　</p>
<p>计数器表</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;良好的逻辑设计和物理设计是高性能的基石，应该根据系统要执行的查询语句来设计 schema。这往往需要权衡各种因素。&lt;/p&gt;
&lt;p&gt;例如：反范式的设计可以加快某些类型的查询，但同时可能使另一些类型的查询变慢。比如添加计数表和汇总表是一种很好的优化查询的方式，&lt;/p&gt;
&lt;p&gt;但
    
    </summary>
    
      <category term="高性能mysql" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
    
      <category term="高性能mysql" scheme="http://yoursite.com/tags/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql6之查询性能优化</title>
    <link href="http://yoursite.com/2017/03/15/mysql6%E4%B9%8B%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/03/15/mysql6之查询性能优化/</id>
    <published>2017-03-15T12:52:12.000Z</published>
    <updated>2017-03-15T11:46:20.722Z</updated>
    
    <content type="html"><![CDATA[<p>前一章节讲解了如何设计库表结构及建索引。只有这些并不够。<br>本章主要介绍合理的查询设计。</p>
<h4 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h4><ol>
<li>是否向数据库请求了不需要的数据</li>
</ol>
<ul>
<li>查询不需要的记录（需要20条，查询了100）</li>
<li>多表关联时反悔了全部列 </li>
<li>总是去除所有列（select *）</li>
<li>重复查询相同的数据</li>
</ul>
<ol>
<li>在确定了查询只返回需要的数据以后，接下来看查询是否扫描了过多的数据、</li>
</ol>
<p>最简单的衡量查询的三个指标：</p>
<ul>
<li>响应时间（服务时间+排队时间）</li>
<li>扫描的行数</li>
<li>返回的行数</li>
</ul>
<h4 id="重构查询的方法"><a href="#重构查询的方法" class="headerlink" title="重构查询的方法"></a>重构查询的方法</h4><ol>
<li>一个复杂查询还是多个简单查询</li>
<li>切分查询</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">delete</span> <span class="keyword">from</span> messages <span class="keyword">where</span> created&lt; <span class="keyword">date_sub</span>(<span class="keyword">now</span>(),<span class="built_in">interval</span> <span class="number">3</span> <span class="keyword">month</span>);</div><div class="line"></div><div class="line">rows_affected=</div><div class="line"><span class="keyword">do</span>&#123;</div><div class="line">    rows_affected=do_query(</div><div class="line">    <span class="string">"delete from messages where &lt; date_sub(now(),interval 3 month) limit 10000</span></div><div class="line">    ")</div><div class="line">&#125; <span class="keyword">while</span> rows_affected&gt;<span class="number">0</span></div></pre></td></tr></table></figure>
<ol>
<li>分解关联查询</li>
</ol>
<ul>
<li>让缓存的效率更高</li>
<li>将查询分解后，执行单个查询可以减少锁的竞争</li>
<li>查询本身小老板也可能hi有所提升</li>
<li>可以减少荣誉记录。咋应用层做关联查询</li>
</ul>
<h4 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h4><p>客户端—通信协议—服务器（sql—查询缓存—解析器—解析树—预处理器—解析树<br>—查询优化器—查询执行计划—查询执行引擎—api接口调用—存储引擎—数据<br>）</p>
<p>根据以上步骤 下面分别描述。</p>
<ol>
<li>mysql客户端和服务器通信协议。</li>
</ol>
<p>通信协议是半双工的。要么是服务器向客户端发送，要么是客户端向服务器发送。</p>
<p>查询状态：</p>
<ul>
<li>sleep</li>
<li>query</li>
<li>locked</li>
<li>analyzing and statics</li>
<li>copying to tmp table [on disk]:线程正在执行查询，并且将结果及复制到一个临时表，</li>
<li>sorting result 正在对结果集进行排序</li>
<li>sending data</li>
</ul>
<ol>
<li>查询缓存</li>
</ol>
<p>如果查询缓存是打开的，mysql会优先检查这个查询是否命中查询缓存中的数据，这个检查是通过一个队大小写敏感的哈希查找实现的。查询和缓存中的查询及时只有一个字节不同，那也不会匹配缓存结果。进入下一阶段。</p>
<p>如果刚好命中查询缓存，会进行一次用户权限检查。没问题 返回。</p>
<ol>
<li>查询优化处理</li>
</ol>
<p>语法解析器和预处理：语法正确合法么？数据表数据列存在么？ 验证权限？</p>
<p>查询优化器：</p>
<p>一条查询可以有很多执行方法，都返回相同的结果，优化器的作用找出最好的执行计划。<br>基于成本的优化器、<br>优化策略：静态优化和动态优化。静态优化对解析树直接进行分析，完成优化。通过简单的代数变换将where换成另一等价形式。</p>
<p>能够处理的一些优化类型：</p>
<ul>
<li>重新定义关联表的顺序</li>
<li>将外链接变成内连接</li>
<li>利用等价变换原则</li>
<li><p>优化count min max等</p>
<p>  举例说明：如果查找一列的最小值，只要查询对应btree索引最左端的记录，mysql可以直接获取索引的第一行记录。在优化器生成执行计划的时候，就可以利用这一点。在btree索引中，优化器会将这个表达式当做一个常数暗袋。 最大值同上。<br>  “select tables optimized away”</p>
</li>
<li>预估并转化为常数表达式</li>
<li>覆盖索引扫描</li>
<li>子查询优化</li>
<li>提前终止查询</li>
<li>等值传播： 如果两个列通过登时关联，那么mysql能够把其中一个列的where条件传递到另一列上。</li>
</ul>
<p>执行计划</p>
<p>关联优化器 </p>
<p>排序优化</p>
<ol>
<li><p>查询执行引擎</p>
</li>
<li><p>返回结果给客户端</p>
</li>
</ol>
<p>mysql将结果集返回客户duan是一个增量逐步返回的结果。<br>结果集中的每一行都会以一个满足mysql客户端服务器通信协议的封包发送，再通过tcp协议进行传输。在tcp传输过程中，可能对mysql封包进行缓存然后批量传输。</p>
<h4 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h4><ul>
<li>count</li>
<li>关联查询 a和b用c列关联，优化顺序是ba，只需要在a上建索引就好，没用到的索引只会是负担。</li>
<li>优化子查询 尽量用关联插叙代替</li>
<li>优化group by 和distinct</li>
<li>优化limit： 使用索引覆盖扫描，延迟加载</li>
<li>优化sql_calc_found_rows</li>
<li>union</li>
<li>使用用户自定义变量</li>
</ul>
<h3 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h3><ol>
<li>使用mysql构建一个队列表。</li>
<li>计算两点之间的距离</li>
<li>使用用户自定义函数</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一章节讲解了如何设计库表结构及建索引。只有这些并不够。&lt;br&gt;本章主要介绍合理的查询设计。&lt;/p&gt;
&lt;h4 id=&quot;慢查询基础：优化数据访问&quot;&gt;&lt;a href=&quot;#慢查询基础：优化数据访问&quot; class=&quot;headerlink&quot; title=&quot;慢查询基础：优化数据访问&quot;&gt;
    
    </summary>
    
      <category term="高性能mysql" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
    
      <category term="高性能mysql" scheme="http://yoursite.com/tags/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
  </entry>
  
</feed>
