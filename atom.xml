<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lyp&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-11-02T17:35:34.386Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Loren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring_AOP源码分析</title>
    <link href="http://yoursite.com/2016/11/03/Spring-AOP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/11/03/Spring-AOP源码分析/</id>
    <published>2016-11-02T17:15:11.000Z</published>
    <updated>2016-11-02T17:35:34.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-AOP-源码分析"><a href="#Spring-AOP-源码分析" class="headerlink" title="Spring AOP 源码分析"></a>Spring AOP 源码分析</h1><h2 id="零-Spring-aop的使用"><a href="#零-Spring-aop的使用" class="headerlink" title="零.Spring aop的使用"></a>零.Spring aop的使用</h2><p>想要分析aop源码。总要先知道spring aop怎么使用吧。要不然，分析个orz…</p>
<p>使用Spring AOP可以基于两种方式，一种是比较方便和强大的注解方式，另一种则是中规中矩的xml配置方式。</p>
<h3 id="0-1-基于注解的使用"><a href="#0-1-基于注解的使用" class="headerlink" title="0.1 基于注解的使用"></a>0.1 基于注解的使用</h3><p>第一步xml配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</div><div class="line">	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</div><div class="line">	xmlns:context="http://www.springframework.org/schema/context"</div><div class="line">	xmlns:aop="http://www.springframework.org/schema/aop"</div><div class="line">	xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd</div><div class="line">		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;</div><div class="line"></div><div class="line">	&lt;!-- 激活组件扫描功能,在包cn.ysh.studio.spring.aop及其子包下面自动扫描通过注解配置的组件 --&gt;</div><div class="line">	&lt;context:component-scan base-package="cn.ysh.studio.spring.aop"/&gt;</div><div class="line">	&lt;!-- 激活自动代理功能 --&gt;</div><div class="line">	&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;</div><div class="line">	</div><div class="line">	&lt;!-- 用户服务对象 --&gt;</div><div class="line">	&lt;bean id="userService" class="cn.ysh.studio.spring.aop.service.UserService" /&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>第二步是为Aspect切面类添加注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="comment">//声明这是一个切面Bean</span></div><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAspect</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Log log = LogFactory.getLog(ServiceAspect.class);</div><div class="line">	</div><div class="line">	<span class="comment">//配置切入点,该方法无方法体,主要为方便同类中其他方法使用此处配置的切入点</span></div><div class="line">	<span class="meta">@Pointcut</span>(<span class="string">"execution(* cn.ysh.studio.spring.aop.service..*(..))"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspect</span><span class="params">()</span></span>&#123;	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 配置前置通知,使用在方法aspect()上注册的切入点</div><div class="line">	 * 同时接受JoinPoint切入点对象,可以没有该参数</div><div class="line">	 */</div><div class="line">	<span class="meta">@Before</span>(<span class="string">"aspect()"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(log.isInfoEnabled())&#123;</div><div class="line">			log.info(<span class="string">"before "</span> + joinPoint);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//配置后置通知,使用在方法aspect()上注册的切入点</span></div><div class="line">	<span class="meta">@After</span>(<span class="string">"aspect()"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(log.isInfoEnabled())&#123;</div><div class="line">			log.info(<span class="string">"after "</span> + joinPoint);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//配置环绕通知,使用在方法aspect()上注册的切入点</span></div><div class="line">	<span class="meta">@Around</span>(<span class="string">"aspect()"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</div><div class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			((ProceedingJoinPoint) joinPoint).proceed();</div><div class="line">			<span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">			<span class="keyword">if</span>(log.isInfoEnabled())&#123;</div><div class="line">				log.info(<span class="string">"around "</span> + joinPoint + <span class="string">"\tUse time : "</span> + (end - start) + <span class="string">" ms!"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">			<span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">			<span class="keyword">if</span>(log.isInfoEnabled())&#123;</div><div class="line">				log.info(<span class="string">"around "</span> + joinPoint + <span class="string">"\tUse time : "</span> + (end - start) + <span class="string">" ms with exception : "</span> + e.getMessage());</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//配置后置返回通知,使用在方法aspect()上注册的切入点</span></div><div class="line">	<span class="meta">@AfterReturning</span>(<span class="string">"aspect()"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturn</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(log.isInfoEnabled())&#123;</div><div class="line">			log.info(<span class="string">"afterReturn "</span> + joinPoint);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//配置抛出异常后通知,使用在方法aspect()上注册的切入点</span></div><div class="line">	<span class="meta">@AfterThrowing</span>(pointcut=<span class="string">"aspect()"</span>, throwing=<span class="string">"ex"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrow</span><span class="params">(JoinPoint joinPoint, Exception ex)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(log.isInfoEnabled())&#123;</div><div class="line">			log.info(<span class="string">"afterThrow "</span> + joinPoint + <span class="string">"\t"</span> + ex.getMessage());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第三步测试：</p>
<pre><code>public class Tester {

    private final static Log log = LogFactory.getLog(Tester.class);

    public static void main(String[] args) {
        //启动Spring容器
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        //获取service组件
        UserService service = (UserService) context.getBean(&quot;userService&quot;);
        //以普通的方式调用UserService对象的三个方法
        User user = service.get(1L);
        service.save(user);
        try {
            service.delete(1L);
        } catch (Exception e) {
            if(log.isWarnEnabled()){
                log.warn(&quot;Delete user : &quot; + e.getMessage());
            }
        }
    }
}
</code></pre><h3 id="0-2-xml配置"><a href="#0-2-xml配置" class="headerlink" title="0.2 xml配置"></a>0.2 xml配置</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;


    &lt;!-- 系统服务组件的切面Bean --&gt;
    &lt;bean id=&quot;serviceAspect&quot; class=&quot;cn.ysh.studio.spring.aop.aspect.ServiceAspect&quot;/&gt;
    &lt;!-- AOP配置 --&gt;
    &lt;aop:config&gt;
        &lt;!-- 声明一个切面,并注入切面Bean,相当于@Aspect --&gt;
        &lt;aop:aspect id=&quot;simpleAspect&quot; ref=&quot;serviceAspect&quot;&gt;
            &lt;!-- 配置一个切入点,相当于@Pointcut --&gt;
            &lt;aop:pointcut expression=&quot;execution(* cn.ysh.studio.spring.aop.service..*(..))&quot; id=&quot;simplePointcut&quot;/&gt;
            &lt;!-- 配置通知,相当于@Before、@After、@AfterReturn、@Around、@AfterThrowing --&gt;
            &lt;aop:before pointcut-ref=&quot;simplePointcut&quot; method=&quot;before&quot;/&gt;
            &lt;aop:after pointcut-ref=&quot;simplePointcut&quot; method=&quot;after&quot;/&gt;
            &lt;aop:after-returning pointcut-ref=&quot;simplePointcut&quot; method=&quot;afterReturn&quot;/&gt;
            &lt;aop:after-throwing pointcut-ref=&quot;simplePointcut&quot; method=&quot;afterThrow&quot; throwing=&quot;ex&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre><p>AOP用起来还是很简单的。就把xml配置好就算完工了。有Advisor和aspect两种方式来完成。如果是用Advisor的话需要实现AfterReturningAdvice，MethodBeforeAdvice，ThrowsAdvice等接口。而如果用aspect的话则不用继承或者实现其他的类，一个普通的类即可。</p>
<h2 id="一．AOP介绍"><a href="#一．AOP介绍" class="headerlink" title="一．AOP介绍"></a>一．AOP介绍</h2><p>软件开发经历了从汇编语言到高级语言和从过程化编程到面向对象编程；前者是为了提高开发效率，而后者则使用了归纳法，把具有共性的东西进行归类并使之模块化，达到便于维护和扩展的目的；如果说面向对象编程可以对业务需求进行很好的分解使之模块化；那么面向切面编程AOP（Aspect-Oriented Programming）则可以对系统需求进行很好的模软件开发经历了从汇编语言到高级语言和从过程化编程到面向对象编程；前者是为了提高开发效率，而后者则使用了归纳法，把具有共性的东西进行归类并使之模块化，达到便于维护和扩展的目的；如果说面向对象编程可以对业务需求进行很好的分解使之模块化；那么面向切面编程AOP（Aspect-Oriented Programming）则可以对系统需求进行很好的模块组织，简化系统需求和实现之间的对比关系，是对OOP思想的一种补充；块组织，简化系统需求和实现之间的对比关系，是对OOP思想的一种补充。</p>
<p>举个例子来说明一下吧！现在系统中有很多的业务方法，如上传产品信息、修改产品信息、发布公司库等；现在需要对这些方法的执行做性能监控，看每个业务方法的执行时间；在不改变原业务代码的基础上，也许我们会这么做。</p>
<p>Offer接口：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public interface IOffer {
    public void postOffer();
    public void modifyOffer();
}
</code></pre><p>Offer实现：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public class OfferImpl implements IOffer {
    public void postOffer() {
        System.out.println(&quot;post offer&quot;);
    }

    public void modifyOffer() {
        System.out.println(&quot;modify offer&quot;);
    }
}
</code></pre><p>工具类：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public class PerformanceUtil {
    public static long start=0;
    public static long end=0;
    public static void startPerformance(){
        start=System.currentTimeMillis();
    }
    public static void endPerformance(){
        end=System.currentTimeMillis();
        System.out.println(&quot;method use:&quot;+(end-start));
    }
}
</code></pre><p>Offer代理：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public class OfferProxy implements IOffer {

    private IOffer delegate;

    public OfferProxy(IOffer delegate){
        this.delegate=delegate;
    }
    public void postOffer() {
        PerformanceUtil.startPerformance();
        delegate.postOffer();
        PerformanceUtil.endPerformance();
    }

    public void modifyOffer() {
        PerformanceUtil.startPerformance();
        delegate.modifyOffer();
        PerformanceUtil.endPerformance();
    }

}
</code></pre><p>Offer测试：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public class TestProxy {
    public static void main(String[] args) {
        IOffer offer= new OfferProxy(new OfferImpl());
        offer.postOffer();
        offer.modifyOffer();
    }
}
</code></pre><p>输出：</p>
<pre><code>post offer
method use:1
modify offer
method use:0
</code></pre><p>上面的例子中，OfferProxy实现了IOffer，而所有的业务实现均委托给其成员offer；可以想像，这应该就是最简单的AOP的实现了；但这种方式会存在一个问题：如果有非常多的这种业务对象需要性能监控，我们就需要写同样多的XyzProxy来满足需求，这也是非常巨大的工作量。</p>
<h2 id="二．-代理模式"><a href="#二．-代理模式" class="headerlink" title="二．    代理模式"></a>二．    代理模式</h2><p>代理模式中，存在一个称为ProxyObject的代理对象和RealObject的真实对象，它们都实现了相同的接口；在调用的地方持有ProxyObject的实例，当调用request()方法时，ProxyObject可以在执行RealObject.request()前后做一些特定的业务，甚至不调用RealObject.request()方法。</p>
<p>目前实现代理模式的方式有两种：基于JDK的动态代理和基于CGLIB字节码的代理。</p>
<h3 id="2-1-JDK动态代理"><a href="#2-1-JDK动态代理" class="headerlink" title="2.1 JDK动态代理"></a>2.1 JDK动态代理</h3><p>JDK动态代理，顾名思义，是基于JDK的反射(reflect)机制；在JDK中，提供了InvocationHandler这个接口。</p>
<p>注释如下：</p>
<pre><code>InvocationHandler is the interface implemented by the invocation handler of a proxy instance.
Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.
</code></pre><p>意思是说：该接口由被代理对象的handler所实现；当调用代理对象的方法时，该方法调用将被编码，然后交给代理对象的invoke方法去执行。<br>因此上面的代码可以改写成如下所示：</p>
<p>实现：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyFactory implements InvocationHandler {
    private Object delegate;

    public Object bind(Object delegate){
        this.delegate= delegate;
        return Proxy.newProxyInstance(delegate.getClass().getClassLoader(), 
                delegate.getClass().getInterfaces(), this);
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        PerformanceUtil.startPerformance();
        Object result=null;
        try {
            result=method.invoke(delegate, args);
        } catch (Exception e) {
            // TODO: handle exceptions
        }
        PerformanceUtil.endPerformance();
        return result;
    }

}
</code></pre><p>测试：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public class TestJDKProxy {
    public static void main(String[] args) {
        IOffer offer = (IOffer) new ProxyFactory().bind(new OfferImpl());
        offer.postOffer();
        offer.modifyOffer();
    }
}
</code></pre><p>结果：</p>
<pre><code>post offer
method use:1
modify offer
method use:0
</code></pre><p>通过这种方式，你不需要为针对每一个业务写一个代理对象，就可以很轻松地完成你的需求；但也许你已经注意到了，JDK的动态代理，在创建代理对象(上面红色代码部分)时，被代理的对象需要实现接口(即面向接口编程)；</p>
<h3 id="2-2CGLIB代理方式"><a href="#2-2CGLIB代理方式" class="headerlink" title="2.2CGLIB代理方式"></a>2.2CGLIB代理方式</h3><p>如果目标对象没有实现任何接口，那怎么办呢？不用担心，你可以用CGLIB来实现代理。</p>
<p>实现：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

import java.lang.reflect.Method;

import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;


public class CglibProxyFactory  implements MethodInterceptor{

    private Object delegate;

    public Object bind(Object delegate){
        this.delegate=delegate;
        Enhancer enhancer= new Enhancer();
        enhancer.setSuperclass(delegate.getClass());
        enhancer.setCallback(this);
        return enhancer.create();
    }
    public Object intercept(Object object, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        PerformanceUtil.startPerformance();
        Object o =proxy.invoke(this.delegate, args);
        PerformanceUtil.endPerformance();
        return o;
    }

}
</code></pre><p>测试类：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public class TestCglibProxy {
    public static void main(String[] args) {
        DefaultOffer defaultOffer= (DefaultOffer) new CglibProxyFactory().bind(new DefaultOffer());
        defaultOffer.postOffer();
        defaultOffer.modifyOffer();
    }
}
</code></pre><p>测试结果：</p>
<pre><code>post offer
method use:20
modify offer
method use:0
</code></pre><p>使用CGLIB创建的代理对象，其实就是继承了要代理的目标类，然后对目标类中所有非final方法进行覆盖，但在覆盖方法时会添加一些拦截代码(上面CglibProxyFactory类中的intercept方法)。</p>
<h2 id="三．-Spring-AOP-实现"><a href="#三．-Spring-AOP-实现" class="headerlink" title="三．    Spring AOP 实现"></a>三．    Spring AOP 实现</h2><h3 id="3-1-Spring-AOP-几个基本概念"><a href="#3-1-Spring-AOP-几个基本概念" class="headerlink" title="3.1 Spring AOP 几个基本概念"></a>3.1 Spring AOP 几个基本概念</h3><p>Spring AOP jar包：<strong>spring-aop-4.2.5.release.jar</strong></p>
<p>Spring AOP中的几个基本概念，每次学习AOP都被这几个概念折腾的很不爽，我们在这里再把这几个概念描述一遍，力争把这几个概念搞清，在每次review这块内容的时候可以很快上手。</p>
<ol>
<li>切面(Aspect)：切面就是一个关注点的模块化，如事务管理、日志管理、权限管理等；</li>
<li>连接点(Joinpoint)：程序执行时的某个特定的点，在Spring中就是一个方法的执行；</li>
<li>通知(Advice)：通知就是在切面的某个连接点上执行的操作，也就是事务管理、日志管理等；</li>
<li>切入点(Pointcut)：切入点就是描述某一类选定的连接点，也就是指定某一类要织入通知的方法；</li>
<li>目标对象(Target)：就是被AOP动态代理的目标对象；</li>
</ol>
<p>用一张图来形象地表达AOP的概念及其关系如下：</p>
<p><img src="http://i.imgur.com/SoF1QtC.png" alt=""></p>
<h3 id="3-2-Spring-AOP-中切入点、通知、切面的实现"><a href="#3-2-Spring-AOP-中切入点、通知、切面的实现" class="headerlink" title="3.2 Spring AOP 中切入点、通知、切面的实现"></a>3.2 Spring AOP 中切入点、通知、切面的实现</h3><p>理解了上面的几个概念后，我们分别来看看Spring AOP是如何实现这些概念的；</p>
<h4 id="3-2-1-切入点-Pointcut"><a href="#3-2-1-切入点-Pointcut" class="headerlink" title="3.2.1.切入点(Pointcut)"></a>3.2.1.切入点(Pointcut)</h4><p>它定义了哪些连接点需要被织入横切逻辑；在Java中，连接点对应哪些类(接口)的方法。因此，我们都能猜到，所谓的切入点，就是定义了匹配哪些娄的哪些方法的一些规则，可以是静态的基于类(方法)名的值匹配，也可以是基于正则表达式的模式匹配。</p>
<p>来看看Spring AOP Pointcut相关的类图：</p>
<p><img src="http://i.imgur.com/0Fpm5dB.png" alt=""></p>
<p>在Pointcut接口的定义中，也许你已经想到了，ClassFilter是类过滤器，它定义了哪些类名需要拦截；典型的两个实现类为TypePatternClassFilter和TrueClassFilter(所有类均匹配)；而MethodMatcher为方法匹配器，定义哪些方法需要拦截。</p>
<p>在上面的类图中：</p>
<ul>
<li>StaticMethodMatch与DynamicMethodMatch的区别是后者在运行时会依据方法的参数值进行匹配。</li>
<li>NameMatchMethodPointCut根据指定的mappedNames来匹配方法。</li>
<li>AbstractRegexpMethodPointCut根据正则表达式来匹配方法</li>
</ul>
<p>类图中部分代码实现：</p>
<p>MethodMatcher.class:</p>
<pre><code>package org.springframework.aop;

import java.lang.reflect.Method;

public abstract interface MethodMatcher {
    public static final MethodMatcher TRUE = TrueMethodMatcher.INSTANCE;

    public abstract boolean matches(Method paramMethod, Class&lt;?&gt; paramClass);

    public abstract boolean isRuntime();

    public abstract boolean matches(Method paramMethod, Class&lt;?&gt; paramClass, Object[] paramArrayOfObject);
}
</code></pre><p>StaticMethodMatcher.class:</p>
<pre><code>package org.springframework.aop.support;

import java.lang.reflect.Method;
import org.springframework.aop.MethodMatcher;

public abstract class StaticMethodMatcher implements MethodMatcher {
    public final boolean isRuntime() {
        return false;
    }

    public final boolean matches(Method method, Class&lt;?&gt; targetClass, Object[] args) {
        throw new UnsupportedOperationException(&quot;Illegal MethodMatcher usage&quot;);
    }
}
</code></pre><p>DynamicMethodMatcher.class:</p>
<pre><code>package org.springframework.aop.support;

import java.lang.reflect.Method;
import org.springframework.aop.MethodMatcher;

public abstract class DynamicMethodMatcher implements MethodMatcher {
    public final boolean isRuntime() {
        return true;
    }

    public boolean matches(Method method, Class&lt;?&gt; targetClass) {
        return true;
    }
}
</code></pre><p>Pointcut.class:</p>
<pre><code>package org.springframework.aop;

public abstract interface Pointcut {
    public static final Pointcut TRUE = TruePointcut.INSTANCE;

    public abstract ClassFilter getClassFilter();

    public abstract MethodMatcher getMethodMatcher();
}
</code></pre><h4 id="3-2-2-通知-Advice"><a href="#3-2-2-通知-Advice" class="headerlink" title="3.2.2.通知(Advice)"></a>3.2.2.通知(Advice)</h4><p>通知定义了具体的横切逻辑。在Spring中，存在两种类型的Advice，即per-class和per-instance的Advice。</p>
<p>所谓per-class，即该类型的Advice只提供方法拦截，不会为目标对象保存任何状态或者添加新的特性，它也是我们最常见的Advice。下面是per-class的类图：</p>
<p><img src="http://i.imgur.com/tGVnfQi.png" alt=""></p>
<ul>
<li>BeforeAdvice：在连接点前执行的横切逻辑。</li>
<li>AfterReturningAdvice：在连接点执行后，再执行横切逻辑。</li>
<li>AfterAdvice：一般由程序自己实现，当抛出异常后，执行横切逻辑。</li>
<li>AroundAdvice：Spring AOP中并没有提供这个接口，而是采用了AOP Alliance的MethodInteceptor接口；通过看AfterReturningAdvice的源码我们知道，它是不能更改连接点所在方法的返回值的(更改引用)；但使用的MethodInteceptor，所有的事情，都不在话下。</li>
</ul>
<p>部分源码介绍：</p>
<p>AfterAdvice,Advice两个接口是空的</p>
<p>AfterReturningAdvice.class</p>
<pre><code>package org.springframework.aop;

import java.lang.reflect.Method;

public abstract interface AfterReturningAdvice extends AfterAdvice {
    public abstract void afterReturning(Object paramObject1, Method paramMethod, Object[] paramArrayOfObject,
            Object paramObject2) throws Throwable;
}
</code></pre><p>MethodBeforeAdvice.class</p>
<pre><code>import java.lang.reflect.Method;

public abstract interface MethodBeforeAdvice extends BeforeAdvice {
    public abstract void before(Method paramMethod, Object[] paramArrayOfObject, Object paramObject) throws Throwable;
}
</code></pre><p>MethodInterceptor.class</p>
<pre><code>package org.aopalliance.intercept;

public abstract interface MethodInterceptor extends Interceptor {
    public abstract Object invoke(MethodInvocation paramMethodInvocation) throws Throwable;
}
</code></pre><p>在上面的类图中，还有两种类没有介绍，那就是 <strong><em>AdviceAdapter 和 </em></strong>AdviceInteceptor.结构如图所示<br><img src="http://i.imgur.com/0ooNuhA.png" alt=""></p>
<p>我们以AfterReturningAdviceInterceptor为例来说明：</p>
<pre><code>package org.springframework.aop.framework.adapter;

import java.io.Serializable;
import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.springframework.aop.AfterAdvice;
import org.springframework.aop.AfterReturningAdvice;
import org.springframework.util.Assert;

public class AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice, Serializable {
    private final AfterReturningAdvice advice;

    public AfterReturningAdviceInterceptor(AfterReturningAdvice advice) {
        Assert.notNull(advice, &quot;Advice must not be null&quot;);
        this.advice = advice;
    }

    public Object invoke(MethodInvocation mi) throws Throwable {
        Object retVal = mi.proceed();
        this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());
        return retVal;
    }
}
</code></pre><p>该类实现了MethodInterceptor和AfterAdvice接口，同时构造函数中还有一个AfterReturningAdvice实例的参数；这个类存在的作用是为了什么呢？Spring AOP把所有的Advice都适配成了MethodInterceptor，统一的好处是方便后面横切逻辑的执行(参看下一节)，适配的工作即由<em>*</em>AdviceAdapter完成；</p>
<p>Spring AOP所谓的AfterReturningAdvice，通过适配成MethodInterceptor后，其实就是在invoke方法中，先执行目标对象的方法，再执行的AfterReturningAdvice所定义的横切逻辑。</p>
<p>对于per-instance的Advice，目前只有一种实现，就是Introduction，使用的场景比较少。</p>
<p><img src="http://i.imgur.com/EmLqrLw.png" alt=""></p>
<h4 id="3-2-3-切面-Aspect"><a href="#3-2-3-切面-Aspect" class="headerlink" title="3.2.3.切面(Aspect)"></a>3.2.3.切面(Aspect)</h4><p>在Spring中，Advisor就是切面；但与通常的Aspect不同的是，Advisor通常只有一个Pointcut和一个Advice，而Aspect则可以包含多个Pointcut和多个Advice，因此Advisor是一种特殊的Aspect。</p>
<p>接下来看下per-class Advisor的类图：</p>
<p><img src="http://i.imgur.com/rELgifs.png" alt=""></p>
<p>继承关系如下：</p>
<p><img src="http://i.imgur.com/oSYJlw4.png" alt=""></p>
<p>Advisor包含一个Pointcut和一个Advisor；在AbstractGenericPointcutAdvisor中，持有一个Advice的引用；下面的几个实现，均是针对前面提到的几种不同的Pointcut的实现。</p>
<h3 id="3-3-Spring-AOP实现基本线索"><a href="#3-3-Spring-AOP实现基本线索" class="headerlink" title="3.3 Spring AOP实现基本线索"></a>3.3 Spring AOP实现基本线索</h3><p>我们选择ProxyFactoryBean作为入口点和分析的开始。ProxyFactoryBean是在Spring IoC环境中，创建AOP应用的最底层方法，从中，可以看到一条实现AOP的基本线索。</p>
<p>所有的逻辑从以下的方法开始,我们主要针对单例的代理对象的生成：</p>
<pre><code>public Object getObject() throws BeansException {
    //这里初始化通知器链
    initializeAdvisorChain();
    if (isSingleton()) {
        //根据定义需要生成单例的proxy
        return getSingletonInstance();
    }

    if (this.targetName == null) {
        this.logger.warn(
                &quot;Using non-singleton proxies with singleton targets is often undesirable. Enable prototype proxies by setting the &apos;targetName&apos; property.&quot;);
    }
    //这里根据定义需要生成prototype类型的proxy
    return newPrototypeInstance();
}
</code></pre><p>下面我们深入到SpringAOP核心代码的内部，看看代理对象的生成机制，拦截器横切逻辑以及织入的实现。</p>
<pre><code>private synchronized Object getSingletonInstance() {
        if (this.singletonInstance == null) {
            //返回具体的目标对象，就是被代理的对象
            this.targetSource = freshTargetSource();
            if ((this.autodetectInterfaces) &amp;&amp; (getProxiedInterfaces().length == 0) &amp;&amp; (!(isProxyTargetClass()))) {
                //从targetsource中获取目标对象的class
                Class targetClass = getTargetClass();
                if (targetClass == null) {
                    throw new FactoryBeanNotInitializedException(&quot;Cannot determine target class for proxy&quot;);
                }
                //这里设置代理对象的借口
                setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader));
            }
            //这里使用proxyfactory来生成我们需要的proxy。
            super.setFrozen(this.freezeProxy);
            this.singletonInstance = getProxy(createAopProxy());
        }
        return this.singletonInstance;
    }
</code></pre><p>ProxyFactoryBean是AdvisedSupport的子类，Spring使用AopProxy接口把AOP代理的实现与框架的其他部分分离开来。在AdvisedSupport中通过这样的方式来得到AopProxy,当然这里需要得到AopProxyFactory的帮助 ，从JDK或者cglib中得到想要的代理对象：</p>
<pre><code>protected final synchronized AopProxy createAopProxy() {
        if (!(this.active)) {
            activate();
        }
        return getAopProxyFactory().createAopProxy(this);
    }
</code></pre><p>getAopProxyFactory()获取ProxyCreatorSupport的属性aopProxyFactory</p>
<pre><code>public AopProxyFactory getAopProxyFactory() {
        return this.aopProxyFactory;
    }
</code></pre><p>该属性被默认初始化为DefaultAopProxyFactory对象。</p>
<pre><code>public ProxyCreatorSupport() {
    this.aopProxyFactory = new DefaultAopProxyFactory();
}
public ProxyCreatorSupport(AopProxyFactory aopProxyFactory) {
        Assert.notNull(aopProxyFactory, &quot;AopProxyFactory must not be null&quot;);
        this.aopProxyFactory = aopProxyFactory;
    }
</code></pre><p>这个DefaultAopProxyFactory是Spring用来生成AopProxy的地方，它包含JDK和Cglib两种实现方式。让我接着往里面看：</p>
<pre><code>/*** Eclipse Class Decompiler plugin, copyright (c) 2016 Chen Chao (cnfree2000@hotmail.com) ***/
package org.springframework.aop.framework;

import java.io.Serializable;
import java.lang.reflect.Proxy;
import org.springframework.aop.SpringProxy;

public class DefaultAopProxyFactory implements AopProxyFactory, Serializable {
    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
        //做一些判断操作。isoptimize（）是指是否采取进一步的优化，true采用cglib来生成代理。
        //isproxytargetclass决定是否采用基于接口的代理。
        if ((config.isOptimize()) || (config.isProxyTargetClass()) || (hasNoUserSuppliedProxyInterfaces(config))) {
            Class targetClass = config.getTargetClass();
            if (targetClass == null) {
                throw new AopConfigException(
                        &quot;TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.&quot;);
            }
            //如果目标对象实现的接口，则采用jdk动态代理来生成proxy
            if ((targetClass.isInterface()) || (Proxy.isProxyClass(targetClass))) {
                return new JdkDynamicAopProxy(config);
            }
            //如果target不是接口的实现的话，返回cglib类型的aopproxy
            return new ObjenesisCglibAopProxy(config);
        }
        //不满足最开始的判断 直接使用jdk动态代理
        return new JdkDynamicAopProxy(config);
    }

    private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) {
        Class[] ifcs = config.getProxiedInterfaces();
        return ((ifcs.length == 0) || ((ifcs.length == 1) &amp;&amp; (SpringProxy.class.isAssignableFrom(ifcs[0]))));
    }
}
</code></pre><p>可以看到其中的代理对象可以由JDK或者Cglib来生成，JdkDynamicAopProxy类和Cglib2AopProxy都实现的是AopProxy的接口，我们进入JdkDynamicAopProxy实现中看看Proxy是怎样生成的：</p>
<pre><code>public JdkDynamicAopProxy(AdvisedSupport config) throws AopConfigException {
        Assert.notNull(config, &quot;AdvisedSupport must not be null&quot;);
        if ((config.getAdvisors().length == 0) &amp;&amp; (config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE)) {
            throw new AopConfigException(&quot;No advisors and no TargetSource specified&quot;);
        }
        this.advised = config;
    }

    public Object getProxy() {
        return getProxy(ClassUtils.getDefaultClassLoader());
    }

    public Object getProxy(ClassLoader classLoader) {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + this.advised.getTargetSource());
        }
        //根据advised中的配置信息，获取proxy需要代理的接口、放入proxiedInterfaces中。
        Class[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised);
        findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
        //这里我们调用jdk proxy 来生成需要的proxy实例
        return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
    }
</code></pre><p>再来看cglib代理</p>
<pre><code>class ObjenesisCglibAopProxy extends CglibAopProxy {
    private static final Log logger = LogFactory.getLog(ObjenesisCglibAopProxy.class);

    private static final SpringObjenesis objenesis = new SpringObjenesis();

    public ObjenesisCglibAopProxy(AdvisedSupport config) {
        super(config);
    }

    protected Object createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks) {
        Class proxyClass = enhancer.createClass();
        Object proxyInstance = null;

        if (objenesis.isWorthTrying()) {
            try {
                proxyInstance = objenesis.newInstance(proxyClass, enhancer.getUseCache());
            } catch (Throwable ex) {
                logger.debug(&quot;Unable to instantiate proxy using Objenesis, falling back to regular proxy construction&quot;,
                        ex);
            }

        }

        if (proxyInstance == null) {
            try {
                proxyInstance = (this.constructorArgs != null)
                        ? proxyClass.getConstructor(this.constructorArgTypes).newInstance(this.constructorArgs)
                        : proxyClass.newInstance();
            } catch (Throwable ex) {
                throw new AopConfigException(
                        &quot;Unable to instantiate proxy using Objenesis, and regular proxy instantiation via default constructor fails as well&quot;,
                        ex);
            }

        }

        ((Factory) proxyInstance).setCallbacks(callbacks);
        return proxyInstance;
    }
}
</code></pre><p>继承了CglibAopProxy。下面的和最开始的例子比较，是不是很熟悉。</p>
<pre><code>public Object getProxy(ClassLoader classLoader) {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Creating CGLIB proxy: target source is &quot; + this.advised.getTargetSource());
        }
        try {
            Class rootClass = this.advised.getTargetClass();
            Assert.state(rootClass != null, &quot;Target class must be available for creating a CGLIB proxy&quot;);

            Class proxySuperClass = rootClass;
            if (ClassUtils.isCglibProxyClass(rootClass)) {
                proxySuperClass = rootClass.getSuperclass();
                Class[] additionalInterfaces = rootClass.getInterfaces();
                for (Class additionalInterface : additionalInterfaces) {
                    this.advised.addInterface(additionalInterface);
                }

            }

            validateClassIfNecessary(proxySuperClass, classLoader);

            Enhancer enhancer = createEnhancer();
            if (classLoader != null) {
                enhancer.setClassLoader(classLoader);
                if ((classLoader instanceof SmartClassLoader)
                        &amp;&amp; (((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass))) {
                    enhancer.setUseCache(false);
                }
            }
            enhancer.setSuperclass(proxySuperClass);
            enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
            enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
            enhancer.setStrategy(new ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));

            Callback[] callbacks = getCallbacks(rootClass);
            Class[] types = new Class[callbacks.length];
            int k;
            for (int k = 0; k &lt; types.length; ++k) {
                types[k] = callbacks[k].getClass();
            }

            enhancer.setCallbackFilter(new ProxyCallbackFilter(this.advised.getConfigurationOnlyCopy(),
                    this.fixedInterceptorMap, this.fixedInterceptorOffset));
            enhancer.setCallbackTypes(types);

            return createProxyClassAndInstance(enhancer, callbacks);
        } catch (CodeGenerationException ex) {
            throw new AopConfigException(&quot;Could not generate CGLIB subclass of class [&quot; + this.advised.getTargetClass()
                    + &quot;]: &quot; + &quot;Common causes of this problem include using a final class or a non-visible class&quot;, ex);
        } catch (IllegalArgumentException ex) {
            throw new AopConfigException(&quot;Could not generate CGLIB subclass of class [&quot; + this.advised.getTargetClass()
                    + &quot;]: &quot; + &quot;Common causes of this problem include using a final class or a non-visible class&quot;, ex);
        } catch (Exception ex) {
            throw new AopConfigException(&quot;Unexpected AOP exception&quot;, ex);
        }
    }
</code></pre><p>用Proxy包装target之后，通过ProxyFactoryBean得到对其方法的调用就被Proxy拦截了， <strong><em>ProxyFactoryBean的getObject()方法得到的实际上是一个Proxy了，target对象已经被封装了。</em></strong>对 ProxyFactoryBean这个工厂bean而言，其生产出来的对象是封装了目标对象的代理对象。</p>
<h3 id="3-4拦截器的作用"><a href="#3-4拦截器的作用" class="headerlink" title="3.4拦截器的作用"></a>3.4拦截器的作用</h3><p>前面分析了SpringAOP实现中得到Proxy对象的过程，接下来我们去探寻Spring AOP中拦截器链是怎样被调用的，也就是Proxy模式是怎样起作用的。<br>还记得在JdkDynamicAopProxy中生成Proxy对象的时候，有一句这样的代码吗？</p>
<pre><code>return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
</code></pre><p>这里我们的JdkDynamicAopProxy实现了InvocationHandler这个接口，<code>final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable</code>.</p>
<p>this参数对应的是InvocationHandler对象,也就是说当 Proxy对象的函数被调用的时候，InvocationHandler的invoke方法会被作为回调函数调用.</p>
<p>我们来看一下动态代理中invoke函数的实现：</p>
<pre><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object oldProxy = null;
        boolean setProxyContext = false;

        TargetSource targetSource = this.advised.targetSource;
        Class targetClass = null;
        Object target = null;
        try {
            Object localObject1;
            //目标对象未实现equals方法
            if ((!(this.equalsDefined)) &amp;&amp; (AopUtils.isEqualsMethod(method))) {
                localObject1 = Boolean.valueOf(equals(args[0]));
                return localObject1;
            }
            //目标对象未实现hashcode方法
            if ((!(this.hashCodeDefined)) &amp;&amp; (AopUtils.isHashCodeMethod(method))) {
                localObject1 = Integer.valueOf(hashCode());
                return localObject1;
            }
            //opaque顺序控制生成代理对象是否可以强制转换类型为advised，默认为false。
            //z这里针对opaque为true且代理的为借口自身，并且代理类为advised借口的子接口，不进行代理操作。
            if ((!(this.advised.opaque)) &amp;&amp; (method.getDeclaringClass().isInterface())
                    &amp;&amp; (method.getDeclaringClass().isAssignableFrom(Advised.class))) {
            //这里就是目标对象的调用
                localObject1 = AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);
                return localObject1;
            }
            //设置exposeproxy为true，让springaop框架将生成的当前代理对象绑定到threadlocal
            if (this.advised.exposeProxy) {
                oldProxy = AopContext.setCurrentProxy(proxy);
                setProxyContext = true;
            }
            //这里是得到目标对象，目标对象可能来自一个示例池或者一个简单的java对象。
            target = targetSource.getTarget();
            if (target != null) {
                targetClass = target.getClass();
            }
            //重要！！！：：：这里获得定义好的拦截器链
            List chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
            Object retVal;
            Object retVal;
            //如果没有拦截器，直接调用目标的对象方法，不创建methodinvocation
            if (chain.isEmpty()) {
                Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
                retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
            } else {
                //如果有拦截器的设定，那么需要调用拦截器之后才能调用目标对象的相应的方法。
                //通过构造一个ReflectiveMethodInvocation来实现
                MethodInvocation invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass,
                        chain);
                //通过ReflectiveMethodInvocation来调用拦截器连和相应的目标方法。
                //在proceed方法内部实现了自身的递归调用来便利整个拦截器链。

                retVal = invocation.proceed();
            }

            Class returnType = method.getReturnType();
            if ((retVal != null) &amp;&amp; (retVal == target) &amp;&amp; (returnType.isInstance(proxy))
                    &amp;&amp; (!(RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())))) {
                retVal = proxy;
            } else if ((retVal == null) &amp;&amp; (returnType != Void.TYPE) &amp;&amp; (returnType.isPrimitive())) {
                throw new AopInvocationException(
                        &quot;Null return value from advice does not match primitive return type for: &quot; + method);
            }

            Object localObject2 = retVal;

            return localObject2;
        } finally {
            if ((target != null) &amp;&amp; (!(targetSource.isStatic()))) {
                //释放gettarget方法获取的target对象，和targetsource实现有关
                targetSource.releaseTarget(target);
            }
            if (setProxyContext) {
                AopContext.setCurrentProxy(oldProxy);
            }
        }
    }
</code></pre><p>上面所说的目标对象方法的调用，是通过AopUtils的方法调用，使用反射机制来对目标对象的方法进行的;</p>
<pre><code>public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) throws Throwable {
    try {
        ReflectionUtils.makeAccessible(method);
        return method.invoke(target, args);
    } catch (InvocationTargetException ex) {
        throw ex.getTargetException();
    } catch (IllegalArgumentException ex) {
        throw new AopInvocationException(&quot;AOP configuration seems to be invalid: tried calling method [&quot; + method
                + &quot;] on target [&quot; + target + &quot;]&quot;, ex);
    } catch (IllegalAccessException ex) {
        throw new AopInvocationException(&quot;Could not access method [&quot; + method + &quot;]&quot;, ex);
    }
}
</code></pre><p>接下来，我们来看具体的ReflectiveMethodInvocation中proceed()方法的实现，也就是拦截器链的实现机制：</p>
<pre><code>public Object proceed() throws Throwable {
        //重点！！！currentInterceptorIndex初始化值为-1，首先判断长度是否为0，为0直接调用目标对象的方法。
        if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {
            return invokeJoinpoint();
        }

        Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers
                .get(++this.currentInterceptorIndex);

        if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {
            //匹配逻辑，只要方法匹配就调用拦截器，不匹配，跳过这个拦截器，调用下一个。
            InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
            //需要注意一点，我们这里虽然反悔了，但是匹配到的拦截器自身的invoke方法还是会调用的，
            //继续遍历拦截器链
            if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {
                return dm.interceptor.invoke(this);
            }
            //没匹配， 调用下一个拦截器，重复上面逻辑
            return proceed();
        }
        //如果是MethodInterceptor，我们调用invoke方法，主要为了兼容原始aop联盟的东西，
        return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);
    }
</code></pre><p>从上面的分析我们看到了Spring AOP拦截机制的基本实现，比如Spring怎样得到Proxy，怎样利用JAVA Proxy以及反射机制对用户定义的拦截器链进行处理。</p>
<h3 id="3-5织入的实现"><a href="#3-5织入的实现" class="headerlink" title="3.5织入的实现"></a>3.5织入的实现</h3><p>在上面调用拦截器的时候，经过一系列的注册，适配的过程以后，拦截器在拦截的时候，会调用到预置好的一个通知适配器，设置通知拦截器，这是一系列Spring设计好为通知服务的类的一个，是最终完成通知拦截和实现的地方，例如对 MethodBeforeAdviceInterceptor的实现是这样的：</p>
<pre><code>public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable {
    private MethodBeforeAdvice advice;

    public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) {
        Assert.notNull(advice, &quot;Advice must not be null&quot;);
        this.advice = advice;
    }

    public Object invoke(MethodInvocation mi) throws Throwable {
        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());
        //这个invoke方法是拦截器的回调方法，会在代理对象的方法被调用的时候出发回调
        return mi.proceed();
    }
}
</code></pre><p>可以看到通知适配器将advice适配成Interceptor以后，会调用advice的before方法去执行横切逻辑。这样就成功的完成了before通知的织入。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-AOP-源码分析&quot;&gt;&lt;a href=&quot;#Spring-AOP-源码分析&quot; class=&quot;headerlink&quot; title=&quot;Spring AOP 源码分析&quot;&gt;&lt;/a&gt;Spring AOP 源码分析&lt;/h1&gt;&lt;h2 id=&quot;零-Spring-aop的
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="AOP" scheme="http://yoursite.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>数据仓库三种变化类型</title>
    <link href="http://yoursite.com/2016/10/28/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%89%E7%A7%8D%E5%8F%98%E5%8C%96%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2016/10/28/数据仓库三种变化类型/</id>
    <published>2016-10-28T03:50:06.000Z</published>
    <updated>2016-11-02T17:26:00.248Z</updated>
    
    <content type="html"><![CDATA[<p>类型1：对于数据元素的历史记录不重要的时候使用，当一个数据源变化的时候，对应的维度属性将会被覆盖，</p>
<p>类型2：当变化的数据元素历史记录也很重要的时候采用，源数据的元素变化的时候，会在维度表中插入新的一行来满足需求。</p>
<p>类型3：当所有分析伴随新值或者旧值的变化前后记录的事实时，需要使用到变化类型3.使用类型1和类型2是不能够解决的。<br>比如：分析所有事实的情况，使用的是新值记录变化发生前后的情况。</p>
<p>###3种事实表</p>
<p>1.事务事实表<br>描述事件，获取事件，或行为的细节</p>
<p>2.事务表快照<br>描述状态，获取事件或行为的效果</p>
<p>3.累计快照<br>累计快照可以跟踪业务流程的一个或多个步骤的时间间隔。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类型1：对于数据元素的历史记录不重要的时候使用，当一个数据源变化的时候，对应的维度属性将会被覆盖，&lt;/p&gt;
&lt;p&gt;类型2：当变化的数据元素历史记录也很重要的时候采用，源数据的元素变化的时候，会在维度表中插入新的一行来满足需求。&lt;/p&gt;
&lt;p&gt;类型3：当所有分析伴随新值或者旧
    
    </summary>
    
      <category term="数据仓库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
    
      <category term="数据仓库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM七-虚拟机类加载机制</title>
    <link href="http://yoursite.com/2016/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E4%B8%83-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2016/10/24/深入理解JVM七-虚拟机类加载机制/</id>
    <published>2016-10-24T10:59:48.000Z</published>
    <updated>2016-10-31T11:38:29.004Z</updated>
    
    <content type="html"><![CDATA[<p>类从被加载到卸载，整个生命周期如下：</p>
<ul>
<li>加载（loading）</li>
<li>连接（验证verification 准备preparation 解析resolution）</li>
<li>初始化（initialization）</li>
<li>使用（using）</li>
<li>卸载（unloading）</li>
</ul>
<p>主动引用，触发类的初始化：</p>
<ul>
<li>1.遇到new getstatic putstatic invokestatic</li>
<li>2.使用java.lang.reflect包的方法对垒进行反射调用。</li>
<li>3.初始化一个类的时候，如果发现父类还没有进行过初始化，则先触发其父类的初始化。</li>
<li>4.当虚拟机启动时，用户需要制定一个要执行的主类，虚拟机则会先初始化这个主类。</li>
<li>5.当使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.methodhandle实例最后解析的结果ref_getstatic ref_putstatic ref_invokestatic 的方法句柄。</li>
</ul>
<p>主要过程参照另一篇blog<br><a href="http://raincoffee.info/2016/09/22/java%E7%B1%BB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/" title="类的加载初始化过程" target="_blank" rel="external">http://raincoffee.info/2016/09/22/java%E7%B1%BB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/</a></p>
<p>###类加载器###</p>
<p>1.类与类加载器<br>比较两个类食肉相等，只能有一个类加载器加载的前提下才有意义。否则，即使这两个类来源于同一个class文件，被同一个虚拟机加载，只要夹在他们的类加载器不同，拿着两个雷一定不同。</p>
<pre><code>package jvm;

import java.io.IOException;
import java.io.InputStream;


/**
 * 
 * @author neuly
 *
 */
public class ClassLoaderTest {
    public static void main(String[] args) throws Exception{
        ClassLoader myloader= new ClassLoader() {
                @Override
                public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException{
                    try {
                        String fileName=name.substring(name.lastIndexOf(&quot;.&quot;)+1)+&quot;.class&quot;;
                        InputStream is= getClass().getResourceAsStream(fileName);
                        if(is==null){
                            return super.loadClass(name);
                        }
                        byte[] b = new byte[is.available()];
                        is.read(b);
                        return defineClass(name, b, 0,b.length);
                    } catch (IOException e) {;; 
                        // TODO: handle exception
                        throw new ClassNotFoundException(name);
                    }

                }
            };
            Object obj =myloader.loadClass(&quot;jvm.ClassLoaderTest&quot;).newInstance();
            System.out.println(obj.getClass());
            System.out.println(obj instanceof jvm.ClassLoaderTest);
    }
}
</code></pre><p>结果 </p>
<pre><code>class jvm.ClassLoaderTest
false
</code></pre><p>代码加载与自己同一路径下的class文件。</p>
<p>###2.双亲委派模型###</p>
<p>自动类加载器<br>↑<br>扩展类加载器<br>↑<br>应用程序类加载器<br>↑<br>自定义类加载器</p>
<p>双亲委派工作过程：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，二十八请求为派给父类加载器去完成。每一个层次的类加载器都是如此，因此所有的加载请求最终都应传送到顶层的启动类加载器中，只有当弗雷加载器反馈自己不能完成这个加载请求时，自加载器才会尝试自己去加载。</p>
<p>###2.破坏双亲委派模型###</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类从被加载到卸载，整个生命周期如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加载（loading）&lt;/li&gt;
&lt;li&gt;连接（验证verification 准备preparation 解析resolution）&lt;/li&gt;
&lt;li&gt;初始化（initialization）&lt;/li&gt;
&lt;li&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM六-类文件结构</title>
    <link href="http://yoursite.com/2016/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%85%AD-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2016/10/24/深入理解JVM六-类文件结构/</id>
    <published>2016-10-24T08:36:18.000Z</published>
    <updated>2016-11-02T17:25:38.764Z</updated>
    
    <content type="html"><![CDATA[<p>class文件是一组以八位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在class文件中，中间没有添加任何分隔符，这使得整个class文件中存储的内容几乎全部都是程序运行的必要数据，没有空隙存在。当需要占用8位字节以上的空间数据时，则会按照高位在前的方式分割成若干个8位字节进行存储。</p>
<p>###class文件结构介绍：</p>
<p>根据java虚拟机规范的规定，class文件格式采用一种类似c语言结构体的伪结构来存储，这种伪结构中只有两种数据类型：无符号数和表。</p>
<p>无符号数：无符号数属于基本的数据类型，以u1,u2,u4,u8来分别代表1个字节，2个字节，4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值，或者按照utf-8编码构成字符串值。</p>
<p>表：表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info“结尾。表用于描述有层次关系的复合结构的数据，整个class文件本质上就是一张表，它由下列数据项构成：</p>
<pre><code>ClassFile {  
    u4 magic;//魔数(0xCAFEBABE)  
    u2 minor_version;//次版本号  
    u2 major_version;//主版本号  
    u2 constant_pool_count;//常量池容量计数值  
    cp_info constant_pool[constant_pool_count-1];//常量池  
    u2 access_flags;//访问标志  
    u2 this_class;//类索引  
    u2 super_class;//父类索引  
    u2 interfaces_count;//接口计数器  
    u2 interfaces[interfaces_count];//接口索引集合  
    u2 fields_count;//字段计数器  
    field_info fields[fields_count];//字段表  
    u2 methods_count;//方法计数器  
    method_info methods[methods_count];//方法表  
    u2 attributes_count;//属性表计数器  
    attribute_info attributes[attributes_count];//属性表集合  
}  
</code></pre><p>无论是无符号数还是表，当需要描述的同一类型但是数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式（比如说一个类可能实现了多个接口，这时候需要一个计数器来指定接口的数量），这时候称这一系列连续的某一类型的数据为某一类型的集合。上面的文件格式是固定的，每个数据项的顺序，占用字节数都是被严格限定的，不允许改变。</p>
<p>1.魔数：class文件头四个字节代表魔数，它的作用是用于确定该文件是一个能被虚拟机接受的class文件,其值为0xCAFEBABE.</p>
<p>2.版本：魔数后四个字节代表class文件的版本号，其中前两个字节代表次版本号，后两个字节代表主版本号。高版本的jdk能向下兼容以前版本的class文件，但不能运行以后版本的class文件。</p>
<p>3.常量池：主版本之后的是常量池入口，常量池是class文件结构中与其他项目关联最多的数据类型，也是占用class文件空间最大的数据项目之一，同时还是在class文件中第一个出现的表类型的数据项目。因为常量池中常量数量不固定，所以在常量池入口前需要放置一个计数器，占用两个字节。比如如果该位置的值为0x0016,那就代表常量池中有21项常量（从1开始），第0项空出来是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达”不引用任何一个常量池项目“的意思，这种情况就可以把索引置为0来表示。class文件结构只有常量池的容量计数器是从1开始的，其他集合类型都是从0开始的。<br>    常量池中主要存放两类数据：字面量和符号引用；<br>（1）字面量：比如文本字符串，被声明为final的常量值等。<br>（2）符号引用：包括类和接口的权限定名，字段的名称和描述符，方法的名称和描述符。</p>
<p>4.访问标志（access_flags）：常量池之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息（比如这个class是否是public是否是final等等)。</p>
<p>5.类索引，父类索引，接口索引：类索引和父类索引都是一个u2类型的数据，而接口索引集合时一组u2类型的数据的集合，class文件中由这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名（除了kava.lang.Object以外所有类的父类索引均不为0）。接口索引集合用来描述这个类实现了哪些接口。<br>    类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。</p>
<p>6.字段表集合：字段表集合用于描述接口或者类中声明的变量。字段包括了类级变量或者实例级变量，但是不包括方法内部声明的变量。</p>
<p>7.方法表集合：内容跟属性表集合基本一致</p>
<p>8.属性表集合：在class文件、字段表、方法表中都可以携带字节的属性表集合，用于描述某些场景专有的信息。属性表中的数据项目不需要有严格的顺序，java虚拟机在运行时会自动的忽略掉不认识的属性，其中系统预定义了9种虚拟机应该识别的属性，</p>
<p>连接：<br><a href="http://blog.csdn.net/kobejayandy/article/details/39620833" target="_blank" rel="external">http://blog.csdn.net/kobejayandy/article/details/39620833</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;class文件是一组以八位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在class文件中，中间没有添加任何分隔符，这使得整个class文件中存储的内容几乎全部都是程序运行的必要数据，没有空隙存在。当需要占用8位字节以上的空间数据时，则会按照高位在前的方式分割
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM笔记五-调优案例分析与实战</title>
    <link href="http://yoursite.com/2016/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E7%AC%94%E8%AE%B0%E4%BA%94/"/>
    <id>http://yoursite.com/2016/10/24/深入理解JVM笔记五/</id>
    <published>2016-10-24T07:00:22.000Z</published>
    <updated>2016-11-02T17:25:25.153Z</updated>
    
    <content type="html"><![CDATA[<p>高性能硬件上部署程序，目前主要有两种方式：</p>
<ul>
<li>使用64位JDK来使用大内存</li>
<li>使用若干个32位虚拟机建立逻辑集群来利用硬件资源</li>
</ul>
<p>集群间同步导致的内存溢出；</p>
<p>堆外内存导致的溢出错误：</p>
<p>direct memory:可通过-XX：MaxDirectMemorySize调整大小，内存不足会抛出outofmemory或者outofmemoryerror：direct buffer memory。</p>
<p>线程堆栈：通过-Xss调整大小。不足抛出stackoverflowerror。</p>
<p>eclipse性能调优参考深入理解jvm第5章</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;高性能硬件上部署程序，目前主要有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用64位JDK来使用大内存&lt;/li&gt;
&lt;li&gt;使用若干个32位虚拟机建立逻辑集群来利用硬件资源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;集群间同步导致的内存溢出；&lt;/p&gt;
&lt;p&gt;堆外内存导致的溢出错误：&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>兰天震的设计</title>
    <link href="http://yoursite.com/2016/10/23/%E5%85%B0%E5%A4%A9%E9%9C%87%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2016/10/23/兰天震的设计/</id>
    <published>2016-10-23T12:45:12.000Z</published>
    <updated>2016-10-23T12:45:30.575Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i.imgur.com/x94fo9Q.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i.imgur.com/x94fo9Q.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解JVM笔记四-虚拟机性能监控与故障处理工具</title>
    <link href="http://yoursite.com/2016/10/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E7%AC%94%E8%AE%B0%E5%9B%9B/"/>
    <id>http://yoursite.com/2016/10/21/深入理解JVM笔记四/</id>
    <published>2016-10-21T08:22:24.000Z</published>
    <updated>2016-11-02T17:25:20.069Z</updated>
    
    <content type="html"><![CDATA[<p>###jdk命令行工具</p>
<p>1.jps<br>虚拟机进程状态工具</p>
<pre><code>常用的几个参数：
-l   输出Java应用程序的main class的完整包

-q 仅显示pid，不显示其它任何相关信息

-m 输出传递给main方法的参数

-v 输出传递给JVM的参数。在诊断JVM相关问题的时候，这个参数可以查看JVM相关参数的设置
</code></pre><p>2.jstat</p>
<p>虚拟机统计信息监视工具</p>
<pre><code>C:\Program Files\Java\jdk1.8.0_91\bin&gt;jstat -gcutil 1676
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT
  0.00 100.00  53.66  80.08  91.20  81.37     72    2.443     0    0.000    2.443

C:\Program Files\Java\jdk1.8.0_91\bin&gt;jstat -gc 1676
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
 0.0   6144.0  0.0   6144.0 83968.0  53248.0   172032.0   137768.9  173184.0 157951.9 23168.0 18851.1     72    2.443   0      0.000    2.443
</code></pre><blockquote>
<p>堆内存 = 年轻代 + 年老代 + 永久代</p>
<p>年轻代 = Eden区 + 两个Survivor区（From和To）</p>
<p>S0C、S1C、S0U、S1U：Survivor 0/1区容量（Capacity）和使用量（Used）</p>
<p>EC、EU：Eden区容量和使用量</p>
<p>OC、OU：年老代容量和使用量</p>
<p>PC、PU：永久代容量和使用量</p>
<p>YGC、YGCT：年轻代GC次数和GC耗时</p>
<p>FGC、FGCT：Full GC次数和Full GC耗时</p>
<p>GCT：GC总耗时</p>
</blockquote>
<p><img src="http://i.imgur.com/uQntEKD.png" alt=""></p>
<p>###3  jinfo   </p>
<p>java配置信息工具</p>
<p>观察运行中的java程序的运行环境参数：参数包括Java System属性和JVM命令行参数</p>
<p>实例：jinfo 2083</p>
<p>其中2083就是java进程id号，可以用jps得到这个id号。</p>
<p>输出内容太多了，不在这里一一列举，大家可以自己尝试这个命令。</p>
<p>###4 jmap  Java内存映像工具<br> jmap（Memory Map）和  jhat（Java Heap Analysis Tool）<br> jmap用来查看堆内存使用状况，一般结合jhat使用。</p>
<p>###5.jhat 虚拟机堆转储快照分析工具</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###jdk命令行工具&lt;/p&gt;
&lt;p&gt;1.jps&lt;br&gt;虚拟机进程状态工具&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;常用的几个参数：
-l   输出Java应用程序的main class的完整包

-q 仅显示pid，不显示其它任何相关信息

-m 输出传递给main方法的参数

-
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM笔记三</title>
    <link href="http://yoursite.com/2016/10/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
    <id>http://yoursite.com/2016/10/21/深入理解JVM笔记三/</id>
    <published>2016-10-21T06:30:38.000Z</published>
    <updated>2016-11-02T17:25:14.576Z</updated>
    
    <content type="html"><![CDATA[<p>内存分配策略</p>
<p>###1.对象有现在eden区分配。</p>
<p>大多数情况下，对象在新生代eden区中分配，当Eden区没有足够的空间分配，虚拟机将发起一次minor GC。<br>虚拟机提供<code>-XX：+PrintGCDetails</code>这个日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并在进程退出的时候输出当前的内存各区域分配的情况。</p>
<pre><code>public class aa{
        /**
         * -verbose:gc -Xms20M -Xms20M -Xmn10M -XX:+PrintGCDetails 
         * -XX:SurvivorRatio=8
         * 
         */
public static final int _1MB =1024*1024;
        public static void main(String[] args) {

            byte[] allocation1,allocation2,allocation3,allocation4;
            allocation1= new byte[2*_1MB];
            allocation2= new byte[2*_1MB];
            allocation3= new byte[2*_1MB];
            allocation4= new byte[3*_1MB];
        }
}
[GC (Allocation Failure) [PSYoungGen: 7128K-&gt;648K(9216K)] 7128K-&gt;6800K(19456K), 0.0030424 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (Ergonomics) [PSYoungGen: 648K-&gt;0K(9216K)] [ParOldGen: 6152K-&gt;6673K(27648K)] 6800K-&gt;6673K(36864K), [Metaspace: 2654K-&gt;2654K(1056768K)], 0.0070118 secs] [Times: user=0.06 sys=0.00, real=0.01 secs] 
Heap
 PSYoungGen      total 9216K, used 3154K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 38% used [0x00000000ff600000,0x00000000ff914930,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
 ParOldGen       total 27648K, used 6673K [0x0000000081c00000, 0x0000000083700000, 0x00000000ff600000)
  object space 27648K, 24% used [0x0000000081c00000,0x0000000082284408,0x0000000083700000)
 Metaspace       used 2660K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 288K, capacity 386K, committed 512K, reserved 1048576K
</code></pre><p>###2.对象直接进入老年代</p>
<p>虚拟机提供一个-XX:pertenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在eden取以及两个survivor区之间发生大量的内存复制。（新生代采用复制算法收集内存）</p>
<pre><code>public class aa{
        /**
         * -verbose:gc -Xms20M -Xms20M -Xmn10M -XX:+PrintGCDetails -XX:PertenureSizeThreshold=3145728
         * -XX:SurvivorRatio=8
         * 
         */
public static final int _1MB =1024*1024;
        public static void main(String[] args) {

            byte[] allocation4;
            allocation4= new byte[4*_1MB];
        }
}
</code></pre><p>###3.长期存活的对象将直接进入老年代</p>
<p>虚拟机给每个对象定义了一个age年龄计数器。如果对象在eden出生并经历了第一次minor gc仍然活着的话，并且能够被survivor容纳，警备移动大survivor空间，并且对象的年龄设为1.对于survivor中没熬过一次minor gc，年龄就增加1.当她的年龄增加到一定程度，默认是15，就会被净胜到老年代。对象净胜到老年代的年龄阈值通过参数-XX:MaxTenuringThreshold设置。</p>
<p>###4.动态对象年龄判定</p>
<p>为了更好地适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到阈值才能够到老年代，瑞国survivor中相同年龄所有对象的大小纸盒大于survivor空间的一般，年龄大于或等于改年龄的对象就可以进入老年代了。</p>
<p>###5.空间分配担保</p>
<p>在发生minor gc之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果这个条件成立，那么minor gc可以确保是安全的。如果不成立，虚拟机会查看handlepromotionfailure设置值食肉允许担保失败，如果允许，那么就会继续检查老年代中最大可用连续空间时都大于历次净胜到老年代对象的平均大小。如果大于，将尝试着进行一次minor gc，尽管这次minor gc是有风险的。如果小于，或者handlepromotionfailure设置不允许毛线，那么就要改为进行一次full gc。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存分配策略&lt;/p&gt;
&lt;p&gt;###1.对象有现在eden区分配。&lt;/p&gt;
&lt;p&gt;大多数情况下，对象在新生代eden区中分配，当Eden区没有足够的空间分配，虚拟机将发起一次minor GC。&lt;br&gt;虚拟机提供&lt;code&gt;-XX：+PrintGCDetails&lt;/code&gt;这
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM笔记二---垃圾收集器及内存分配策略</title>
    <link href="http://yoursite.com/2016/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <id>http://yoursite.com/2016/10/19/深入理解JVM笔记二/</id>
    <published>2016-10-19T02:51:50.000Z</published>
    <updated>2016-11-02T17:25:05.958Z</updated>
    
    <content type="html"><![CDATA[<p>####对象已死么？</p>
<p>1.引用计数算法</p>
<p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器值就加1；当引用时效的时候，减一。任何时候计数器为0的对象就是不可能再被引用的。（很难解决对象之间相互循环引用的问题）</p>
<p>2.可达性分析算法</p>
<p>这个算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，下图对象object5, object6, object7虽然有互相判断，但它们到GC Roots是不可达的，所以它们将会判定为是可回收对象。<br><img src="http://i.imgur.com/XvHdvR5.png" alt=""></p>
<p>java  GC ROOTS的对象包含以下几种<br>虚拟机栈中引用的对象<br>方法区中类静态属性引用的对象<br>方法区中常量引用的对象<br>本地方法栈种JNI（native方法）引用的对象</p>
<p>####引用</p>
<p>1.强引用 一直活着<br>2.软引用 还有用但并非必须的对象 活到第二次回收<br>3.弱引用 非必须对象 活到下一次垃圾收集之前<br>4.虚引用</p>
<p>####GC算法<br>1.标记清除算法</p>
<p>分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。该算法的缺点是效率不高并且会产生不连续的内存碎片。<br><img src="http://i.imgur.com/PTYTd1h.jpg" alt=""></p>
<p>2.复制算法</p>
<p>把内存空间划为两个区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。优点：实现简单，运行高效。缺点：会浪费一定的内存。一般新生代采用这种算法<br><img src="http://i.imgur.com/wXBBEyQ.jpg" alt=""></p>
<p>3.标记整理算法</p>
<p>标记阶段与标记清除算法一样。但后续并不是直接对可回收的对象进行清理，而是让所有存活对象都想一端移动，然后清理。优点是不会造成内存碎片<br><img src="http://i.imgur.com/1H8E9sw.jpg" alt=""></p>
<p>4.分代收集算法<br>只是根据对象存货周期的不用将内存划分为几块。一般是把java堆划分为新生代和老年代。这样就可以根据各个年代的特点采用最适当的手机算法。在新生代中，每次垃圾收集时有大量的对象死亡，只有少量的存在，那就采用复制算法，对于老年代，对象存活率高，没有额外空间对他进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p>
<p>####Java中垃圾回收器的类型<br>Java提供多种类型的垃圾回收器。JVM中的垃圾收集一般都采用“分代收集”，不同的堆内存区域采用不同的收集算法，主要目的就是为了增加吞吐量或降低停顿时间。</p>
<ul>
<li>Serial收集器：新生代收集器，使用复制算法，使用一个线程进行GC，串行，其它工作线程暂停。</li>
<li>ParNew收集器：新生代收集器，使用复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停。使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。</li>
<li>Parallel Scavenge 收集器：吞吐量优先的垃圾回收器，作用在新生代，使用复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间。使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾。</li>
<li>Serial Old收集器：老年代收集器，单线程收集器，串行，使用标记整理算法，使用单线程进行GC，其它工作线程暂停。</li>
<li>Parallel Old收集器：吞吐量优先的垃圾回收器，作用在老年代，多线程，并行，多线程机制与Parallel Scavenge差不错，使用标记整理算法，在Parallel Old执行时，仍然需要暂停其它线程。</li>
<li>CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见Full GC和并发垃圾回收一节），当用户线程内存不足时，采用备用方案Serial Old收集。</li>
<li>GI收集器</li>
</ul>
<p>####与GC有关的JVM参数<br>做GC调优需要大量的实践，耐心和对项目的分析。我曾经参与过高容量，低延迟的电商系统，在开发中我们需要通过分析造成Full GC的原因来提高系统性能，在这个过程中我发现做GC的调优很大程度上依赖于对系统的分析，系统拥有怎样的对象以及他们的平均生命周期。</p>
<p>举个例子，如果一个应用大多是短生命周期的对象，那么应该确保Eden区足够大，这样可以减少Minor GC的次数。可以通过-XX:NewRatio来控制新生代和老年代的比例，比如-XX:NewRatio=3代表新生代和老年代的比例为1：3。需要注意的是，扩大新生代的大小会减少老年代的大小，这会导致Major GC执行的更频繁，而Major GC可能会造成用户线程的停顿从而降低系统吞吐量。JVM中可以用NewSize和MaxNewSize参数来指定新生代内存最小和最大值，如果两个参数值一样，那么就相当于固定了新生代的大小。<br>个人建议，在做GC调优之前最好深入理解Java中GC机制，推荐阅读Sun Microsystems提供的有关GC的文档。这个链接可能会对理解GC机制提供一些帮助。下面的图列出了各个区可用的一些JVM参数。<br><img src="http://i.imgur.com/bwvkDEn.png" alt=""></p>
<p>####总结</p>
<ul>
<li>为了分代垃圾回收，Java堆内存分为3代：新生代，老年代和永久代。</li>
<li>新的对象实例会优先分配在新生代，在经历几次Minor GC后(默认15次)，还存活的会被移至老年代(某些大对象会直接在老年代分配)。</li>
<li>永久代是否执行GC，取决于采用的JVM。</li>
<li>Minor GC发生在新生代，当Eden区没有足够空间时，会发起一次Minor GC，将Eden区中的存活对象移至Survivor区。Major GC发生在老年代，当升到老年代的对象大于老年代剩余空间时会发生Major GC。</li>
<li>发生Major GC时用户线程会暂停，会降低系统性能和吞吐量。</li>
<li>JVM的参数-Xmx和-Xms用来设置Java堆内存的初始大小和最大值。依据个人经验这个值的比例最好是1:1或者1:1.5。比如，你可以将-Xmx和-Xms都设为1GB，或者-Xmx和-Xms设为1.2GB和1.8GB。</li>
<li>Java中不能手动触发GC，但可以用不同的引用类来辅助垃圾回收器工作(比如：弱引用或软引用)。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;####对象已死么？&lt;/p&gt;
&lt;p&gt;1.引用计数算法&lt;/p&gt;
&lt;p&gt;给对象中添加一个引用计数器，每当有一个地方引用它，计数器值就加1；当引用时效的时候，减一。任何时候计数器为0的对象就是不可能再被引用的。（很难解决对象之间相互循环引用的问题）&lt;/p&gt;
&lt;p&gt;2.可达性分析算
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM笔记一-java内存区域与内存溢出异常</title>
    <link href="http://yoursite.com/2016/10/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://yoursite.com/2016/10/18/深入理解JVM笔记一/</id>
    <published>2016-10-18T07:03:57.000Z</published>
    <updated>2016-11-02T17:25:31.949Z</updated>
    
    <content type="html"><![CDATA[<p>#自动内存管理机制</p>
<p>##java内存区域与内存溢出异常</p>
<p>###1.java虚拟机运行时数据区</p>
<p><img src="http://i.imgur.com/9y9f9Z1.png" alt=""></p>
<ul>
<li><p>程序计数器（Program Counter Register）</p>
<blockquote>
<p>它是一块较小的内存空间，它的作用可以看做是当先线程所执行的字节码的信号指示器。</p>
<p>每一条JVM线程都有自己的PC寄存器，各条线程之间互不影响，独立存储，这类内存区域被称为“线程私有”内存</p>
<p>在任意时刻，一条JVM线程只会执行一个方法的代码。该方法称为该线程的当前方法（Current Method）</p>
<p>如果该方法是java方法，那PC寄存器保存JVM正在执行的字节码指令的地址</p>
<p>如果该方法是native，那PC寄存器的值是undefined。</p>
<p>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
</blockquote>
</li>
<li><p>Java虚拟机栈（Java Virtual Machine Stack）</p>
<blockquote>
<p>与PC寄存器一样，Java虚拟机栈也是线程私有的。每一个JVM线程都有自己的java虚拟机栈，这个栈与线程同时创建，它的生命周期与线程相同。</p>
<p>虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>JVM stack 可以被实现成固定大小，也可以根据计算动态扩展。</p>
<p>如果采用固定大小的JVM stack设计，那么每一条线程的JVM Stack容量应该在线程创建时独立地选定。JVM实现应该提供调节JVM Stack初始容量的手段；如果采用动态扩展和收缩的JVM Stack方式，应该提供调节最大、最小容量的手段。</p>
<p>如果线程请求的栈深度大于虚拟机所允许的深度将抛出StackOverflowError；</p>
<p>如果JVM Stack可以动态扩展，但是在尝试扩展时无法申请到足够的内存时抛出OutOfMemoryError。</p>
</blockquote>
</li>
<li><p>本地方法栈（Native Method Stack）</p>
</li>
</ul>
<blockquote>
<p>本地方法栈与虚拟机栈作用相似，后者为虚拟机执行Java方法服务，而前者为虚拟机用到的Native方法服务。</p>
<p>虚拟机规范对于本地方法栈中方法使用的语言，使用方式和数据结构没有强制规定，甚至有的虚拟机（比如HotSpot）直接把二者合二为一。</p>
<p>这玩意儿抛出的异常跟上面的虚拟机栈一样。</p>
</blockquote>
<ul>
<li><p>Java堆（Java Heap）</p>
<blockquote>
<p>虚拟机管理的内存中最大的一块，同时也是被所有线程所共享的，它在虚拟机启动时创建，这货存在的意义就是存放对象实例，几乎所有的对象实例以及数组都要在这里分配内存。这里面的对象被自动管理，也就是俗称的GC（Garbage Collector）所管理。用就是了，有GC扛着呢，不用操心销毁回收的事儿。</p>
<p>Java堆的容量可以是固定大小，也可以随着需求动态扩展（-Xms和-Xmx），并在不需要过多空间时自动收缩。</p>
<p>Java堆所使用的内存不需要保证是物理连续的，只要逻辑上是连续的即可。</p>
<p>JVM实现应当提供给程序员调节Java 堆初始容量的手段，对于可动态扩展和收缩的堆来说，则应当提供调节其最大和最小容量的手段。</p>
<p>如果堆中没有内存完成实例分配并且堆也无法扩展，就会抛OutOfMemoryError。</p>
</blockquote>
</li>
<li><p>方法区（Method Area）</p>
<blockquote>
<p>跟堆一样是被<strong>各个线程共享的内存区域</strong>，用于存储以被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然这个区域被虚拟机规范把方法区描述为堆的一个逻辑部分，但是它的别名叫非堆，用来与堆做一下区别。</p>
<p>方法区在虚拟机启动的时候创建。</p>
<p>方法区的容量可以是固定大小的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩。</p>
<p>方法区在实际内存空间中可以是不连续的。</p>
<p>Java虚拟机实现应当提供给程序员或者最终用户调节方法区初始容量的手段，对于可以动态扩展和收缩方法区来说，则应当提供调节其最大、最小容量的手段。</p>
<p>当方法区无法满足内存分配需求时就会抛OutOfMemoryError。</p>
</blockquote>
</li>
<li><p>运行时常量池（Runtime Constant Pool）</p>
<blockquote>
<p>它是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<p>Java虚拟机对Class文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p>
<p>既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>
</blockquote>
</li>
</ul>
<p>###2.hotspot虚拟机对象探秘<br>1.对象的创建</p>
<p>new-&gt;检查这个指令参数是否能在常量池中定位到一个类的引用符号-&gt;判断这个类是否被加载、解析、初始化过-&gt;加载检查通过后，分配内存(指针碰撞，空闲列表)</p>
<p>-&gt;对分配内存空间的动作进行同步处理（CAS配上失败重试、TLAB）-&gt;虚拟机需要将分配到的内存空间都初始化为零值-&gt;对对象进行必要的设置</p>
<p>2.对象的内存布局</p>
<p>还Hotspot虚拟机中，对象的内存中存储的布局分为3块区域：对象头（header）、实例数据（Instance Data）、对其填充（Padding） </p>
<p>Hotspot虚拟机的对象头包括两部分信息，第一部分用于存储自身运行时的数据，例如：哈希码、GC分代年龄、锁状态标识、线程持有锁、偏向线程id、偏向时间戳，这部分数据数据长度在32位和64位的虚拟机（未开启指针压缩）中分别为32bit和64bit，官方称为’Mark word’。对象需要存储的运行时的数据非常多，已经超出了32位、64位bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关额外的存储成本，考虑到虚拟机的空间效率，Mark work被设计成一个非固定的数据结构以便在极小空间内存储尽可能多的信息，他会根据对象状态复用自己的存储空间。<br>对象头的另一部分是类型指针，即对象指向他的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个Java数组，那在对象中还必须有一块用于记录数组长度的数据，因为虚拟机可通过普通 Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。 </p>
<p>接下来的实例数据是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的还是在子类中定义的，都需要记录下来。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。Hotspot虚拟机的分配策略是相同宽度的字段总是被分配到一起。在满足这个前提条件下，在父类中定义的变量会出现在子类之前。</p>
<p>3.对象的访问定位</p>
<ul>
<li>句柄</li>
</ul>
<p>如果使用句柄访问的话，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据的具体各自的地址信息。如图1所示。<br><img src="http://i.imgur.com/xF8cz3T.jpg" alt=""></p>
<ul>
<li>直接指针</li>
</ul>
<p>如果使用直接指针访问的话，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如图2所示。<br><img src="http://i.imgur.com/7mWuClk.jpg" alt=""></p>
<p>###3.outofmemoryerror异常<br>1.java 堆溢出<br>2.虚拟机栈本地方法溢出<br>3.方法区和运行时常量池溢出<br>4.本机直接内存溢出</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#自动内存管理机制&lt;/p&gt;
&lt;p&gt;##java内存区域与内存溢出异常&lt;/p&gt;
&lt;p&gt;###1.java虚拟机运行时数据区&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/9y9f9Z1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;程序计
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Ng机器学习notes1+weka相关算法实现</title>
    <link href="http://yoursite.com/2016/10/14/Ng%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0notes1-weka%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2016/10/14/Ng机器学习notes1-weka相关算法实现/</id>
    <published>2016-10-14T04:30:14.000Z</published>
    <updated>2016-11-02T17:22:06.217Z</updated>
    
    <content type="html"><![CDATA[<p>Andrew Ng的机器学习课程notes1.</p>
<p>参考链接：<a href="http://blog.csdn.net/qiao1245/article/details/50886247" target="_blank" rel="external">http://blog.csdn.net/qiao1245/article/details/50886247</a></p>
<p>主要内容是关于判别学习方法的，涉及到了梯度下降、随机梯度下降、最小二乘法、局部加权回归、极大似然原理、logistic regression、牛顿方法、广义线性模型、指数分布族。</p>
<p>##Ng机器学习笔记</p>
<p><strong>1.问题引入：房价预测</strong></p>
<p><img src="http://i.imgur.com/YVXqMDd.png" alt=""><br>我们可以将变量表示成X1，X2，然后结果表示为Y，那么Y和X之间存在一种映射关系，也就是说，我们可以通过X预测Y，假设二者之间关系是多元线性关系，形式上表述为：</p>
<p><img src="http://i.imgur.com/WhQcGmc.png" alt=""></p>
<p>H就是根据X对Y做出的估计，其中的参数θ是我们要求的量。<br>如何求得参数θ呢？我们可以利用损失函数的概念，损失函数表示了预测值与实际值之间的差距：</p>
<p><img src="http://i.imgur.com/b8rfDs0.png" alt=""></p>
<p>那么很显然，只要J（θ）最小化，那么θ就是最好的参数。那么我们下面就是使得J（θ）最小化，其中方法之一梯度下降方法。</p>
<p><strong>2.梯度下降</strong></p>
<p>什么是梯度？梯度是标量场中某一点上的梯度指向标量场增长最快的方向，梯度的长度是这个最大的变化率。因此，梯度方向是函数变化最快的地方。那么我们可以任意初始化θ，接下来就按照梯度方向进行调整θ只，就可以最快的到达最大值。 </p>
<p>可以得到更新θ规则，对于一个独立的样本，这种方法就是最小二乘法。 </p>
<p><img src="http://i.imgur.com/ovVDkP1.png" alt=""></p>
<p>扩展到M个样本，对J（θ）求偏导数，可以得到最终结果：<br><img src="http://i.imgur.com/aKxdpy0.png" alt=""><br>因此，梯度下降的过程就是不断地θ进行迭代，直到θ达到最大值为止<br><img src="http://i.imgur.com/3wQOxcE.png" alt=""><br>但是这样有一个很大的问题，就是每下降一步，就需要遍历整个数据集，这会导致巨大的计算量。因此，我们可以每次使用一条数据，就迭代一次，过程如下：<br><img src="http://i.imgur.com/tFXT2y1.png" alt=""><br>这样就会使得迭代过程并非一直是正向进行的，也就是可能会有向相反方向迭代的可能，但是总体还是向下的。这样还有一个问题，就是可能算法未必会收敛到最小值，而在最小值附近一直徘徊。但是最大的优点就是，快！</p>
<p>除了代数方法求得θ，我们还可以使用线性代数的方法直接求得θ参数，具体推导过程不再赘述，可以去看讲义，结果是：<br><img src="http://i.imgur.com/9bpMtTg.png" alt=""></p>
<p>这样虽然避免了计算，但是对矩阵求逆是比较慢的，而且这个方法要求X是满秩的，若不是满秩矩阵需要做处理。</p>
<p><strong>3.极大似然估计</strong></p>
<p>那么为什么采用平方和函数得到的θ就是最佳的呢？这里有对应的概率解释。对于一般的回归问题，我们可以将预测值和真实值之间表示为：<br><img src="http://i.imgur.com/H9SEMY1.png" alt=""></p>
<p><strong>4.局部加权回归</strong></p>
<p>有时候可能我们发现变量X和Y之间的关系并不是一种线性关系，但是在很小一段上，X和Y可以近似的看做线性关系，那么如何衡量这种关系呢？我们可以使用局部加权回归来解决这类问题，通过权重函数，我们可以距离目标值越远的点对整体影响越小。 </p>
<p>那么我们的问题可以化为：<br> <img src="http://i.imgur.com/cPk6OoJ.png" alt=""></p>
<p>其中，W可以表示为：<br><img src="http://i.imgur.com/7oueKN5.png" alt=""><br>这里面的τ被称为波长，用于控制权值随着距离变化的快慢。<br>那么我们像之前一样对问题进行求解。</p>
<p><strong>5.logistic回归</strong><br>有时候，我们的预测值并不是连续的，如满足伯努利分布，Y∈{0,1}，那么该怎么进行回归分析呢？<br>我们可以利用函数将连续值映射到0-1之间，一个函数就是： </p>
<p><img src="http://i.imgur.com/I20ojGR.png" alt=""></p>
<p><strong>6.牛顿方法</strong></p>
<p>除了梯度下降，还有一种牛顿方法可以对解空间进行搜索。示意图如下：<br><img src="http://i.imgur.com/NHm6GiT.png" alt=""></p>
<p>方法是先随机选一个点，求出该点的切线，延长它使之与 x 轴相<br>交，以相交时的 x 的值作为下一次迭代的值。<br>由于最大似然函数的性质，我们可以知道当导数为0时，求得θ最佳，那么我们可以得到更新规则：</p>
<p><img src="http://i.imgur.com/0ZTqRI2.png" alt=""></p>
<p>牛顿法的优点是收敛较快，但是有可能达不到最值。</p>
<p>##weka相关算法实现</p>
<p><strong>1.线性回归</strong></p>
<pre><code>weka.classifiers.functions.LinearRegression
Class for using linear regression for prediction. Uses the Akaike criterion for model selection, and is able to deal with weighted instances. 

 Valid options are: 
 -S &lt;number of selection method&gt;
  Set the attribute selection method to use. 1 = None, 2 = Greedy.
  (default 0 = M5&apos; method)

 -C
  Do not try to eliminate colinear attributes.

 -R &lt;double&gt;
  Set ridge parameter (default 1.0e-8).

 -minimal
  Conserve memory, don&apos;t keep dataset header and means/stdevs.
  Model cannot be printed out if this option is enabled. (default: keep data)

 -additional-stats
  Output additional statistics.

 -output-debug-info
  If set, classifier is run in debug mode and
  may output additional info to the console

 -do-not-check-capabilities
  If set, classifier capabilities are not checked before classifier is built
  (use with caution).

Version:$Revision: 12643 $Author:Eibe Frank (eibe@cs.waikato.ac.nz)Len Trigg (trigg@cs.waikato.ac.nz)
</code></pre><p><strong>2.逻辑回归</strong></p>
<p>Valid options are: </p>
<pre><code>-D
 Turn on debugging output.

-R &lt;ridge&gt;
 Set the ridge in the log-likelihood.

-M &lt;number&gt;
 Set the maximum number of iterations (default -1, until convergence).
</code></pre><p>参数比较少，其中-R用来调整迭代时θ对整个Cost函数的影响，默认是1E-8，-M是迭代的最大次数，如果指定为-1，则算法运行一直到收敛为止。<br>代码如下：</p>
<pre><code>class LogisticModel {

    public LogisticModel(Instances data) {
        String[] options={&quot;-M&quot;,20};
        Logistic model = new Logistic();
        try {
            model.setOptions(options);
            model.buildClassifier(data);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Andrew Ng的机器学习课程notes1.&lt;/p&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;http://blog.csdn.net/qiao1245/article/details/50886247&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http:
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>mysql中tinyint.smallint.int.bigint区别</title>
    <link href="http://yoursite.com/2016/10/13/mysql%E4%B8%ADtinyint-smallint-int-bigint%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2016/10/13/mysql中tinyint-smallint-int-bigint区别/</id>
    <published>2016-10-13T07:52:49.000Z</published>
    <updated>2016-11-02T17:21:54.339Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>tinyint<br>从 -2^7 (-128) 到 2^7 - 1 (123) 的整型数据。存储大小为 1 个字节。<br>unsigned 是从 0 到 255 的整型数据。<br>所以建表的时候 只能是tinyint(3),哪怕你建tinyint(100)，他最大还是3位这么多。</p>
</li>
<li><p>smallint<br>从 -2^15 (-32,768) 到 2^15 - 1 (32,767) 的整型数据。存储大小为 2 个字节。<br>unsigned 是从 0 到 65535 的整型数据。<br>所以建表的时候 只能是smallint(5),哪怕你建smallint(100)，他最大还是5位这么多。</p>
</li>
<li><p>int<br>从 -2^31 (-2,147,483,648) 到 2^31 - 1 (2,147,483,647) 的整型数据（所有数字）.存储大小为 4 个字节。<br>unsigned 是从 0 到 4294967296 的整型数据。<br>所以建表的时候 只能是int(10),哪怕你建int(100)，他最大还是10位这么多。</p>
</li>
<li><p>bigint<br>从 -2^63 (-9,223,372,036,854,775,808) 到 2^63-1 (9,223,372,036,854,775,807) 的整型数据（所有数字）。存储大小为 8 个字节。<br>unsigned 是(自己算吧)</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;tinyint&lt;br&gt;从 -2^7 (-128) 到 2^7 - 1 (123) 的整型数据。存储大小为 1 个字节。&lt;br&gt;unsigned 是从 0 到 255 的整型数据。&lt;br&gt;所以建表的时候 只能是tinyint(3),哪怕你建tinyint(1
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>面向对象系统分析与设计</title>
    <link href="http://yoursite.com/2016/10/06/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2016/10/06/面向对象系统分析与设计/</id>
    <published>2016-10-06T09:02:48.000Z</published>
    <updated>2016-10-06T09:30:40.429Z</updated>
    
    <content type="html"><![CDATA[<p>####系统分析设计方法：</p>
<ul>
<li>结构化方法</li>
<li>信息建模法</li>
<li>面向对象分析设计方法</li>
</ul>
<p>面向对象的分析（Object Oriented Analysis，OOA）强调的是在问题域内发现和描述对象（或概念）。</p>
<p>面向对象的设计（ Object Oriented Design ，OOD）强调的是定义软件对象以它们是如何协作以实现需求</p>
<p>####面向对象的优点：</p>
<ul>
<li>复用<br>通过继承、关联、封装等手段</li>
<li>应变<br>弹性应对需求变化</li>
<li>沟通<br>开发人员、用户、管理人员</li>
<li>市场<br>应付市场的变化</li>
<li>士气<br>员工的士气</li>
</ul>
<p>使用OMT方法的面向对象开发过程可分为5步：</p>
<ul>
<li>分析</li>
<li>系统设计</li>
<li>对象设计</li>
<li>编代码</li>
<li>测试</li>
</ul>
<p>分为下述5个活动 </p>
<ul>
<li>编写问题陈述 </li>
<li>建立对象模型 </li>
<li>建立动态模型 </li>
<li>建立功能模型</li>
<li>细化对象模型、动态模型和功能模型，并建立文档</li>
</ul>
<p>系统设计的步骤如下：</p>
<ul>
<li>将系统划分为子系统 </li>
<li>识别并发 </li>
<li>将子系统和任务分配给处理器 </li>
<li>选择实现数据存储的策略 </li>
<li>识别出全局资源，并确定控制访问全局资源的机制 </li>
<li>选择实现软件控制的方法 </li>
<li>考虑边界条件 </li>
<li>建立折衷的优先级</li>
</ul>
<p>宏过程包括下述5个活动:</p>
<p>（1）概念化（Conceptualization）：在这个活动中，建立核心需求。<br>（2）分析（Analysis）：在这个活动中，为所期望的行为建立模型。<br>（3）设计（Design）：在这个活动中，建立体系结构。<br>（4）进化（Evolution）：在这个活动中，形成实现。<br>（5）维护（Maintenance）：在这个活动中，管理软件的交付使用。</p>
<p>微过程由4个步骤组成：</p>
<p>（1）在给定的抽象层次上识别出类和对象。<br>（2）识别出这些类和对象的语义。<br>（3）识别出类间和对象间的关系。<br>（4）实现类和对象。</p>
<p>####软件过程</p>
<p>软件过程定义了软件开发、部署和维护的步骤</p>
<ul>
<li><p>迭代式开发 </p>
<p> 迭代式开发将软件开发过程分解为一系列小的，固定周期的(比如，4个星期)的小项目，每个小项目称为一个迭代。</p>
</li>
<li><p>统一过程 (Unified Process)</p>
</li>
</ul>
<p>一种采用OOA/D方法学开发项目的过程(Ivar Jacobson)。<br>一种流行的构造面向对象系统的迭代开发过程（JBR99）。</p>
<ul>
<li>敏捷UP( Agile UP ) </li>
</ul>
<p>引入了敏捷概念的UP,是UP的一个简集。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;####系统分析设计方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构化方法&lt;/li&gt;
&lt;li&gt;信息建模法&lt;/li&gt;
&lt;li&gt;面向对象分析设计方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面向对象的分析（Object Oriented Analysis，OOA）强调的是在问题域内发现和描述对象（或
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>机器学习weka（三）</title>
    <link href="http://yoursite.com/2016/09/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0weka%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2016/09/29/机器学习weka（三）/</id>
    <published>2016-09-29T14:12:39.000Z</published>
    <updated>2016-11-02T17:24:27.425Z</updated>
    
    <content type="html"><![CDATA[<p><strong>模型序列化/持久化存储和加载</strong></p>
<p>有很多时候，你在构建了一个模型并完成调优后，你很可能会想把这个模型存入到磁盘中，免得下次再重新训练。尤其是神经网络、SVM等模型训练时间非常长，重新训练非常浪费时间。那么怎么持久化模型呢？<br>其实既然模型也是一个Java对象，那我就按照JAVA的序列化和反序列化方法保存模型对象即可。</p>
<p>以J48为例，进行序列化和存取</p>
<p>序列化：</p>
<pre><code>public static void persistModel(J48 model, String ModelPath) {
        ObjectOutputStream oos = null;
        try {
            oos = new ObjectOutputStream(
            new FileOutputStream(ModelPath));
            oos.writeObject(model);
            oos.flush();
            oos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
</code></pre><p>重新加载：</p>
<pre><code>public static J48 reloadPersistModel(String ModelPath) {
        ObjectInputStream ois = null;
        try {
            ois = new ObjectInputStream(
            new FileInputStream(new File(ModelPath)));
            J48 model = (J48) ois.readObject();
            return model;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;模型序列化/持久化存储和加载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有很多时候，你在构建了一个模型并完成调优后，你很可能会想把这个模型存入到磁盘中，免得下次再重新训练。尤其是神经网络、SVM等模型训练时间非常长，重新训练非常浪费时间。那么怎么持久化模型呢？&lt;br&gt;
    
    </summary>
    
      <category term="weka" scheme="http://yoursite.com/categories/weka/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="weka" scheme="http://yoursite.com/tags/weka/"/>
    
  </entry>
  
  <entry>
    <title>机器学习weka（二）</title>
    <link href="http://yoursite.com/2016/09/29/weka%E5%AD%A6%E4%B9%A02/"/>
    <id>http://yoursite.com/2016/09/29/weka学习2/</id>
    <published>2016-09-29T14:04:00.000Z</published>
    <updated>2016-11-02T17:24:08.887Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.weka分类/回归模型构建与评价</strong></p>
<p>以最简单的决策树算法为例，在Weka中，决策树算法的实现是J48类，因此我们只需要创建J48对象就可以创建决策树。整个过程可以分为如下步骤： </p>
<p><strong>数据准备</strong></p>
<p>我们要做的就是加载数据，然后使用Filter对数据进行一定的操作，满足特定算法的需求。具体的将在决策树中讲解。</p>
<p><strong>模型配置</strong></p>
<p>在模型准备前，要对模型进行适当的配置，Weka中是通过传入Options数组来实现的，然后使用模型的setOptions(options)方法将模型配置信息传入</p>
<p><strong>模型学习</strong></p>
<p>模型学习过程就是使用训练数据对模型进行训练，在Weka中只需要调用模型的buildClassifier(data)方法即可。<br>上述三个过程可以用以下代码表示：</p>
<pre><code>class CARTModel {
    public CARTModel(Instances data) throws Exception{
        J48 model = new J48();
        String[] options = {&quot;-M&quot;,&quot;5&quot;,&quot;-R&quot;};
        model.setOptions(options);
        model.buildClassifier(data);
    }
}
</code></pre><p><strong>模型评价</strong></p>
<p>通过创建Evaluation对象来实现评价，具体代码如下：</p>
<pre><code>Evaluation eval = new Evaluation(testData);
 eval.crossValidateModel(model, trainSet, 10, new Random(1));
 System.out.println(eval.toSummaryString(&quot;\nResult&quot;, false));
 System.out.println(eval.toClassDetailsString());
</code></pre><p><strong>2.评价evaluation介绍</strong></p>
<p><strong>基本指标</strong></p>
<p>1、 FN：False Negative,被判定为负样本，但事实上是正样本。 </p>
<p>2、 FP：False Positive,被判定为正样本，但事实上是负样本。 </p>
<p>3、TN：True Negative,被判定为负样本，事实上也是负样本。 </p>
<p>4、TP：True Positive,被判定为正样本，事实上也是证样本。</p>
<p>5、precesion：查准率<br>即在检索后返回的结果中，真正正确的个数占整个结果的比例。precesion = TP/(TP+FP) 。 </p>
<p>6、 recall：查全率<br>即在检索结果中真正正确的个数 占整个数据集（检索到的和未检索到的）中真正正确个数的比例。recall = TP/(TP+FN)即，检索结果中，你判断为正的样本也确实为正的，以及那些没在检索结果中被你判断为负但是事实上是正的（FN）。</p>
<p>7、F-Measure<br>是Precision和Recall加权调和平均<br>P和R指标有时候会出现的矛盾的情况，这样就需要综合考虑他们，最常见的方法就是F-Measure（又称为F-Score）。 </p>
<p>8、MCC 马修斯相关系数<br>衡量不平衡数据集的指标比较好。</p>
<p><strong>ROC曲线</strong></p>
<p>ROC曲线的横坐标为false positive rate（FPR），纵坐标为 true positive rate（TPR）<br>当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变。根据每个测试样本属于正样本的概率值从大到小排序，依次将 “Score”值作为阈值threshold，当测试样本属于正样本的概率 大于或等于这个threshold时，认为它为正样本，否则为负样本。 </p>
<p><strong>PRC曲线</strong></p>
<p>在正负样本分布得极不均匀(highly skewed datasets)的情况下，PRC比ROC能更有效地反应分类器的好坏。 </p>
<p><strong>其他指标</strong></p>
<p>1、kappa statics Kappa<br>值即内部一致性系数(inter-rater,coefficient of internal consistency)，是作为评价判断的一致性程度的重要指标。取值在0～1之间。Kappa≥0.75两者一致性较好；0.75&gt;Kappa≥0.4两者一致性一般；Kappa&lt;0.4两者一致性较差。</p>
<p>2、Mean absolute error 和 Root mean squared error<br>平均绝对误差和均方根误差，用来衡量分类器预测值和实际结果的差异，越小越好。</p>
<p>3、Relative absolute error 和 Root relative squared error<br>相对绝对误差和相对均方根误差，有时绝对误差不能体现误差的真实大小，而相对误差通过体现误差占真值的比重来反映误差大小。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1.weka分类/回归模型构建与评价&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以最简单的决策树算法为例，在Weka中，决策树算法的实现是J48类，因此我们只需要创建J48对象就可以创建决策树。整个过程可以分为如下步骤： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据准备&lt;/s
    
    </summary>
    
      <category term="weka" scheme="http://yoursite.com/categories/weka/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="weka" scheme="http://yoursite.com/tags/weka/"/>
    
  </entry>
  
  <entry>
    <title>机器学习weka（一）</title>
    <link href="http://yoursite.com/2016/09/29/weka1/"/>
    <id>http://yoursite.com/2016/09/29/weka1/</id>
    <published>2016-09-29T12:39:32.000Z</published>
    <updated>2016-11-02T17:23:59.960Z</updated>
    
    <content type="html"><![CDATA[<p>###机器学习weka（一）<br><a id="more"></a></p>
<p>##1.Instances</p>
<p>Instances对象实例化后，就存储了所有数据，同时也附带了很多数据属性，简单来说，你可以认为Instances就像一个电子表格，存储了你所加载的数据。 </p>
<p>Instances实例化有很多方式，在这里我介绍三种方式：<br>1.通过文件加载</p>
<pre><code>Instances(java.io.Reader reader) 
Reads an ARFF file from a reader, and assigns a weight of one to each instance.

Instances(java.io.Reader reader, int capacity) 
Deprecated. instead of using this method in conjunction with the readInstance(Reader) method, one should use the ArffLoader or DataSource class instead.

Instances data = new Instances( new BufferedReader(new FileReader(&quot;/Path/data.arff&quot;)));
</code></pre><p>2.使用DataSource从文件中加载数据 </p>
<pre><code>DataSource source = new DataSource(&quot;/some/where/data.arff&quot;);
Instances data = source.getDataSet();
</code></pre><p>3.从数据库实例化Instances对象</p>
<pre><code>InstanceQuery query= new InstanceQuery();
query.setDebug(true);
query.setUsername(&quot;C##TEST&quot;);
query.setPassword(&quot;test&quot;);
query.setDatabaseURL(&quot;jdbc:oracle:thin:@127.0.0.1:1521:ORCL&quot;);
String sql=&quot;SELECT * FROM (SELECT MDI_READING , MDI_TS from M_FS_DB_INTERVAL where  CST_ID= 5695 ) where rownum &lt; 10000&quot;;
query.setQuery(sql);
Instances train=query.retrieveInstances();
</code></pre><p>4.自己构造一个instances</p>
<pre><code>Creates an empty set of instances. Uses the given attribute information. Sets the capacity of the set of instances to 0 if its negative. Given attribute information must not be changed after this constructor has been used.Parameters:name the name of the relationattInfo the attribute informationcapacity the capacity of the setThrows:IllegalArgumentException - if attribute names are not unique

Instances(java.lang.String name, java.util.ArrayList&lt;Attribute&gt; attInfo, int capacity) 
Creates an empty set of instances.
</code></pre><p>根据构造方法我们需要创建一个attInfo对象。</p>
<pre><code>ArrayList&lt;Attribute&gt; atts = new ArrayList&lt;Attribute&gt;();
Attribute attribute1 = new Attribute(&quot;ID&quot;);
Attribute attribute2 = new Attribute(&quot;District&quot;);
Attribute attribute3 = new Attribute(&quot;CountryCode&quot;);
Attribute attribute4 = new Attribute(&quot;Population&quot;);
atts.add(attribute1);
atts.add(attribute2);
atts.add(attribute3);
atts.add(attribute4);
</code></pre><p>构建instances对象</p>
<pre><code>Instances df = new Instances(&quot;Data&quot;, atts, 0);
</code></pre><p>构建instance对象</p>
<pre><code>Create empty instance with three attribute values 
Instance inst = new DenseInstance(3); 
// Set instance&apos;s values for the attributes &quot;length&quot;, &quot;weight&quot;, and &quot;position&quot;
inst.setValue(length, 5.3); 
inst.setValue(weight, 300); 
inst.setValue(position, &quot;first&quot;); 
// Set instance&apos;s dataset to be the dataset &quot;race&quot; 
inst.setDataset(instances); 
</code></pre><p>instances对象添加instance值</p>
<pre><code>instances.add(inst);
</code></pre><p>##2.Attribute</p>
<p>1.介绍</p>
<p>attribute指的是Weka中数据的属性，一般就是表明数据集信息，数据每一列的性质等。之前讲过的Weka数据格式ARFF其实头信息包含的就是数据的Attribute信息。之前讲的Weka的数据存储方式Instances也有Attribute属性。<br>Attribute属性主要分以下几类:</p>
<pre><code>numeric: This type of attribute represents a floating-point number. 
         就是代表连续的，浮点数变量，如气温。
nominal: This type of attribute represents a fixed set of nominal values. 
         指的是离散的，刻意被划分为几类的变量，如户口类型。
string: This type of attribute represents a dynamically expanding set of nominal values. Usually used in text classification. 
         指的该列内容是文本，一般用于文本挖掘。
date: This type of attribute represents a date, internally represented as floating-point number storing the milliseconds since January 1, 1970, 00:00:00 GMT. The string representation of the date must be ISO-8601 compliant, the default is yyyy-MM-dd&apos;T&apos;HH:mm:ss. 
         指的该列数据代表日期，要按照规范格式写。
relational: This type of attribute can contain other attributes and is, e.g., used for representing Multi-Instance data. (Multi-Instance data consists of a nominal attribute containing the bag-id, then a relational attribute with all the attributes of the bag, and finally the class attribute.) 
    用来实现其他类型的数据。
</code></pre><p>2.attribute的创建</p>
<pre><code>// Create numeric attributes &quot;length&quot; and &quot;weight&quot; 
Attribute length = new Attribute(&quot;length&quot;); 
Attribute weight = new Attribute(&quot;weight&quot;); 
// Create list to hold nominal values &quot;first&quot;, &quot;second&quot;, &quot;third&quot; 
List my_nominal_values = new ArrayList(3); 
my_nominal_values.add(&quot;first&quot;); 
my_nominal_values.add(&quot;second&quot;); 
my_nominal_values.add(&quot;third&quot;); 
// Create nominal attribute &quot;position&quot; 
Attribute position = new Attribute(&quot;position&quot;, my_nominal_values);
</code></pre><p>##3.Filter（数据预处理）</p>
<p>1.什么是数据预处理？</p>
<p>加载完毕数据集后，还是不能直接进行数据挖掘模型的训练和学习，必须要进行数据预处理，数据预处理一般指的是以下四个方面：数据清理，数据集成，数据变换，数据归约等。</p>
<ul>
<li><p>①数据清理<br>数据清理例程通过填写缺失的值、光滑噪声数据、识别或删除离群点并解决不一致性来“清理”数据。主要是达到如下目标：格式标准化，异常数据清除，错误纠正，重复数据的清除。 </p>
</li>
<li><p>②数据集成<br>数据集成例程将多个数据源中的数据结合起来并统一存储，建立数据仓库的过程实际上就是数据集成。 </p>
</li>
<li><p>③数据变换<br>通过平滑聚集，数据概化，规范化等方式将数据转换成适用于数据挖掘的形式。 </p>
</li>
<li><p>④数据归约<br>数据挖掘时往往数据量非常大，在少量数据上进行挖掘分析需要很长的时间，数据归约技术可以用来得到数据集的归约表示，它小得多，但仍然接近于保持原数据的完整性，并结果与归约前结果相同或几乎相同。<br>这些预处理都可以使用Weka的Filter来实现。Weka的Filter作用是将一个Instances输入后，通过特定的数据清洗过程，将清洗好的Instances输出，也就是说，Filter处理的维度是在Instances层面上进行的。你也可以通过Filter的组合来实现复杂的数据处理。</p>
</li>
</ul>
<p>Filter提供的功能<br>FIlter功能还是比较强大的，但是Filter分为非监督学习和监督学习两种过滤器，分别属于weka.filters.unsupervised.attribute和weka.filters.unsupervised.attribute，至于监督学习和非监督学习，简单理解就是看输入数据是否有标签（label）。输入数据有标签，则为有监督学习，没标签则为无监督学习。这两种方式下的过滤器是不一样的，使用时一定要注意。<br>非监督学习包下的方法比较多，先讲解一下&gt; weka.filters.unsupervised.attribute主要方法的含义： </p>
<blockquote>
<p>1.Add<br>为数据库添加一个新的属性，新的属性将会包含所有缺失值。</p>
<p>2.AddExpression<br>新增一个属性，该属性由现有属性通过设定的表达式计算得出。支持+, -, *, /, ^, log, abs, cos, exp, sqrt, floor, ceil, rint, tan, sin。现有属性由a+索引值构成。 </p>
<p>3.AddNoise<br>只对名义属性有效，依照一定比例修改值。 </p>
<p>4.Center<br>将数值化属性的平均化为0。 </p>
<p>5.ChangeDateFormat<br>修改数据格式 </p>
<p>6.Discretize<br>简单划分的离散化处理。参数： </p>
<p>7.MathExpression<br>功能和AddExpression类似，不过支持的运算更多，特别是MAX和MIN的支持特别有用。所有支持运算符如下：+, -, *, /, pow, log,abs, cos, exp, sqrt, tan, sin, ceil, floor, rint, (, ),A,MEAN, MAX, MIN, SD, COUNT, SUM, SUMSQUARED, ifelse </p>
<p>8.Reorder<br>重新排列属性，输入2-last，1可以让第一项排到最后，如果输入1,3,5的话…其他项就没有了 </p>
<p>9.Standardize<br>这个和Center功能大致相同，多了一个标准化单位变异数 </p>
<p>10.StringToNominal<br>将String型转化为Nominal型</p>
</blockquote>
<p>然后再讲一下weka.filters.unsupervised.instance包下的主要方法和含义： </p>
<ul>
<li>1.NonSparseToSparse 将所有输入转为稀疏格式 </li>
<li>2.Normalize 规范化整个实例集 </li>
<li>3.RemoveFolds 交叉验证，不支持分层，如果需要的话使用监督学习中的方法 </li>
<li>4.RemoveRange  移除制定范围的实例，化为NaN </li>
<li>5.Resample  随机抽样，从现有样本产生新的小样本 </li>
<li>6.SubsetByExpression 根据规则进行过滤，支持逻辑运算，向上取值，取绝对值等等</li>
</ul>
<p>监督学习下虽然方法比较少，但是思路有所不同，主要是在有标签的情况下，很多方法诸如抽样就必须考虑不同数据分类的比例</p>
<pre><code>//假设已经有一个数据集tempData
Normalize normalize = new Normalize();
String[] normalOptions = new String[]{&quot;-S&quot;,&quot;2.0&quot;,&quot;-T&quot;,&quot;-1.0&quot;};
normalize.setOptions(normalOptions);
normalize.setInputFormat(tempData);
newData = Filter.useFilter(tempData,normalize);
</code></pre><p>2.采样</p>
<p>数据预处理中，有一个原理很简单但是非常重要的部分：采样。良好的采样可以让数据集变得平衡，会大大的提高预测和分类的效果。<br>采样是很复杂的一个领域，背后涉及到数据的分布/数据的性质等很多内容。常见的采样有： </p>
<ul>
<li>Simple Random Sampling(简单随机采样)， </li>
<li>OfflineSampling(离线等可能K采样)， </li>
<li>Online Sampling(在线等可能K采样)， </li>
<li>Ratio-based Sampling(等比例随机采样)， </li>
<li>Acceptance-RejectionSampling(接受-拒绝采样)， </li>
<li>Importance Sampling(重要性采样)， </li>
<li>MCMC(MarkovChain Monte Carlo 马尔科夫蒙特卡罗采样算法)。</li>
</ul>
<p>Filter支持多种采样方式，其中有监督的采样比较复杂，因此主要讲解有监督学习采样方法。Filter中的Resample采样就是简单的有放回抽样。</p>
<pre><code>Resample

  Open Declaration   weka.filters.supervised.instance.Resample


Produces a random subsample of a dataset using either sampling with replacement or without replacement.
 The original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled. 

 Valid options are: 


 -S &lt;num&gt;
  Specify the random number seed (default 1)
  指定随机数种子，随机数种子相同，则采样结果相同。

 -Z &lt;num&gt;
  The size of the output dataset, as a percentage of
  the input dataset (default 100)
  指定采样数据占整个数据的比例。

 -B &lt;num&gt;
  Bias factor towards uniform class distribution.
  0 = distribution in input data -- 1 = uniform distribution.
  (default 0)
 是否按照原来数据类别的分布分层抽样

 -no-replacement
  Disables replacement of instances
  (default: with replacement)

 -V
  Inverts the selection - only available with &apos;-no-replacement&apos;.

Version:$Revision: 11310 $Author:Len Trigg (len@reeltwo.com)FracPete (fracpete at waikato dot ac dot nz)Eibe Frank
</code></pre><p>使用Resample进行采样是比较简单的，下面是一个例子：</p>
<pre><code>public static Instances BoostrapSample(Instances data) {
        String[] options = {&quot;-S&quot;,1};
        Resample convert = new Resample();
        try {
            convert.setOptions(options);
            convert.setInputFormat(data);
            data = Filter.useFilter(data, convert);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return data;
    }
</code></pre><p>SMOTE采样<br>随机采样比较简单，其实Weka还支持一种附加的采样方法，在Weka3.6版本以下，这个功能嵌入在Weka包里，Weka3.7版本开始，这个功能需要额外的第三方包的支持，这种采样就是SMOTE采样。<br>SMOTE算法的思想是合成新的少数类样本，合成的策略是对每个少数类样本a，从它的最近邻中随机选一个样本b，然后在a、b之间的连线上随机选一点作为新合成的少数类样本。 这是一种过采样方法，通过制造更多模拟的少数类样本来实现各个样本之间的平衡。</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;nz.ac.waikato.cms.weka&lt;/groupId&gt;
    &lt;artifactId&gt;SMOTE&lt;/artifactId&gt;
    &lt;version&gt;1.0.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>SMOTE采样实现代码如下：</p>
<pre><code>public static Instances SMOTESample(Instances data,int normalElemFlag) {
        SMOTE convert = new SMOTE();
        int seed = (int) (Math.random() * 10);
        String[] options = {&quot;-S&quot;, String.valueOf(seed), &quot;-P&quot;, &quot;100.0&quot;, &quot;-K&quot;, &quot;5&quot;};
        Instances SmoteInstances = null;
        try {
            convert.setOptions(options);
            convert.setInputFormat(data);
            SmoteInstances = Filter.useFilter(data, convert);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return SmoteInstances;
    }
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###机器学习weka（一）&lt;br&gt;
    
    </summary>
    
      <category term="weka" scheme="http://yoursite.com/categories/weka/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="weka" scheme="http://yoursite.com/tags/weka/"/>
    
  </entry>
  
  <entry>
    <title>Object类有哪些方法</title>
    <link href="http://yoursite.com/2016/09/25/Object%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/09/25/Object类有哪些方法/</id>
    <published>2016-09-25T15:52:26.000Z</published>
    <updated>2016-11-02T17:22:23.073Z</updated>
    
    <content type="html"><![CDATA[<p>ps：上周面试中科院，被问到object类有哪些方法。当时一脸懵逼没有反应过来，做以下记录。</p>
<pre><code>clone();
equals();
finalize();
getClass();
notify(),notifyAll();
hashCode();
toString();
wait();
</code></pre><p>摘要如下：</p>
<pre><code>protected  Object    clone() //创建并返回此对象的一个副本。
boolean    equals(Object obj) //指示某个其他对象是否与此对象“相等”。
protected  void    finalize() //当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。
Class&lt;? extends Object&gt;    getClass() //返回一个对象的运行时类。
int    hashCode() //返回该对象的哈希码值。
void    notify() //唤醒在此对象监视器上等待的单个线程。
void    notifyAll() //唤醒在此对象监视器上等待的所有线程。
String    toString()  //返回该对象的字符串表示。
void    wait() //导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。
void    wait(long timeout) //导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。
void    wait(long timeout, int nanos) //导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ps：上周面试中科院，被问到object类有哪些方法。当时一脸懵逼没有反应过来，做以下记录。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clone();
equals();
finalize();
getClass();
notify(),notifyAll();
hashCode()
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java多线程</title>
    <link href="http://yoursite.com/2016/09/25/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/09/25/java多线程/</id>
    <published>2016-09-25T15:43:30.000Z</published>
    <updated>2016-11-02T17:19:46.585Z</updated>
    
    <content type="html"><![CDATA[<p>线程和进程有什么区别？</p>
<p>答：一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。</p>
<p>如何在Java中实现线程？</p>
<p>答：<br>创建线程有两种方式：</p>
<ol>
<li>一、继承 Thread 类，扩展线程。</li>
<li>二、实现 Runnable 接口。</li>
</ol>
<p>启动一个线程是调用run()还是start()方法？</p>
<p>答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。</p>
<p>Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</p>
<ul>
<li>sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。</li>
<li>wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</li>
</ul>
<p>线程的sleep()方法和yield()方法有什么区别？</p>
<p>答：</p>
<ul>
<li>① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</li>
<li>② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；</li>
<li>③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；</li>
<li>④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。</li>
</ul>
<p>请说出与线程同步以及线程调度相关的方法。<br>答：</p>
<ul>
<li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</li>
<li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；</li>
<li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；</li>
<li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线程和进程有什么区别？&lt;/p&gt;
&lt;p&gt;答：一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>oracle</title>
    <link href="http://yoursite.com/2016/09/25/oracle/"/>
    <id>http://yoursite.com/2016/09/25/oracle/</id>
    <published>2016-09-25T14:14:27.000Z</published>
    <updated>2016-11-02T17:22:38.866Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>很少使用oracle，记录两个问题。</p>
<p>###1.在Maven仓库中添加Oracle JDBC驱动</p>
<p>由于Oracle授权问题，Maven不提供Oracle JDBC driver，为了在Maven项目中应用Oracle JDBC driver,必须手动添加到本地仓库。</p>
<p>1.获取oracle jdbc driver</p>
<ol>
<li>通过Oracle官方网站下载相应版本： <a href="http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html" target="_blank" rel="external">http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html</a></li>
<li>通过Oracle的安装目录获得，位置在“{ORACLE_HOME}\jdbc\lib\ojdbc14.jar</li>
</ol>
<p>2.安装到本地仓库</p>
<pre><code>mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=12.1.0.2 -Dpackaging=jar -Dfile=D:\Document_x64\Downloads\ojdbc14.jar
</code></pre><p>3.pom文件中添加引用</p>
<pre><code>&lt;dependency&gt;
&lt;groupId&gt;com.oracle&lt;/groupId&gt;
&lt;artifactId&gt;ojdbc7&lt;/artifactId&gt;
&lt;version&gt;12.1.0.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>###2. “ORA-00942: 表或视图不存在 “的原因和解决方法</p>
<p>产生的原因：<br>Oracle 是大小写敏感的，我们创自己写Sql脚本创建表的时候Oracle会自动将我们的表名，字段名转成大写,</p>
<pre><code>create table T_WindRadar  (
   wr_id                VARCHAR2(64)                    not null,
   wr_reciveTime        DATE,
   wr_image             BLOB,
   constraint PK_T_WINDRADAR primary key (wr_id)
);
</code></pre><p>但是 Oracle 同样支持”” 语法，将表名或字段名加上””后，Oracle不会将其转换成大写。</p>
<pre><code>create table &quot;T_WindRadar&quot;  (
   &quot;wr_id&quot;                VARCHAR2(64)                    not null,
   &quot;wr_reciveTime&quot;        DATE,
   &quot;wr_image &quot;            BLOB,
   constraint PK_T_WINDRADAR primary key (wr_id)
);
</code></pre><p>如果加上了””,那么我们采用一般的SQL语句查询则会产生“ORA-00942: 表或视图不存在 ”，因此SQL脚本中需要将表名也加上””。</p>
<pre><code>select * from  &quot;T_WindRadar&quot;;
</code></pre><p>这种情况在我们手写SQL的时候一般不会发生，但是我们使用powerdesigner设计数据库的时候，由于不注意会经常出现此类问题，因为Powerdesigner生成的SQL文件默认是加””的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;很少使用oracle，记录两个问题。&lt;/p&gt;
&lt;p&gt;###1.在Maven仓库中添加Oracle JDBC驱动&lt;/p&gt;
&lt;p&gt;由于Oracle授权问题，Maven不提供Oracle JDBC driver，为了在Maven项目中应用Ora
    
    </summary>
    
      <category term="oracle" scheme="http://yoursite.com/categories/oracle/"/>
    
    
      <category term="oracle" scheme="http://yoursite.com/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>机器学习</title>
    <link href="http://yoursite.com/2016/09/25/k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2016/09/25/k-近邻算法/</id>
    <published>2016-09-25T05:39:12.000Z</published>
    <updated>2016-11-02T17:21:25.220Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>##k-近邻算法</p>
<p>####1.工作原理<br>存在一个样本数据集合，也成为训练样本集，并且样本集中每个数据都存在标签。加我们知道样本集中荷每一条数据玉所属分类之间的关系，输入没有标签的数据，将新数据的每个特征和样本数据进行比较然后算法提取出样本集中特征醉相思的数据的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据。最后，选择开个醉相思数据中出现次数最多的分类，作为新数据的分类。</p>
<p>####2.伪代码</p>
<ol>
<li>计算已知类别数据器中点与当前点之间的距离；</li>
<li>按照距离递增次序排序</li>
<li>选择与当前距离最小的k个点</li>
<li>确定前k个点所在类别的出现频率</li>
<li>返回前k个点出现的频率最高的类别作为当前点的预测分类</li>
</ol>
<p>##决策树</p>
<p>####1.优缺点</p>
<ul>
<li>优点：计算复杂度不高，对中间值的确实不敏感。可以处理不想管特征数据。</li>
<li>缺点：过度匹配问题</li>
</ul>
<p>##基于概率论的分类方法：朴素贝叶斯</p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;##k-近邻算法&lt;/p&gt;
&lt;p&gt;####1.工作原理&lt;br&gt;存在一个样本数据集合，也成为训练样本集，并且样本集中每个数据都存在标签。加我们知道样本集中荷每一条数据玉所属分类之间的关系，输入没有标签的数据，将新数据的每个特征和样本数据进行比
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
