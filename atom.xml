<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lyp&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-10-23T12:45:30.575Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>兰天震的设计</title>
    <link href="http://yoursite.com/2016/10/23/%E5%85%B0%E5%A4%A9%E9%9C%87%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2016/10/23/兰天震的设计/</id>
    <published>2016-10-23T12:45:12.000Z</published>
    <updated>2016-10-23T12:45:30.575Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://i.imgur.com/x94fo9Q.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://i.imgur.com/x94fo9Q.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解JVM笔记四-虚拟机性能监控与故障处理工具</title>
    <link href="http://yoursite.com/2016/10/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E7%AC%94%E8%AE%B0%E5%9B%9B/"/>
    <id>http://yoursite.com/2016/10/21/深入理解JVM笔记四/</id>
    <published>2016-10-21T08:22:24.000Z</published>
    <updated>2016-10-21T09:29:40.320Z</updated>
    
    <content type="html"><![CDATA[<p>###jdk命令行工具</p>
<p>1.jps<br>虚拟机进程状态工具</p>
<pre><code>常用的几个参数：
-l   输出Java应用程序的main class的完整包

-q 仅显示pid，不显示其它任何相关信息

-m 输出传递给main方法的参数

-v 输出传递给JVM的参数。在诊断JVM相关问题的时候，这个参数可以查看JVM相关参数的设置
</code></pre><p>2.jstat</p>
<p>虚拟机统计信息监视工具</p>
<pre><code>C:\Program Files\Java\jdk1.8.0_91\bin&gt;jstat -gcutil 1676
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT
  0.00 100.00  53.66  80.08  91.20  81.37     72    2.443     0    0.000    2.443

C:\Program Files\Java\jdk1.8.0_91\bin&gt;jstat -gc 1676
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
 0.0   6144.0  0.0   6144.0 83968.0  53248.0   172032.0   137768.9  173184.0 157951.9 23168.0 18851.1     72    2.443   0      0.000    2.443
</code></pre><blockquote>
<p>堆内存 = 年轻代 + 年老代 + 永久代</p>
<p>年轻代 = Eden区 + 两个Survivor区（From和To）</p>
<p>S0C、S1C、S0U、S1U：Survivor 0/1区容量（Capacity）和使用量（Used）</p>
<p>EC、EU：Eden区容量和使用量</p>
<p>OC、OU：年老代容量和使用量</p>
<p>PC、PU：永久代容量和使用量</p>
<p>YGC、YGCT：年轻代GC次数和GC耗时</p>
<p>FGC、FGCT：Full GC次数和Full GC耗时</p>
<p>GCT：GC总耗时</p>
</blockquote>
<p><img src="http://i.imgur.com/uQntEKD.png" alt=""></p>
<p>###3  jinfo   </p>
<p>java配置信息工具</p>
<p>观察运行中的java程序的运行环境参数：参数包括Java System属性和JVM命令行参数</p>
<p>实例：jinfo 2083</p>
<p>其中2083就是java进程id号，可以用jps得到这个id号。</p>
<p>输出内容太多了，不在这里一一列举，大家可以自己尝试这个命令。</p>
<p>###4 jmap  Java内存映像工具<br> jmap（Memory Map）和  jhat（Java Heap Analysis Tool）<br> jmap用来查看堆内存使用状况，一般结合jhat使用。</p>
<p>###5.jhat 虚拟机堆转储快照分析工具</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###jdk命令行工具&lt;/p&gt;
&lt;p&gt;1.jps&lt;br&gt;虚拟机进程状态工具&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;常用的几个参数：
-l   输出Java应用程序的main class的完整包

-q 仅显示pid，不显示其它任何相关信息

-m 输出传递给main方法的参数

-
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM笔记三</title>
    <link href="http://yoursite.com/2016/10/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
    <id>http://yoursite.com/2016/10/21/深入理解JVM笔记三/</id>
    <published>2016-10-21T06:30:38.000Z</published>
    <updated>2016-10-21T08:22:39.676Z</updated>
    
    <content type="html"><![CDATA[<p>内存分配策略</p>
<p>###1.对象有现在eden区分配。</p>
<p>大多数情况下，对象在新生代eden区中分配，当Eden区没有足够的空间分配，虚拟机将发起一次minor GC。<br>虚拟机提供<code>-XX：+PrintGCDetails</code>这个日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并在进程退出的时候输出当前的内存各区域分配的情况。</p>
<pre><code>public class aa{
        /**
         * -verbose:gc -Xms20M -Xms20M -Xmn10M -XX:+PrintGCDetails 
         * -XX:SurvivorRatio=8
         * 
         */
public static final int _1MB =1024*1024;
        public static void main(String[] args) {

            byte[] allocation1,allocation2,allocation3,allocation4;
            allocation1= new byte[2*_1MB];
            allocation2= new byte[2*_1MB];
            allocation3= new byte[2*_1MB];
            allocation4= new byte[3*_1MB];
        }
}
[GC (Allocation Failure) [PSYoungGen: 7128K-&gt;648K(9216K)] 7128K-&gt;6800K(19456K), 0.0030424 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (Ergonomics) [PSYoungGen: 648K-&gt;0K(9216K)] [ParOldGen: 6152K-&gt;6673K(27648K)] 6800K-&gt;6673K(36864K), [Metaspace: 2654K-&gt;2654K(1056768K)], 0.0070118 secs] [Times: user=0.06 sys=0.00, real=0.01 secs] 
Heap
 PSYoungGen      total 9216K, used 3154K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 38% used [0x00000000ff600000,0x00000000ff914930,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
 ParOldGen       total 27648K, used 6673K [0x0000000081c00000, 0x0000000083700000, 0x00000000ff600000)
  object space 27648K, 24% used [0x0000000081c00000,0x0000000082284408,0x0000000083700000)
 Metaspace       used 2660K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 288K, capacity 386K, committed 512K, reserved 1048576K
</code></pre><p>###2.对象直接进入老年代</p>
<p>虚拟机提供一个-XX:pertenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在eden取以及两个survivor区之间发生大量的内存复制。（新生代采用复制算法收集内存）</p>
<pre><code>public class aa{
        /**
         * -verbose:gc -Xms20M -Xms20M -Xmn10M -XX:+PrintGCDetails -XX:PertenureSizeThreshold=3145728
         * -XX:SurvivorRatio=8
         * 
         */
public static final int _1MB =1024*1024;
        public static void main(String[] args) {

            byte[] allocation4;
            allocation4= new byte[4*_1MB];
        }
}
</code></pre><p>###3.长期存活的对象将直接进入老年代</p>
<p>虚拟机给每个对象定义了一个age年龄计数器。如果对象在eden出生并经历了第一次minor gc仍然活着的话，并且能够被survivor容纳，警备移动大survivor空间，并且对象的年龄设为1.对于survivor中没熬过一次minor gc，年龄就增加1.当她的年龄增加到一定程度，默认是15，就会被净胜到老年代。对象净胜到老年代的年龄阈值通过参数-XX:MaxTenuringThreshold设置。</p>
<p>###4.动态对象年龄判定</p>
<p>为了更好地适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到阈值才能够到老年代，瑞国survivor中相同年龄所有对象的大小纸盒大于survivor空间的一般，年龄大于或等于改年龄的对象就可以进入老年代了。</p>
<p>###5.空间分配担保</p>
<p>在发生minor gc之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果这个条件成立，那么minor gc可以确保是安全的。如果不成立，虚拟机会查看handlepromotionfailure设置值食肉允许担保失败，如果允许，那么就会继续检查老年代中最大可用连续空间时都大于历次净胜到老年代对象的平均大小。如果大于，将尝试着进行一次minor gc，尽管这次minor gc是有风险的。如果小于，或者handlepromotionfailure设置不允许毛线，那么就要改为进行一次full gc。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存分配策略&lt;/p&gt;
&lt;p&gt;###1.对象有现在eden区分配。&lt;/p&gt;
&lt;p&gt;大多数情况下，对象在新生代eden区中分配，当Eden区没有足够的空间分配，虚拟机将发起一次minor GC。&lt;br&gt;虚拟机提供&lt;code&gt;-XX：+PrintGCDetails&lt;/code&gt;这
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM笔记二---垃圾收集器及内存分配策略</title>
    <link href="http://yoursite.com/2016/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <id>http://yoursite.com/2016/10/19/深入理解JVM笔记二/</id>
    <published>2016-10-19T02:51:50.000Z</published>
    <updated>2016-10-19T09:47:01.156Z</updated>
    
    <content type="html"><![CDATA[<p>####对象已死么？</p>
<p>1.引用计数算法</p>
<p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器值就加1；当引用时效的时候，减一。任何时候计数器为0的对象就是不可能再被引用的。（很难解决对象之间相互循环引用的问题）</p>
<p>2.可达性分析算法</p>
<p>这个算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，下图对象object5, object6, object7虽然有互相判断，但它们到GC Roots是不可达的，所以它们将会判定为是可回收对象。<br><img src="http://i.imgur.com/XvHdvR5.png" alt=""></p>
<p>java  GC ROOTS的对象包含以下几种<br>虚拟机栈中引用的对象<br>方法区中类静态属性引用的对象<br>方法区中常量引用的对象<br>本地方法栈种JNI（native方法）引用的对象</p>
<p>####引用</p>
<p>1.强引用 一直活着<br>2.软引用 还有用但并非必须的对象 活到第二次回收<br>3.弱引用 非必须对象 活到下一次垃圾收集之前<br>4.虚引用</p>
<p>####GC算法<br>1.标记清除算法</p>
<p>分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。该算法的缺点是效率不高并且会产生不连续的内存碎片。<br><img src="http://i.imgur.com/PTYTd1h.jpg" alt=""></p>
<p>2.复制算法</p>
<p>把内存空间划为两个区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。优点：实现简单，运行高效。缺点：会浪费一定的内存。一般新生代采用这种算法<br><img src="http://i.imgur.com/wXBBEyQ.jpg" alt=""></p>
<p>3.标记整理算法</p>
<p>标记阶段与标记清除算法一样。但后续并不是直接对可回收的对象进行清理，而是让所有存活对象都想一端移动，然后清理。优点是不会造成内存碎片<br><img src="http://i.imgur.com/1H8E9sw.jpg" alt=""></p>
<p>4.分代收集算法<br>只是根据对象存货周期的不用将内存划分为几块。一般是把java堆划分为新生代和老年代。这样就可以根据各个年代的特点采用最适当的手机算法。在新生代中，每次垃圾收集时有大量的对象死亡，只有少量的存在，那就采用复制算法，对于老年代，对象存活率高，没有额外空间对他进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p>
<p>####Java中垃圾回收器的类型<br>Java提供多种类型的垃圾回收器。JVM中的垃圾收集一般都采用“分代收集”，不同的堆内存区域采用不同的收集算法，主要目的就是为了增加吞吐量或降低停顿时间。</p>
<ul>
<li>Serial收集器：新生代收集器，使用复制算法，使用一个线程进行GC，串行，其它工作线程暂停。</li>
<li>ParNew收集器：新生代收集器，使用复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停。使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。</li>
<li>Parallel Scavenge 收集器：吞吐量优先的垃圾回收器，作用在新生代，使用复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间。使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾。</li>
<li>Serial Old收集器：老年代收集器，单线程收集器，串行，使用标记整理算法，使用单线程进行GC，其它工作线程暂停。</li>
<li>Parallel Old收集器：吞吐量优先的垃圾回收器，作用在老年代，多线程，并行，多线程机制与Parallel Scavenge差不错，使用标记整理算法，在Parallel Old执行时，仍然需要暂停其它线程。</li>
<li>CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见Full GC和并发垃圾回收一节），当用户线程内存不足时，采用备用方案Serial Old收集。</li>
<li>GI收集器</li>
</ul>
<p>####与GC有关的JVM参数<br>做GC调优需要大量的实践，耐心和对项目的分析。我曾经参与过高容量，低延迟的电商系统，在开发中我们需要通过分析造成Full GC的原因来提高系统性能，在这个过程中我发现做GC的调优很大程度上依赖于对系统的分析，系统拥有怎样的对象以及他们的平均生命周期。</p>
<p>举个例子，如果一个应用大多是短生命周期的对象，那么应该确保Eden区足够大，这样可以减少Minor GC的次数。可以通过-XX:NewRatio来控制新生代和老年代的比例，比如-XX:NewRatio=3代表新生代和老年代的比例为1：3。需要注意的是，扩大新生代的大小会减少老年代的大小，这会导致Major GC执行的更频繁，而Major GC可能会造成用户线程的停顿从而降低系统吞吐量。JVM中可以用NewSize和MaxNewSize参数来指定新生代内存最小和最大值，如果两个参数值一样，那么就相当于固定了新生代的大小。<br>个人建议，在做GC调优之前最好深入理解Java中GC机制，推荐阅读Sun Microsystems提供的有关GC的文档。这个链接可能会对理解GC机制提供一些帮助。下面的图列出了各个区可用的一些JVM参数。<br><img src="http://i.imgur.com/bwvkDEn.png" alt=""></p>
<p>####总结</p>
<ul>
<li>为了分代垃圾回收，Java堆内存分为3代：新生代，老年代和永久代。</li>
<li>新的对象实例会优先分配在新生代，在经历几次Minor GC后(默认15次)，还存活的会被移至老年代(某些大对象会直接在老年代分配)。</li>
<li>永久代是否执行GC，取决于采用的JVM。</li>
<li>Minor GC发生在新生代，当Eden区没有足够空间时，会发起一次Minor GC，将Eden区中的存活对象移至Survivor区。Major GC发生在老年代，当升到老年代的对象大于老年代剩余空间时会发生Major GC。</li>
<li>发生Major GC时用户线程会暂停，会降低系统性能和吞吐量。</li>
<li>JVM的参数-Xmx和-Xms用来设置Java堆内存的初始大小和最大值。依据个人经验这个值的比例最好是1:1或者1:1.5。比如，你可以将-Xmx和-Xms都设为1GB，或者-Xmx和-Xms设为1.2GB和1.8GB。</li>
<li>Java中不能手动触发GC，但可以用不同的引用类来辅助垃圾回收器工作(比如：弱引用或软引用)。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;####对象已死么？&lt;/p&gt;
&lt;p&gt;1.引用计数算法&lt;/p&gt;
&lt;p&gt;给对象中添加一个引用计数器，每当有一个地方引用它，计数器值就加1；当引用时效的时候，减一。任何时候计数器为0的对象就是不可能再被引用的。（很难解决对象之间相互循环引用的问题）&lt;/p&gt;
&lt;p&gt;2.可达性分析算
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM笔记一-java内存区域与内存溢出异常</title>
    <link href="http://yoursite.com/2016/10/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://yoursite.com/2016/10/18/深入理解JVM笔记一/</id>
    <published>2016-10-18T07:03:57.000Z</published>
    <updated>2016-10-18T12:50:15.916Z</updated>
    
    <content type="html"><![CDATA[<p>#自动内存管理机制</p>
<p>##java内存区域与内存溢出异常</p>
<p>###1.java虚拟机运行时数据区</p>
<p><img src="http://i.imgur.com/9y9f9Z1.png" alt=""></p>
<ul>
<li><p>程序计数器（Program Counter Register）</p>
<blockquote>
<p>它是一块较小的内存空间，它的作用可以看做是当先线程所执行的字节码的信号指示器。</p>
<p>每一条JVM线程都有自己的PC寄存器，各条线程之间互不影响，独立存储，这类内存区域被称为“线程私有”内存</p>
<p>在任意时刻，一条JVM线程只会执行一个方法的代码。该方法称为该线程的当前方法（Current Method）</p>
<p>如果该方法是java方法，那PC寄存器保存JVM正在执行的字节码指令的地址</p>
<p>如果该方法是native，那PC寄存器的值是undefined。</p>
<p>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
</blockquote>
</li>
<li><p>Java虚拟机栈（Java Virtual Machine Stack）</p>
<blockquote>
<p>与PC寄存器一样，Java虚拟机栈也是线程私有的。每一个JVM线程都有自己的java虚拟机栈，这个栈与线程同时创建，它的生命周期与线程相同。</p>
<p>虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>JVM stack 可以被实现成固定大小，也可以根据计算动态扩展。</p>
<p>如果采用固定大小的JVM stack设计，那么每一条线程的JVM Stack容量应该在线程创建时独立地选定。JVM实现应该提供调节JVM Stack初始容量的手段；如果采用动态扩展和收缩的JVM Stack方式，应该提供调节最大、最小容量的手段。</p>
<p>如果线程请求的栈深度大于虚拟机所允许的深度将抛出StackOverflowError；</p>
<p>如果JVM Stack可以动态扩展，但是在尝试扩展时无法申请到足够的内存时抛出OutOfMemoryError。</p>
</blockquote>
</li>
<li><p>本地方法栈（Native Method Stack）</p>
</li>
</ul>
<blockquote>
<p>本地方法栈与虚拟机栈作用相似，后者为虚拟机执行Java方法服务，而前者为虚拟机用到的Native方法服务。</p>
<p>虚拟机规范对于本地方法栈中方法使用的语言，使用方式和数据结构没有强制规定，甚至有的虚拟机（比如HotSpot）直接把二者合二为一。</p>
<p>这玩意儿抛出的异常跟上面的虚拟机栈一样。</p>
</blockquote>
<ul>
<li><p>Java堆（Java Heap）</p>
<blockquote>
<p>虚拟机管理的内存中最大的一块，同时也是被所有线程所共享的，它在虚拟机启动时创建，这货存在的意义就是存放对象实例，几乎所有的对象实例以及数组都要在这里分配内存。这里面的对象被自动管理，也就是俗称的GC（Garbage Collector）所管理。用就是了，有GC扛着呢，不用操心销毁回收的事儿。</p>
<p>Java堆的容量可以是固定大小，也可以随着需求动态扩展（-Xms和-Xmx），并在不需要过多空间时自动收缩。</p>
<p>Java堆所使用的内存不需要保证是物理连续的，只要逻辑上是连续的即可。</p>
<p>JVM实现应当提供给程序员调节Java 堆初始容量的手段，对于可动态扩展和收缩的堆来说，则应当提供调节其最大和最小容量的手段。</p>
<p>如果堆中没有内存完成实例分配并且堆也无法扩展，就会抛OutOfMemoryError。</p>
</blockquote>
</li>
<li><p>方法区（Method Area）</p>
<blockquote>
<p>跟堆一样是被<strong>各个线程共享的内存区域</strong>，用于存储以被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然这个区域被虚拟机规范把方法区描述为堆的一个逻辑部分，但是它的别名叫非堆，用来与堆做一下区别。</p>
<p>方法区在虚拟机启动的时候创建。</p>
<p>方法区的容量可以是固定大小的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩。</p>
<p>方法区在实际内存空间中可以是不连续的。</p>
<p>Java虚拟机实现应当提供给程序员或者最终用户调节方法区初始容量的手段，对于可以动态扩展和收缩方法区来说，则应当提供调节其最大、最小容量的手段。</p>
<p>当方法区无法满足内存分配需求时就会抛OutOfMemoryError。</p>
</blockquote>
</li>
<li><p>运行时常量池（Runtime Constant Pool）</p>
<blockquote>
<p>它是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<p>Java虚拟机对Class文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p>
<p>既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>
</blockquote>
</li>
</ul>
<p>###2.hotspot虚拟机对象探秘<br>1.对象的创建</p>
<p>new-&gt;检查这个指令参数是否能在常量池中定位到一个类的引用符号-&gt;判断这个类是否被加载、解析、初始化过-&gt;加载检查通过后，分配内存(指针碰撞，空闲列表)</p>
<p>-&gt;对分配内存空间的动作进行同步处理（CAS配上失败重试、TLAB）-&gt;虚拟机需要将分配到的内存空间都初始化为零值-&gt;对对象进行必要的设置</p>
<p>2.对象的内存布局</p>
<p>还Hotspot虚拟机中，对象的内存中存储的布局分为3块区域：对象头（header）、实例数据（Instance Data）、对其填充（Padding） </p>
<p>Hotspot虚拟机的对象头包括两部分信息，第一部分用于存储自身运行时的数据，例如：哈希码、GC分代年龄、锁状态标识、线程持有锁、偏向线程id、偏向时间戳，这部分数据数据长度在32位和64位的虚拟机（未开启指针压缩）中分别为32bit和64bit，官方称为’Mark word’。对象需要存储的运行时的数据非常多，已经超出了32位、64位bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关额外的存储成本，考虑到虚拟机的空间效率，Mark work被设计成一个非固定的数据结构以便在极小空间内存储尽可能多的信息，他会根据对象状态复用自己的存储空间。<br>对象头的另一部分是类型指针，即对象指向他的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个Java数组，那在对象中还必须有一块用于记录数组长度的数据，因为虚拟机可通过普通 Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。 </p>
<p>接下来的实例数据是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的还是在子类中定义的，都需要记录下来。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。Hotspot虚拟机的分配策略是相同宽度的字段总是被分配到一起。在满足这个前提条件下，在父类中定义的变量会出现在子类之前。</p>
<p>3.对象的访问定位</p>
<ul>
<li>句柄</li>
</ul>
<p>如果使用句柄访问的话，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据的具体各自的地址信息。如图1所示。<br><img src="http://i.imgur.com/xF8cz3T.jpg" alt=""></p>
<ul>
<li>直接指针</li>
</ul>
<p>如果使用直接指针访问的话，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如图2所示。<br><img src="http://i.imgur.com/7mWuClk.jpg" alt=""></p>
<p>###3.outofmemoryerror异常<br>1.java 堆溢出<br>2.虚拟机栈本地方法溢出<br>3.方法区和运行时常量池溢出<br>4.本机直接内存溢出</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#自动内存管理机制&lt;/p&gt;
&lt;p&gt;##java内存区域与内存溢出异常&lt;/p&gt;
&lt;p&gt;###1.java虚拟机运行时数据区&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/9y9f9Z1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;程序计
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ng机器学习notes1+weka相关算法实现</title>
    <link href="http://yoursite.com/2016/10/14/Ng%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0notes1-weka%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2016/10/14/Ng机器学习notes1-weka相关算法实现/</id>
    <published>2016-10-14T04:30:14.000Z</published>
    <updated>2016-10-14T04:59:08.082Z</updated>
    
    <content type="html"><![CDATA[<p>Andrew Ng的机器学习课程notes1.</p>
<p>参考链接：<a href="http://blog.csdn.net/qiao1245/article/details/50886247" target="_blank" rel="external">http://blog.csdn.net/qiao1245/article/details/50886247</a></p>
<p>主要内容是关于判别学习方法的，涉及到了梯度下降、随机梯度下降、最小二乘法、局部加权回归、极大似然原理、logistic regression、牛顿方法、广义线性模型、指数分布族。</p>
<p>##Ng机器学习笔记</p>
<p><strong>1.问题引入：房价预测</strong></p>
<p><img src="http://i.imgur.com/YVXqMDd.png" alt=""><br>我们可以将变量表示成X1，X2，然后结果表示为Y，那么Y和X之间存在一种映射关系，也就是说，我们可以通过X预测Y，假设二者之间关系是多元线性关系，形式上表述为：</p>
<p><img src="http://i.imgur.com/WhQcGmc.png" alt=""></p>
<p>H就是根据X对Y做出的估计，其中的参数θ是我们要求的量。<br>如何求得参数θ呢？我们可以利用损失函数的概念，损失函数表示了预测值与实际值之间的差距：</p>
<p><img src="http://i.imgur.com/b8rfDs0.png" alt=""></p>
<p>那么很显然，只要J（θ）最小化，那么θ就是最好的参数。那么我们下面就是使得J（θ）最小化，其中方法之一梯度下降方法。</p>
<p><strong>2.梯度下降</strong></p>
<p>什么是梯度？梯度是标量场中某一点上的梯度指向标量场增长最快的方向，梯度的长度是这个最大的变化率。因此，梯度方向是函数变化最快的地方。那么我们可以任意初始化θ，接下来就按照梯度方向进行调整θ只，就可以最快的到达最大值。 </p>
<p>可以得到更新θ规则，对于一个独立的样本，这种方法就是最小二乘法。 </p>
<p><img src="http://i.imgur.com/ovVDkP1.png" alt=""></p>
<p>扩展到M个样本，对J（θ）求偏导数，可以得到最终结果：<br><img src="http://i.imgur.com/aKxdpy0.png" alt=""><br>因此，梯度下降的过程就是不断地θ进行迭代，直到θ达到最大值为止<br><img src="http://i.imgur.com/3wQOxcE.png" alt=""><br>但是这样有一个很大的问题，就是每下降一步，就需要遍历整个数据集，这会导致巨大的计算量。因此，我们可以每次使用一条数据，就迭代一次，过程如下：<br><img src="http://i.imgur.com/tFXT2y1.png" alt=""><br>这样就会使得迭代过程并非一直是正向进行的，也就是可能会有向相反方向迭代的可能，但是总体还是向下的。这样还有一个问题，就是可能算法未必会收敛到最小值，而在最小值附近一直徘徊。但是最大的优点就是，快！</p>
<p>除了代数方法求得θ，我们还可以使用线性代数的方法直接求得θ参数，具体推导过程不再赘述，可以去看讲义，结果是：<br><img src="http://i.imgur.com/9bpMtTg.png" alt=""></p>
<p>这样虽然避免了计算，但是对矩阵求逆是比较慢的，而且这个方法要求X是满秩的，若不是满秩矩阵需要做处理。</p>
<p><strong>3.极大似然估计</strong></p>
<p>那么为什么采用平方和函数得到的θ就是最佳的呢？这里有对应的概率解释。对于一般的回归问题，我们可以将预测值和真实值之间表示为：<br><img src="http://i.imgur.com/H9SEMY1.png" alt=""></p>
<p><strong>4.局部加权回归</strong></p>
<p>有时候可能我们发现变量X和Y之间的关系并不是一种线性关系，但是在很小一段上，X和Y可以近似的看做线性关系，那么如何衡量这种关系呢？我们可以使用局部加权回归来解决这类问题，通过权重函数，我们可以距离目标值越远的点对整体影响越小。 </p>
<p>那么我们的问题可以化为：<br> <img src="http://i.imgur.com/cPk6OoJ.png" alt=""></p>
<p>其中，W可以表示为：<br><img src="http://i.imgur.com/7oueKN5.png" alt=""><br>这里面的τ被称为波长，用于控制权值随着距离变化的快慢。<br>那么我们像之前一样对问题进行求解。</p>
<p><strong>5.logistic回归</strong><br>有时候，我们的预测值并不是连续的，如满足伯努利分布，Y∈{0,1}，那么该怎么进行回归分析呢？<br>我们可以利用函数将连续值映射到0-1之间，一个函数就是： </p>
<p><img src="http://i.imgur.com/I20ojGR.png" alt=""></p>
<p><strong>6.牛顿方法</strong></p>
<p>除了梯度下降，还有一种牛顿方法可以对解空间进行搜索。示意图如下：<br><img src="http://i.imgur.com/NHm6GiT.png" alt=""></p>
<p>方法是先随机选一个点，求出该点的切线，延长它使之与 x 轴相<br>交，以相交时的 x 的值作为下一次迭代的值。<br>由于最大似然函数的性质，我们可以知道当导数为0时，求得θ最佳，那么我们可以得到更新规则：</p>
<p><img src="http://i.imgur.com/0ZTqRI2.png" alt=""></p>
<p>牛顿法的优点是收敛较快，但是有可能达不到最值。</p>
<p>##weka相关算法实现</p>
<p><strong>1.线性回归</strong></p>
<pre><code>weka.classifiers.functions.LinearRegression
Class for using linear regression for prediction. Uses the Akaike criterion for model selection, and is able to deal with weighted instances. 

 Valid options are: 
 -S &lt;number of selection method&gt;
  Set the attribute selection method to use. 1 = None, 2 = Greedy.
  (default 0 = M5&apos; method)

 -C
  Do not try to eliminate colinear attributes.

 -R &lt;double&gt;
  Set ridge parameter (default 1.0e-8).

 -minimal
  Conserve memory, don&apos;t keep dataset header and means/stdevs.
  Model cannot be printed out if this option is enabled. (default: keep data)

 -additional-stats
  Output additional statistics.

 -output-debug-info
  If set, classifier is run in debug mode and
  may output additional info to the console

 -do-not-check-capabilities
  If set, classifier capabilities are not checked before classifier is built
  (use with caution).

Version:$Revision: 12643 $Author:Eibe Frank (eibe@cs.waikato.ac.nz)Len Trigg (trigg@cs.waikato.ac.nz)
</code></pre><p><strong>2.逻辑回归</strong></p>
<p>Valid options are: </p>
<pre><code>-D
 Turn on debugging output.

-R &lt;ridge&gt;
 Set the ridge in the log-likelihood.

-M &lt;number&gt;
 Set the maximum number of iterations (default -1, until convergence).
</code></pre><p>参数比较少，其中-R用来调整迭代时θ对整个Cost函数的影响，默认是1E-8，-M是迭代的最大次数，如果指定为-1，则算法运行一直到收敛为止。<br>代码如下：</p>
<pre><code>class LogisticModel {

    public LogisticModel(Instances data) {
        String[] options={&quot;-M&quot;,20};
        Logistic model = new Logistic();
        try {
            model.setOptions(options);
            model.buildClassifier(data);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Andrew Ng的机器学习课程notes1.&lt;/p&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;http://blog.csdn.net/qiao1245/article/details/50886247&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http:
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql中tinyint.smallint.int.bigint区别</title>
    <link href="http://yoursite.com/2016/10/13/mysql%E4%B8%ADtinyint-smallint-int-bigint%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2016/10/13/mysql中tinyint-smallint-int-bigint区别/</id>
    <published>2016-10-13T07:52:49.000Z</published>
    <updated>2016-10-13T07:55:14.028Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>tinyint<br>从 -2^7 (-128) 到 2^7 - 1 (123) 的整型数据。存储大小为 1 个字节。<br>unsigned 是从 0 到 255 的整型数据。<br>所以建表的时候 只能是tinyint(3),哪怕你建tinyint(100)，他最大还是3位这么多。</p>
</li>
<li><p>smallint<br>从 -2^15 (-32,768) 到 2^15 - 1 (32,767) 的整型数据。存储大小为 2 个字节。<br>unsigned 是从 0 到 65535 的整型数据。<br>所以建表的时候 只能是smallint(5),哪怕你建smallint(100)，他最大还是5位这么多。</p>
</li>
<li><p>int<br>从 -2^31 (-2,147,483,648) 到 2^31 - 1 (2,147,483,647) 的整型数据（所有数字）.存储大小为 4 个字节。<br>unsigned 是从 0 到 4294967296 的整型数据。<br>所以建表的时候 只能是int(10),哪怕你建int(100)，他最大还是10位这么多。</p>
</li>
<li><p>bigint<br>从 -2^63 (-9,223,372,036,854,775,808) 到 2^63-1 (9,223,372,036,854,775,807) 的整型数据（所有数字）。存储大小为 8 个字节。<br>unsigned 是(自己算吧)</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;tinyint&lt;br&gt;从 -2^7 (-128) 到 2^7 - 1 (123) 的整型数据。存储大小为 1 个字节。&lt;br&gt;unsigned 是从 0 到 255 的整型数据。&lt;br&gt;所以建表的时候 只能是tinyint(3),哪怕你建tinyint(1
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面向对象系统分析与设计</title>
    <link href="http://yoursite.com/2016/10/06/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2016/10/06/面向对象系统分析与设计/</id>
    <published>2016-10-06T09:02:48.000Z</published>
    <updated>2016-10-06T09:30:40.429Z</updated>
    
    <content type="html"><![CDATA[<p>####系统分析设计方法：</p>
<ul>
<li>结构化方法</li>
<li>信息建模法</li>
<li>面向对象分析设计方法</li>
</ul>
<p>面向对象的分析（Object Oriented Analysis，OOA）强调的是在问题域内发现和描述对象（或概念）。</p>
<p>面向对象的设计（ Object Oriented Design ，OOD）强调的是定义软件对象以它们是如何协作以实现需求</p>
<p>####面向对象的优点：</p>
<ul>
<li>复用<br>通过继承、关联、封装等手段</li>
<li>应变<br>弹性应对需求变化</li>
<li>沟通<br>开发人员、用户、管理人员</li>
<li>市场<br>应付市场的变化</li>
<li>士气<br>员工的士气</li>
</ul>
<p>使用OMT方法的面向对象开发过程可分为5步：</p>
<ul>
<li>分析</li>
<li>系统设计</li>
<li>对象设计</li>
<li>编代码</li>
<li>测试</li>
</ul>
<p>分为下述5个活动 </p>
<ul>
<li>编写问题陈述 </li>
<li>建立对象模型 </li>
<li>建立动态模型 </li>
<li>建立功能模型</li>
<li>细化对象模型、动态模型和功能模型，并建立文档</li>
</ul>
<p>系统设计的步骤如下：</p>
<ul>
<li>将系统划分为子系统 </li>
<li>识别并发 </li>
<li>将子系统和任务分配给处理器 </li>
<li>选择实现数据存储的策略 </li>
<li>识别出全局资源，并确定控制访问全局资源的机制 </li>
<li>选择实现软件控制的方法 </li>
<li>考虑边界条件 </li>
<li>建立折衷的优先级</li>
</ul>
<p>宏过程包括下述5个活动:</p>
<p>（1）概念化（Conceptualization）：在这个活动中，建立核心需求。<br>（2）分析（Analysis）：在这个活动中，为所期望的行为建立模型。<br>（3）设计（Design）：在这个活动中，建立体系结构。<br>（4）进化（Evolution）：在这个活动中，形成实现。<br>（5）维护（Maintenance）：在这个活动中，管理软件的交付使用。</p>
<p>微过程由4个步骤组成：</p>
<p>（1）在给定的抽象层次上识别出类和对象。<br>（2）识别出这些类和对象的语义。<br>（3）识别出类间和对象间的关系。<br>（4）实现类和对象。</p>
<p>####软件过程</p>
<p>软件过程定义了软件开发、部署和维护的步骤</p>
<ul>
<li><p>迭代式开发 </p>
<p> 迭代式开发将软件开发过程分解为一系列小的，固定周期的(比如，4个星期)的小项目，每个小项目称为一个迭代。</p>
</li>
<li><p>统一过程 (Unified Process)</p>
</li>
</ul>
<p>一种采用OOA/D方法学开发项目的过程(Ivar Jacobson)。<br>一种流行的构造面向对象系统的迭代开发过程（JBR99）。</p>
<ul>
<li>敏捷UP( Agile UP ) </li>
</ul>
<p>引入了敏捷概念的UP,是UP的一个简集。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;####系统分析设计方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构化方法&lt;/li&gt;
&lt;li&gt;信息建模法&lt;/li&gt;
&lt;li&gt;面向对象分析设计方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面向对象的分析（Object Oriented Analysis，OOA）强调的是在问题域内发现和描述对象（或
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>机器学习weka（三）</title>
    <link href="http://yoursite.com/2016/09/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0weka%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2016/09/29/机器学习weka（三）/</id>
    <published>2016-09-29T14:12:39.000Z</published>
    <updated>2016-09-29T14:16:49.908Z</updated>
    
    <content type="html"><![CDATA[<p><strong>模型序列化/持久化存储和加载</strong></p>
<p>有很多时候，你在构建了一个模型并完成调优后，你很可能会想把这个模型存入到磁盘中，免得下次再重新训练。尤其是神经网络、SVM等模型训练时间非常长，重新训练非常浪费时间。那么怎么持久化模型呢？<br>其实既然模型也是一个Java对象，那我就按照JAVA的序列化和反序列化方法保存模型对象即可。</p>
<p>以J48为例，进行序列化和存取</p>
<p>序列化：</p>
<pre><code>public static void persistModel(J48 model, String ModelPath) {
        ObjectOutputStream oos = null;
        try {
            oos = new ObjectOutputStream(
            new FileOutputStream(ModelPath));
            oos.writeObject(model);
            oos.flush();
            oos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
</code></pre><p>重新加载：</p>
<pre><code>public static J48 reloadPersistModel(String ModelPath) {
        ObjectInputStream ois = null;
        try {
            ois = new ObjectInputStream(
            new FileInputStream(new File(ModelPath)));
            J48 model = (J48) ois.readObject();
            return model;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;模型序列化/持久化存储和加载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有很多时候，你在构建了一个模型并完成调优后，你很可能会想把这个模型存入到磁盘中，免得下次再重新训练。尤其是神经网络、SVM等模型训练时间非常长，重新训练非常浪费时间。那么怎么持久化模型呢？&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>机器学习weka（二）</title>
    <link href="http://yoursite.com/2016/09/29/weka%E5%AD%A6%E4%B9%A02/"/>
    <id>http://yoursite.com/2016/09/29/weka学习2/</id>
    <published>2016-09-29T14:04:00.000Z</published>
    <updated>2016-09-29T14:11:11.276Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.weka分类/回归模型构建与评价</strong></p>
<p>以最简单的决策树算法为例，在Weka中，决策树算法的实现是J48类，因此我们只需要创建J48对象就可以创建决策树。整个过程可以分为如下步骤： </p>
<p><strong>数据准备</strong></p>
<p>我们要做的就是加载数据，然后使用Filter对数据进行一定的操作，满足特定算法的需求。具体的将在决策树中讲解。</p>
<p><strong>模型配置</strong></p>
<p>在模型准备前，要对模型进行适当的配置，Weka中是通过传入Options数组来实现的，然后使用模型的setOptions(options)方法将模型配置信息传入</p>
<p><strong>模型学习</strong></p>
<p>模型学习过程就是使用训练数据对模型进行训练，在Weka中只需要调用模型的buildClassifier(data)方法即可。<br>上述三个过程可以用以下代码表示：</p>
<pre><code>class CARTModel {
    public CARTModel(Instances data) throws Exception{
        J48 model = new J48();
        String[] options = {&quot;-M&quot;,&quot;5&quot;,&quot;-R&quot;};
        model.setOptions(options);
        model.buildClassifier(data);
    }
}
</code></pre><p><strong>模型评价</strong></p>
<p>通过创建Evaluation对象来实现评价，具体代码如下：</p>
<pre><code>Evaluation eval = new Evaluation(testData);
 eval.crossValidateModel(model, trainSet, 10, new Random(1));
 System.out.println(eval.toSummaryString(&quot;\nResult&quot;, false));
 System.out.println(eval.toClassDetailsString());
</code></pre><p><strong>2.评价evaluation介绍</strong></p>
<p><strong>基本指标</strong></p>
<p>1、 FN：False Negative,被判定为负样本，但事实上是正样本。 </p>
<p>2、 FP：False Positive,被判定为正样本，但事实上是负样本。 </p>
<p>3、TN：True Negative,被判定为负样本，事实上也是负样本。 </p>
<p>4、TP：True Positive,被判定为正样本，事实上也是证样本。</p>
<p>5、precesion：查准率<br>即在检索后返回的结果中，真正正确的个数占整个结果的比例。precesion = TP/(TP+FP) 。 </p>
<p>6、 recall：查全率<br>即在检索结果中真正正确的个数 占整个数据集（检索到的和未检索到的）中真正正确个数的比例。recall = TP/(TP+FN)即，检索结果中，你判断为正的样本也确实为正的，以及那些没在检索结果中被你判断为负但是事实上是正的（FN）。</p>
<p>7、F-Measure<br>是Precision和Recall加权调和平均<br>P和R指标有时候会出现的矛盾的情况，这样就需要综合考虑他们，最常见的方法就是F-Measure（又称为F-Score）。 </p>
<p>8、MCC 马修斯相关系数<br>衡量不平衡数据集的指标比较好。</p>
<p><strong>ROC曲线</strong></p>
<p>ROC曲线的横坐标为false positive rate（FPR），纵坐标为 true positive rate（TPR）<br>当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变。根据每个测试样本属于正样本的概率值从大到小排序，依次将 “Score”值作为阈值threshold，当测试样本属于正样本的概率 大于或等于这个threshold时，认为它为正样本，否则为负样本。 </p>
<p><strong>PRC曲线</strong></p>
<p>在正负样本分布得极不均匀(highly skewed datasets)的情况下，PRC比ROC能更有效地反应分类器的好坏。 </p>
<p><strong>其他指标</strong></p>
<p>1、kappa statics Kappa<br>值即内部一致性系数(inter-rater,coefficient of internal consistency)，是作为评价判断的一致性程度的重要指标。取值在0～1之间。Kappa≥0.75两者一致性较好；0.75&gt;Kappa≥0.4两者一致性一般；Kappa&lt;0.4两者一致性较差。</p>
<p>2、Mean absolute error 和 Root mean squared error<br>平均绝对误差和均方根误差，用来衡量分类器预测值和实际结果的差异，越小越好。</p>
<p>3、Relative absolute error 和 Root relative squared error<br>相对绝对误差和相对均方根误差，有时绝对误差不能体现误差的真实大小，而相对误差通过体现误差占真值的比重来反映误差大小。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1.weka分类/回归模型构建与评价&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以最简单的决策树算法为例，在Weka中，决策树算法的实现是J48类，因此我们只需要创建J48对象就可以创建决策树。整个过程可以分为如下步骤： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据准备&lt;/s
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>机器学习weka（一）</title>
    <link href="http://yoursite.com/2016/09/29/weka1/"/>
    <id>http://yoursite.com/2016/09/29/weka1/</id>
    <published>2016-09-29T12:39:32.000Z</published>
    <updated>2016-09-29T12:00:05.559Z</updated>
    
    <content type="html"><![CDATA[<p>###机器学习weka（一）<br><a id="more"></a></p>
<p>##1.Instances</p>
<p>Instances对象实例化后，就存储了所有数据，同时也附带了很多数据属性，简单来说，你可以认为Instances就像一个电子表格，存储了你所加载的数据。 </p>
<p>Instances实例化有很多方式，在这里我介绍三种方式：<br>1.通过文件加载</p>
<pre><code>Instances(java.io.Reader reader) 
Reads an ARFF file from a reader, and assigns a weight of one to each instance.

Instances(java.io.Reader reader, int capacity) 
Deprecated. instead of using this method in conjunction with the readInstance(Reader) method, one should use the ArffLoader or DataSource class instead.

Instances data = new Instances( new BufferedReader(new FileReader(&quot;/Path/data.arff&quot;)));
</code></pre><p>2.使用DataSource从文件中加载数据 </p>
<pre><code>DataSource source = new DataSource(&quot;/some/where/data.arff&quot;);
Instances data = source.getDataSet();
</code></pre><p>3.从数据库实例化Instances对象</p>
<pre><code>InstanceQuery query= new InstanceQuery();
query.setDebug(true);
query.setUsername(&quot;C##TEST&quot;);
query.setPassword(&quot;test&quot;);
query.setDatabaseURL(&quot;jdbc:oracle:thin:@127.0.0.1:1521:ORCL&quot;);
String sql=&quot;SELECT * FROM (SELECT MDI_READING , MDI_TS from M_FS_DB_INTERVAL where  CST_ID= 5695 ) where rownum &lt; 10000&quot;;
query.setQuery(sql);
Instances train=query.retrieveInstances();
</code></pre><p>4.自己构造一个instances</p>
<pre><code>Creates an empty set of instances. Uses the given attribute information. Sets the capacity of the set of instances to 0 if its negative. Given attribute information must not be changed after this constructor has been used.Parameters:name the name of the relationattInfo the attribute informationcapacity the capacity of the setThrows:IllegalArgumentException - if attribute names are not unique

Instances(java.lang.String name, java.util.ArrayList&lt;Attribute&gt; attInfo, int capacity) 
Creates an empty set of instances.
</code></pre><p>根据构造方法我们需要创建一个attInfo对象。</p>
<pre><code>ArrayList&lt;Attribute&gt; atts = new ArrayList&lt;Attribute&gt;();
Attribute attribute1 = new Attribute(&quot;ID&quot;);
Attribute attribute2 = new Attribute(&quot;District&quot;);
Attribute attribute3 = new Attribute(&quot;CountryCode&quot;);
Attribute attribute4 = new Attribute(&quot;Population&quot;);
atts.add(attribute1);
atts.add(attribute2);
atts.add(attribute3);
atts.add(attribute4);
</code></pre><p>构建instances对象</p>
<pre><code>Instances df = new Instances(&quot;Data&quot;, atts, 0);
</code></pre><p>构建instance对象</p>
<pre><code>Create empty instance with three attribute values 
Instance inst = new DenseInstance(3); 
// Set instance&apos;s values for the attributes &quot;length&quot;, &quot;weight&quot;, and &quot;position&quot;
inst.setValue(length, 5.3); 
inst.setValue(weight, 300); 
inst.setValue(position, &quot;first&quot;); 
// Set instance&apos;s dataset to be the dataset &quot;race&quot; 
inst.setDataset(instances); 
</code></pre><p>instances对象添加instance值</p>
<pre><code>instances.add(inst);
</code></pre><p>##2.Attribute</p>
<p>1.介绍</p>
<p>attribute指的是Weka中数据的属性，一般就是表明数据集信息，数据每一列的性质等。之前讲过的Weka数据格式ARFF其实头信息包含的就是数据的Attribute信息。之前讲的Weka的数据存储方式Instances也有Attribute属性。<br>Attribute属性主要分以下几类:</p>
<pre><code>numeric: This type of attribute represents a floating-point number. 
         就是代表连续的，浮点数变量，如气温。
nominal: This type of attribute represents a fixed set of nominal values. 
         指的是离散的，刻意被划分为几类的变量，如户口类型。
string: This type of attribute represents a dynamically expanding set of nominal values. Usually used in text classification. 
         指的该列内容是文本，一般用于文本挖掘。
date: This type of attribute represents a date, internally represented as floating-point number storing the milliseconds since January 1, 1970, 00:00:00 GMT. The string representation of the date must be ISO-8601 compliant, the default is yyyy-MM-dd&apos;T&apos;HH:mm:ss. 
         指的该列数据代表日期，要按照规范格式写。
relational: This type of attribute can contain other attributes and is, e.g., used for representing Multi-Instance data. (Multi-Instance data consists of a nominal attribute containing the bag-id, then a relational attribute with all the attributes of the bag, and finally the class attribute.) 
    用来实现其他类型的数据。
</code></pre><p>2.attribute的创建</p>
<pre><code>// Create numeric attributes &quot;length&quot; and &quot;weight&quot; 
Attribute length = new Attribute(&quot;length&quot;); 
Attribute weight = new Attribute(&quot;weight&quot;); 
// Create list to hold nominal values &quot;first&quot;, &quot;second&quot;, &quot;third&quot; 
List my_nominal_values = new ArrayList(3); 
my_nominal_values.add(&quot;first&quot;); 
my_nominal_values.add(&quot;second&quot;); 
my_nominal_values.add(&quot;third&quot;); 
// Create nominal attribute &quot;position&quot; 
Attribute position = new Attribute(&quot;position&quot;, my_nominal_values);
</code></pre><p>##3.Filter（数据预处理）</p>
<p>1.什么是数据预处理？</p>
<p>加载完毕数据集后，还是不能直接进行数据挖掘模型的训练和学习，必须要进行数据预处理，数据预处理一般指的是以下四个方面：数据清理，数据集成，数据变换，数据归约等。</p>
<ul>
<li><p>①数据清理<br>数据清理例程通过填写缺失的值、光滑噪声数据、识别或删除离群点并解决不一致性来“清理”数据。主要是达到如下目标：格式标准化，异常数据清除，错误纠正，重复数据的清除。 </p>
</li>
<li><p>②数据集成<br>数据集成例程将多个数据源中的数据结合起来并统一存储，建立数据仓库的过程实际上就是数据集成。 </p>
</li>
<li><p>③数据变换<br>通过平滑聚集，数据概化，规范化等方式将数据转换成适用于数据挖掘的形式。 </p>
</li>
<li><p>④数据归约<br>数据挖掘时往往数据量非常大，在少量数据上进行挖掘分析需要很长的时间，数据归约技术可以用来得到数据集的归约表示，它小得多，但仍然接近于保持原数据的完整性，并结果与归约前结果相同或几乎相同。<br>这些预处理都可以使用Weka的Filter来实现。Weka的Filter作用是将一个Instances输入后，通过特定的数据清洗过程，将清洗好的Instances输出，也就是说，Filter处理的维度是在Instances层面上进行的。你也可以通过Filter的组合来实现复杂的数据处理。</p>
</li>
</ul>
<p>Filter提供的功能<br>FIlter功能还是比较强大的，但是Filter分为非监督学习和监督学习两种过滤器，分别属于weka.filters.unsupervised.attribute和weka.filters.unsupervised.attribute，至于监督学习和非监督学习，简单理解就是看输入数据是否有标签（label）。输入数据有标签，则为有监督学习，没标签则为无监督学习。这两种方式下的过滤器是不一样的，使用时一定要注意。<br>非监督学习包下的方法比较多，先讲解一下&gt; weka.filters.unsupervised.attribute主要方法的含义： </p>
<blockquote>
<p>1.Add<br>为数据库添加一个新的属性，新的属性将会包含所有缺失值。</p>
<p>2.AddExpression<br>新增一个属性，该属性由现有属性通过设定的表达式计算得出。支持+, -, *, /, ^, log, abs, cos, exp, sqrt, floor, ceil, rint, tan, sin。现有属性由a+索引值构成。 </p>
<p>3.AddNoise<br>只对名义属性有效，依照一定比例修改值。 </p>
<p>4.Center<br>将数值化属性的平均化为0。 </p>
<p>5.ChangeDateFormat<br>修改数据格式 </p>
<p>6.Discretize<br>简单划分的离散化处理。参数： </p>
<p>7.MathExpression<br>功能和AddExpression类似，不过支持的运算更多，特别是MAX和MIN的支持特别有用。所有支持运算符如下：+, -, *, /, pow, log,abs, cos, exp, sqrt, tan, sin, ceil, floor, rint, (, ),A,MEAN, MAX, MIN, SD, COUNT, SUM, SUMSQUARED, ifelse </p>
<p>8.Reorder<br>重新排列属性，输入2-last，1可以让第一项排到最后，如果输入1,3,5的话…其他项就没有了 </p>
<p>9.Standardize<br>这个和Center功能大致相同，多了一个标准化单位变异数 </p>
<p>10.StringToNominal<br>将String型转化为Nominal型</p>
</blockquote>
<p>然后再讲一下weka.filters.unsupervised.instance包下的主要方法和含义： </p>
<ul>
<li>1.NonSparseToSparse 将所有输入转为稀疏格式 </li>
<li>2.Normalize 规范化整个实例集 </li>
<li>3.RemoveFolds 交叉验证，不支持分层，如果需要的话使用监督学习中的方法 </li>
<li>4.RemoveRange  移除制定范围的实例，化为NaN </li>
<li>5.Resample  随机抽样，从现有样本产生新的小样本 </li>
<li>6.SubsetByExpression 根据规则进行过滤，支持逻辑运算，向上取值，取绝对值等等</li>
</ul>
<p>监督学习下虽然方法比较少，但是思路有所不同，主要是在有标签的情况下，很多方法诸如抽样就必须考虑不同数据分类的比例</p>
<pre><code>//假设已经有一个数据集tempData
Normalize normalize = new Normalize();
String[] normalOptions = new String[]{&quot;-S&quot;,&quot;2.0&quot;,&quot;-T&quot;,&quot;-1.0&quot;};
normalize.setOptions(normalOptions);
normalize.setInputFormat(tempData);
newData = Filter.useFilter(tempData,normalize);
</code></pre><p>2.采样</p>
<p>数据预处理中，有一个原理很简单但是非常重要的部分：采样。良好的采样可以让数据集变得平衡，会大大的提高预测和分类的效果。<br>采样是很复杂的一个领域，背后涉及到数据的分布/数据的性质等很多内容。常见的采样有： </p>
<ul>
<li>Simple Random Sampling(简单随机采样)， </li>
<li>OfflineSampling(离线等可能K采样)， </li>
<li>Online Sampling(在线等可能K采样)， </li>
<li>Ratio-based Sampling(等比例随机采样)， </li>
<li>Acceptance-RejectionSampling(接受-拒绝采样)， </li>
<li>Importance Sampling(重要性采样)， </li>
<li>MCMC(MarkovChain Monte Carlo 马尔科夫蒙特卡罗采样算法)。</li>
</ul>
<p>Filter支持多种采样方式，其中有监督的采样比较复杂，因此主要讲解有监督学习采样方法。Filter中的Resample采样就是简单的有放回抽样。</p>
<pre><code>Resample

  Open Declaration   weka.filters.supervised.instance.Resample


Produces a random subsample of a dataset using either sampling with replacement or without replacement.
 The original dataset must fit entirely in memory. The number of instances in the generated dataset may be specified. The dataset must have a nominal class attribute. If not, use the unsupervised version. The filter can be made to maintain the class distribution in the subsample, or to bias the class distribution toward a uniform distribution. When used in batch mode (i.e. in the FilteredClassifier), subsequent batches are NOT resampled. 

 Valid options are: 


 -S &lt;num&gt;
  Specify the random number seed (default 1)
  指定随机数种子，随机数种子相同，则采样结果相同。

 -Z &lt;num&gt;
  The size of the output dataset, as a percentage of
  the input dataset (default 100)
  指定采样数据占整个数据的比例。

 -B &lt;num&gt;
  Bias factor towards uniform class distribution.
  0 = distribution in input data -- 1 = uniform distribution.
  (default 0)
 是否按照原来数据类别的分布分层抽样

 -no-replacement
  Disables replacement of instances
  (default: with replacement)

 -V
  Inverts the selection - only available with &apos;-no-replacement&apos;.

Version:$Revision: 11310 $Author:Len Trigg (len@reeltwo.com)FracPete (fracpete at waikato dot ac dot nz)Eibe Frank
</code></pre><p>使用Resample进行采样是比较简单的，下面是一个例子：</p>
<pre><code>public static Instances BoostrapSample(Instances data) {
        String[] options = {&quot;-S&quot;,1};
        Resample convert = new Resample();
        try {
            convert.setOptions(options);
            convert.setInputFormat(data);
            data = Filter.useFilter(data, convert);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return data;
    }
</code></pre><p>SMOTE采样<br>随机采样比较简单，其实Weka还支持一种附加的采样方法，在Weka3.6版本以下，这个功能嵌入在Weka包里，Weka3.7版本开始，这个功能需要额外的第三方包的支持，这种采样就是SMOTE采样。<br>SMOTE算法的思想是合成新的少数类样本，合成的策略是对每个少数类样本a，从它的最近邻中随机选一个样本b，然后在a、b之间的连线上随机选一点作为新合成的少数类样本。 这是一种过采样方法，通过制造更多模拟的少数类样本来实现各个样本之间的平衡。</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;nz.ac.waikato.cms.weka&lt;/groupId&gt;
    &lt;artifactId&gt;SMOTE&lt;/artifactId&gt;
    &lt;version&gt;1.0.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>SMOTE采样实现代码如下：</p>
<pre><code>public static Instances SMOTESample(Instances data,int normalElemFlag) {
        SMOTE convert = new SMOTE();
        int seed = (int) (Math.random() * 10);
        String[] options = {&quot;-S&quot;, String.valueOf(seed), &quot;-P&quot;, &quot;100.0&quot;, &quot;-K&quot;, &quot;5&quot;};
        Instances SmoteInstances = null;
        try {
            convert.setOptions(options);
            convert.setInputFormat(data);
            SmoteInstances = Filter.useFilter(data, convert);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return SmoteInstances;
    }
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###机器学习weka（一）&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="weka" scheme="http://yoursite.com/tags/weka/"/>
    
  </entry>
  
  <entry>
    <title>Object类有哪些方法</title>
    <link href="http://yoursite.com/2016/09/25/Object%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/09/25/Object类有哪些方法/</id>
    <published>2016-09-25T15:52:26.000Z</published>
    <updated>2016-09-25T15:56:27.683Z</updated>
    
    <content type="html"><![CDATA[<p>ps：上周面试中科院，被问到object类有哪些方法。当时一脸懵逼没有反应过来，做以下记录。</p>
<pre><code>clone();
equals();
finalize();
getClass();
notify(),notifyAll();
hashCode();
toString();
wait();
</code></pre><p>摘要如下：</p>
<pre><code>protected  Object    clone() //创建并返回此对象的一个副本。
boolean    equals(Object obj) //指示某个其他对象是否与此对象“相等”。
protected  void    finalize() //当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。
Class&lt;? extends Object&gt;    getClass() //返回一个对象的运行时类。
int    hashCode() //返回该对象的哈希码值。
void    notify() //唤醒在此对象监视器上等待的单个线程。
void    notifyAll() //唤醒在此对象监视器上等待的所有线程。
String    toString()  //返回该对象的字符串表示。
void    wait() //导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。
void    wait(long timeout) //导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。
void    wait(long timeout, int nanos) //导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ps：上周面试中科院，被问到object类有哪些方法。当时一脸懵逼没有反应过来，做以下记录。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;clone();
equals();
finalize();
getClass();
notify(),notifyAll();
hashCode()
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java多线程</title>
    <link href="http://yoursite.com/2016/09/25/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/09/25/java多线程/</id>
    <published>2016-09-25T15:43:30.000Z</published>
    <updated>2016-09-25T15:46:03.440Z</updated>
    
    <content type="html"><![CDATA[<p>线程和进程有什么区别？</p>
<p>答：一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。</p>
<p>如何在Java中实现线程？</p>
<p>答：<br>创建线程有两种方式：</p>
<ol>
<li>一、继承 Thread 类，扩展线程。</li>
<li>二、实现 Runnable 接口。</li>
</ol>
<p>启动一个线程是调用run()还是start()方法？</p>
<p>答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。</p>
<p>Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</p>
<ul>
<li>sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。</li>
<li>wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</li>
</ul>
<p>线程的sleep()方法和yield()方法有什么区别？</p>
<p>答：</p>
<ul>
<li>① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</li>
<li>② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；</li>
<li>③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；</li>
<li>④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。</li>
</ul>
<p>请说出与线程同步以及线程调度相关的方法。<br>答：</p>
<ul>
<li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</li>
<li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；</li>
<li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；</li>
<li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线程和进程有什么区别？&lt;/p&gt;
&lt;p&gt;答：一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>oracle</title>
    <link href="http://yoursite.com/2016/09/25/oracle/"/>
    <id>http://yoursite.com/2016/09/25/oracle/</id>
    <published>2016-09-25T14:14:27.000Z</published>
    <updated>2016-09-25T14:28:12.599Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>很少使用oracle，记录两个问题。</p>
<p>###1.在Maven仓库中添加Oracle JDBC驱动</p>
<p>由于Oracle授权问题，Maven不提供Oracle JDBC driver，为了在Maven项目中应用Oracle JDBC driver,必须手动添加到本地仓库。</p>
<p>1.获取oracle jdbc driver</p>
<ol>
<li>通过Oracle官方网站下载相应版本： <a href="http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html" target="_blank" rel="external">http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html</a></li>
<li>通过Oracle的安装目录获得，位置在“{ORACLE_HOME}\jdbc\lib\ojdbc14.jar</li>
</ol>
<p>2.安装到本地仓库</p>
<pre><code>mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=12.1.0.2 -Dpackaging=jar -Dfile=D:\Document_x64\Downloads\ojdbc14.jar
</code></pre><p>3.pom文件中添加引用</p>
<pre><code>&lt;dependency&gt;
&lt;groupId&gt;com.oracle&lt;/groupId&gt;
&lt;artifactId&gt;ojdbc7&lt;/artifactId&gt;
&lt;version&gt;12.1.0.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>###2. “ORA-00942: 表或视图不存在 “的原因和解决方法</p>
<p>产生的原因：<br>Oracle 是大小写敏感的，我们创自己写Sql脚本创建表的时候Oracle会自动将我们的表名，字段名转成大写,</p>
<pre><code>create table T_WindRadar  (
   wr_id                VARCHAR2(64)                    not null,
   wr_reciveTime        DATE,
   wr_image             BLOB,
   constraint PK_T_WINDRADAR primary key (wr_id)
);
</code></pre><p>但是 Oracle 同样支持”” 语法，将表名或字段名加上””后，Oracle不会将其转换成大写。</p>
<pre><code>create table &quot;T_WindRadar&quot;  (
   &quot;wr_id&quot;                VARCHAR2(64)                    not null,
   &quot;wr_reciveTime&quot;        DATE,
   &quot;wr_image &quot;            BLOB,
   constraint PK_T_WINDRADAR primary key (wr_id)
);
</code></pre><p>如果加上了””,那么我们采用一般的SQL语句查询则会产生“ORA-00942: 表或视图不存在 ”，因此SQL脚本中需要将表名也加上””。</p>
<pre><code>select * from  &quot;T_WindRadar&quot;;
</code></pre><p>这种情况在我们手写SQL的时候一般不会发生，但是我们使用powerdesigner设计数据库的时候，由于不注意会经常出现此类问题，因为Powerdesigner生成的SQL文件默认是加””的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;很少使用oracle，记录两个问题。&lt;/p&gt;
&lt;p&gt;###1.在Maven仓库中添加Oracle JDBC驱动&lt;/p&gt;
&lt;p&gt;由于Oracle授权问题，Maven不提供Oracle JDBC driver，为了在Maven项目中应用Ora
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>机器学习</title>
    <link href="http://yoursite.com/2016/09/25/k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2016/09/25/k-近邻算法/</id>
    <published>2016-09-25T05:39:12.000Z</published>
    <updated>2016-09-25T16:01:44.907Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>##k-近邻算法</p>
<p>####1.工作原理<br>存在一个样本数据集合，也成为训练样本集，并且样本集中每个数据都存在标签。加我们知道样本集中荷每一条数据玉所属分类之间的关系，输入没有标签的数据，将新数据的每个特征和样本数据进行比较然后算法提取出样本集中特征醉相思的数据的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据。最后，选择开个醉相思数据中出现次数最多的分类，作为新数据的分类。</p>
<p>####2.伪代码</p>
<ol>
<li>计算已知类别数据器中点与当前点之间的距离；</li>
<li>按照距离递增次序排序</li>
<li>选择与当前距离最小的k个点</li>
<li>确定前k个点所在类别的出现频率</li>
<li>返回前k个点出现的频率最高的类别作为当前点的预测分类</li>
</ol>
<p>##决策树</p>
<p>####1.优缺点</p>
<ul>
<li>优点：计算复杂度不高，对中间值的确实不敏感。可以处理不想管特征数据。</li>
<li>缺点：过度匹配问题</li>
</ul>
<p>##基于概率论的分类方法：朴素贝叶斯</p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;##k-近邻算法&lt;/p&gt;
&lt;p&gt;####1.工作原理&lt;br&gt;存在一个样本数据集合，也成为训练样本集，并且样本集中每个数据都存在标签。加我们知道样本集中荷每一条数据玉所属分类之间的关系，输入没有标签的数据，将新数据的每个特征和样本数据进行比
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>java泛型</title>
    <link href="http://yoursite.com/2016/09/23/java%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2016/09/23/java泛型/</id>
    <published>2016-09-23T12:52:12.000Z</published>
    <updated>2016-09-22T16:03:40.193Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>###一、泛型的由来<br>在1.5之后，Java引入了泛型(Generic)的概念，提供了一套抽象的类型表示方法。<br>利用泛型，我们可以；</p>
<p>1、表示多个可变类型之间的相互关系：HashMap<t,s>表示类型T与S的映射，HashMap<t, s="" extends="" t="">表示T的子类与T的映射关系</t,></t,s></p>
<p>2、细化类的能力：ArrayList<t> 可以容纳任何指定类型T的数据，当T代指人，则是人的有序列表，当T代指杯子，则是杯子的有序列表，所有对象个体可以共用相同的操作行为</t></p>
<p>3、简化代码实现：假设有一个执行过程，对不同类型的数据，进行某些流程一致的处理.</p>
<pre><code>public &lt;T&gt; void addToArray(T data, T array[], int pos) {  
    array[pos] = data;  
} 
</code></pre><p>###二、泛型用法<br>1.泛型类</p>
<p>2.泛型方法</p>
<p>###三、通配符<br>我们还可以赋予泛型参数不确定值，也就是通配符?。使用通配符?表示一个未知的类型。类似如下：</p>
<pre><code>List&lt;?&gt; list;存放任意的对象
List&lt;? extends AClass&gt; listSubAClass; //存放AClass的子类
List&lt;? extends BClass&gt; listSuperBClass; //存放BClass的父类
</code></pre><p>通配符不能用在泛型类和泛型方法声明中</p>
<p>###四、泛型关键字<br>1、泛型关键字有二个 extends和super，分别表示类型上界和类型下界<br><code>T extends AClass</code> 表示T继承自AClass类<br><code>? super AClass</code> 表示?是AClass的父类，注意：super只能与通配符?搭配使用，我们不能写：</p>
<pre><code>public class GenericClass&lt;T super AClass&gt; { //错误
}
</code></pre><p>此例子中super换成extends是正确的，表示泛型T继承自AClass，T换成通配符?也是可以的，表示未知类型的下界是AClass。</p>
<p>###五、泛型的应用<br>java泛型的最深入人心的应用就是容器（Collections）了。容器不需要考虑它要装什么东西，它的职责就是表达它装的东西的集合所具有的功能。因此是天然的泛型支持者。</p>
<p>JAVA的容器—List,Map,Set<br>Collection </p>
<p>├List<br>│├LinkedList<br>│├ArrayList<br>│└Vector<br>│　└Stack<br>└Set </p>
<p>Map<br>├Hashtable<br>├HashMap<br>└WeakHashMap</p>
<p><img src="http://i.imgur.com/QIEylMe.jpg" alt=""></p>
<p>LinkedList ：其数据结构采用的是链表，此种结构的优势是删除和添加的效率很高，但随机访问元素时效率较ArrayList类低。</p>
<p>ArrayList：其数据结构采用的是线性表，此种结构的优势是访问和查询十分方便，但添加和删除的时候效率很低。</p>
<p>HashSet: Set类不允许其中存在重复的元素（集），无法添加一个重复的元素（Set中已经存在）。HashSet利用Hash函数进行了查询效率上的优化，其contain（）方法经常被使用，以用于判断相关元素是否已经被添加过。</p>
<p>HashMap: 提供了key-value的键值对数据存储机制，可以十分方便的通过键值查找相应的元素，而且通过Hash散列机制，查找十分的方便。</p>
<p>1.ArrayList和LinkedList有什么区别？<br>ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。</p>
<p>相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。</p>
<p>LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</p>
<p>2.HashSet和TreeSet有什么区别？</p>
<p>HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。</p>
<p>另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)</p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;###一、泛型的由来&lt;br&gt;在1.5之后，Java引入了泛型(Generic)的概念，提供了一套抽象的类型表示方法。&lt;br&gt;利用泛型，我们可以；&lt;/p&gt;
&lt;p&gt;1、表示多个可变类型之间的相互关系：HashMap&lt;t,s&gt;表示类型T与S的映
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java杂记</title>
    <link href="http://yoursite.com/2016/09/23/java%E6%9D%82%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/09/23/java杂记/</id>
    <published>2016-09-23T12:52:12.000Z</published>
    <updated>2016-10-19T02:50:29.895Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>1.ArrayList和LinkedList有什么区别？<br>ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。</p>
<p>相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。</p>
<p>LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</p>
<p>2.Comparable和Comparator接口是干什么的？列出它们的区别。</p>
<p>Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。</p>
<p>Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。</p>
<p>3.Enumeration接口和Iterator接口的区别有哪些？</p>
<p>Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。</p>
<p>4.HashSet和TreeSet有什么区别？</p>
<p>HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。</p>
<p>另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)</p>
<p>###JDBC</p>
<p>8.什么是JDBC？</p>
<p>JDBC是允许用户在不同数据库之间做选择的一个抽象层。JDBC允许开发者用JAVA写数据库应用程序，而不需要关心底层特定数据库的细节。</p>
<p>9.PreparedStatement比Statement有什么优势？</p>
<p>PreparedStatements是预编译的，因此，性能会更好。同时，不同的查询参数值，PreparedStatement可以重用。</p>
<p>10.什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？</p>
<p>CallableStatement用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。准备一个CallableStatement的方法是：</p>
<pre><code>CallableStament.prepareCall();
</code></pre><hr>
<p>##一.GC<br>Java中的垃圾回收机制</p>
<p>####GC针对什么对象？<br>了解GC机制的第一步就是理解什么样的对象会被回收。当一个对象通过一系列根对象(比如：静态属性引用的常量)都不可达时就会被回收。简而言之，当一个对象的所有引用都为null。循环依赖不算做引用，如果对象A有一个指向对象B的引用，对象B也有一个指向对象A的引用，除此之外，它们没有其他引用，那么对象A和对象B都、需要被回收(如下图,ObjA和ObjB需要被回收)。</p>
<p>####堆内存是如何划分的？</p>
<p>Java中对象都在堆上创建。为了GC，堆内存分为三个部分，也可以说三代，分别称为新生代，老年代和永久代。其中新生代又进一步分为Eden区，Survivor 1区和Survivor 2区(如下图)。新创建的对象会分配在Eden区,在经历一次Minor GC后会被移到Survivor 1区，再经历一次Minor GC后会被移到Survivor 2区，直到升至老年代,需要注意的是，一些大对象(长字符串或数组)可能会直接存放到老年代。</p>
<p><img src="http://i.imgur.com/KU1IyMG.png" alt=""></p>
<hr>
<p>##二.hashmap</p>
<p>原文链接：<a href="http://yemengying.com/2016/05/07/threadsafe-hashmap/" target="_blank" rel="external">http://yemengying.com/2016/05/07/threadsafe-hashmap/</a></p>
<p>####hashmap的自动扩容机制<br>HashMap 内部的 Node 数组默认的大小是16，假设有100万个元素，那么最好的情况下每个 hash 桶里都有62500个元素😱，这时get(),put(),remove()等方法效率都会降低。为了解决这个问题，HashMap 提供了自动扩容机制，当元素个数达到数组大小 loadFactor 后会扩大数组的大小，在默认情况下，数组大小为16，loadFactor 为0.75，也就是说当 HashMap 中的元素超过16\0.75=12时，会把数组大小扩展为2*16=32，并且重新计算每个元素在新数组中的位置。</p>
<p>####为什么线程不安全<br>个人觉得 HashMap 在并发时可能出现的问题主要是两方面,首先如果多个线程同时使用put方法添加元素，而且假设正好存在两个 put 的 key 发生了碰撞(根据 hash 值计算的 bucket 一样)，那么根据 HashMap 的实现，这两个 key 会添加到数组的同一个位置，这样最终就会发生其中一个线程的 put 的数据被覆盖。第二就是如果多个线程同时检测到元素个数超过数组大小* loadFactor ，这样就会发生多个线程同时对 Node 数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给 table，也就是说其他线程的都会丢失，并且各自线程 put 的数据也丢失。</p>
<p>关于 HashMap 线程不安全这一点，《Java并发编程的艺术》一书中是这样说的：</p>
<blockquote>
<p>HashMap 在并发执行 put 操作时会引起死循环，导致 CPU 利用率接近100%。因为多线程会导致 HashMap 的 Node 链表形成环形数据结构，一旦形成环形数据结构，Node 的 next 节点永远不为空，就会在获取 Node 时产生死循环。死循环并不是发生在 put 操作时，而是发生在扩容时。</p>
</blockquote>
<p>####如何安全的使用hashmap</p>
<ul>
<li>Hashtable</li>
<li>ConcurrentHashMap</li>
<li>Synchronized Map</li>
</ul>
<pre><code>//Hashtable
Map&lt;String, String&gt; hashtable = new Hashtable&lt;&gt;();

//synchronizedMap
Map&lt;String, String&gt; synchronizedHashMap = Collections.synchronizedMap(new HashMap&lt;String, String&gt;());

//ConcurrentHashMap
Map&lt;String, String&gt; concurrentHashMap = new ConcurrentHashMap&lt;&gt;();
</code></pre><p>hashtable通过使用 <em>synchronized</em>来保证线程安全。</p>
<p>concurrenthashmap：</p>
<ul>
<li>CHM允许并发的读和线程安全的更新操作</li>
<li>在执行写操作时，CHM只锁住部分的Map</li>
<li>并发的更新是通过内部根据并发级别将Map分割成小部分实现的</li>
<li>高的并发级别会造成时间和空间的浪费，低的并发级别在写线程多时会引起线程间的竞争</li>
<li>CHM的所有操作都是线程安全</li>
<li>CHM返回的迭代器是弱一致性，fail-safe并且不会抛出ConcurrentModificationException异常</li>
<li>CHM不允许null的键值</li>
<li>可以使用CHM代替HashTable，但要记住CHM不会锁住整个Map</li>
</ul>
<p>Synchronized Map：<br>从源码中可以看出调用 synchronizedMap() 方法后会返回一个 SynchronizedMap 类的对象，而在 SynchronizedMap 类中使用了 synchronized 同步关键字来保证对 Map 的操作是线程安全的。</p>
<p>####hashmap如何解决冲突<br>其实就是链接法，将索引值相同的元素存放到一个单链表里。但为了解决在频繁冲突时HashMap性能降低的问题，Java 8中做了一个小优化，在冲突的元素个数超过设定的值(默认为8)时，会使用平衡树来替代链表存储冲突的元素。</p>
<hr>
<p>##三.java创建对象有哪几种</p>
<ul>
<li>new</li>
<li>工厂模式</li>
<li>反射</li>
<li>克隆</li>
</ul>
<p>#四.java反射详解<br>原文链接：<a href="http://www.jianshu.com/p/53eb4e16d00e" target="_blank" rel="external">http://www.jianshu.com/p/53eb4e16d00e</a></p>
<p>####什么是反射</p>
<p> 主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。<br> 反射是java中一种强大的工具，能够使我们很方便的创建灵活的代码，这些代码可以再运行时装配，无需在组件之间进行源代码链接。但是反射使用不当会成本很高！<br>反射（Reflection）能够让运行于 JVM 中的程序检测和修改运行时的行为</p>
<p>反射机制的作用：</p>
<ol>
<li>反编译：.class–&gt;.java</li>
<li><p>通过反射机制访问java对象的属性，方法，构造方法等；</p>
<pre><code>String s = &quot;java.util.Date&quot;;
   Object m = Class.forName(s).newInstance();
</code></pre><p>####为什么需要反射<br>通过反射，我们能够</p>
</li>
</ol>
<ul>
<li>在运行时检测对象的类型；</li>
<li>动态构造某个类的对象；</li>
<li>检测类的属性和方法；</li>
<li>任意调用对象的方法；</li>
<li>修改构造函数、方法、属性的可见性。</li>
</ul>
<p>JUnit通过反射来遍历包含 @Test 注解的方法，并在运行单元测试时调用它们。</p>
<p>Web框架<br>开发人员可以在配置文件中定义对各种接口和类的实现。通过反射机制，框架能够快速地动态初始化所需要的类。</p>
<p>Spring框架使用如下的配置文件：</p>
<pre><code>&lt;bean id=&quot;someID&quot; class=&quot;com.programcreek.Foo&quot;&gt;
    &lt;property name=&quot;someField&quot; value=&quot;someValue&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>当Spring容器处理 bean 元素时，会使用Class.forName(“com.programcreek.Foo”)来初始化这个类，并再次使用反射获取 property 元素对应的setter方法，为对象的属性赋值。</p>
<hr>
<p>##五.异常<br>5.throw和throws有什么区别？</p>
<p>throw关键字用来在程序中明确的抛出异常，相反，throws语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。</p>
<p>6.Java中Exception和Error有什么区别？</p>
<p>Exception和Error都是Throwable的子类。Exception用于用户程序可以捕获的异常情况。Error定义了不期望被用户程序捕获的异常。</p>
<p>7.Java中的两种异常类型是什么？他们有什么区别？</p>
<p>Java中有两种异常：受检查的(checked)异常和不受检查的(unchecked)异常。不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。相反，受检查的异常必须要用throws语句在方法或者是构造函数上声明。<br><img src="http://i.imgur.com/hUwjIXa.jpg" alt=""></p>
<p>##六.spring相关</p>
<p>spring的核心 ioc和aop</p>
<p>Spring Bean的生命周期（非常详细）<a href="http://www.cnblogs.com/zrtqsk/p/3735273.html" target="_blank" rel="external">http://www.cnblogs.com/zrtqsk/p/3735273.html</a></p>
<p>####spring中用到的设计模式<br>工厂模式:IOC容器<br>代理模式:AOP<br>策略模式:在spring采取动态代理时，根据代理的类有无实现接口有JDK和CGLIB两种代理方式，就是采用策略模式实现的<br>单例模式:默认情况下spring中的bean只存在一个实例<br>只知道这四个。。。。</p>
<p>####讲一讲Spring IoC和AOP<br>IoC的核心是依赖反转，将创建对象和对象之间的依赖管理交给IoC容器来做，完成对象之间的解耦。<br>AOP主要是利用代理模式，把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。</p>
<p>权限，日志，处理异常，事务等等，个人理解就是把许多接口都要用的又和接口本身主要的业务逻辑无关的部分抽出来，写成一个切面，单独维护，比如权限验证。这样可以使接口符合“单一职责原则”，只关注主要的业务逻辑，也提高了代码的重用性。</p>
<p>####Spring中编码统一要如何做<br>配置一个拦截器</p>
<pre><code>&lt;filter&gt;  
       &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;  
       &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;  
       &lt;init-param&gt;  
           &lt;param-name&gt;encoding&lt;/param-name&gt;  
           &lt;param-value&gt;UTF-8&lt;/param-value&gt;  
       &lt;/init-param&gt;  
       &lt;init-param&gt;  
           &lt;param-name&gt;forceEncoding&lt;/param-name&gt;  
           &lt;param-value&gt;true&lt;/param-value&gt;  
       &lt;/init-param&gt;  
   &lt;/filter&gt;  
   &lt;filter-mapping&gt;  
       &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;  
       &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  
   &lt;/filter-mapping&gt;
</code></pre><hr>
<p>##七.数据库相关</p>
<p>###mysql索引原理</p>
<p>来源：美团点评技术团队<a href="http://tech.meituan.com/mysql-index.html" target="_blank" rel="external">http://tech.meituan.com/mysql-index.html</a></p>
<p>####详解b+树</p>
<p><img src="http://i.imgur.com/iFzh0Ub.jpg" alt=""></p>
<p>如上图，是一颗b+树，关于b+树的定义可以参见B+树，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p>
<p>####b+树的查找过程<br>如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p>
<p>####b+树性质<br>1.通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</p>
<p>2.当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p>
<p>####建索引的几大原则</p>
<ol>
<li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>
<li>尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</li>
<li>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</li>
</ol>
<p>####mysql分页优化<br>ps：吐槽下，饿了么面试问我，但是呢。我压根没优化过…<br>参考另一个。</p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;1.ArrayList和LinkedList有什么区别？&lt;br&gt;ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java类的连接与初始化</title>
    <link href="http://yoursite.com/2016/09/22/java%E7%B1%BB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2016/09/22/java类的连接和初始化/</id>
    <published>2016-09-22T12:52:12.000Z</published>
    <updated>2016-09-22T12:41:54.573Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>Java虚拟机通过装载、连接、初始化来使得一个Java类型可以被Java程序所使用，如下图所示，其中连接过程又分为验证、准备、解析三个部分。其中部分类的解析过程可以推迟到程序真正使用其某个符号引用时再去解析。</p>
<p><img src="http://i.imgur.com/kQuMdeK.png" alt=""></p>
<p>解析过程可以推迟到累的初始化之后进行，但这是有条件的，java虚拟机必须在每个类或借口主动使用时进行初始化。<br>以下为主动使用的情况：</p>
<ul>
<li>(1).(无论直接通过new创建出来的，还是通过反射、克隆、序列化创建的)创建某个类新的实例</li>
<li>(2).使用某个类的静态方法</li>
<li>(3).访问某个类或接口的静态字段</li>
<li>(4).调用JavaAPI中的某些反射方法</li>
<li>(5).初始化某个类的子类(要求其祖先类都要被初始化，否则无法正确访问其继承的成员)</li>
<li>(6).启动某个标明为启动类的类(含有main()方法)</li>
</ul>
<p>主动使用会导致类的初始化，其超类均将在该类的初始化之前被初始化，但通过子类访问父类的静态字段或方法时，对于子类(或子接口、接口的实现类)来说，这种访问就是被动访问，或者说访问了该类(接口)中的不在该类(接口)中声明的静态成员。</p>
<p>如：<br>Grandpa的定义如下：<br>    package com.ice.passiveaccess;</p>
<pre><code>public class Grandpa {
    static{
        System.out.println(&quot;Grandpa was initialized.&quot;);
    }
}
</code></pre><p>Parent的定义如下：<br>    package com.ice.passiveaccess;</p>
<pre><code>public class Parent extends Grandpa{
    static String language = &quot;Chinese&quot;;
    static{
        System.out.println(&quot;Parent was initialized.&quot;);
    }
}
</code></pre><p>Cindy的定义如下：<br>    package com.ice.passiveaccess;</p>
<pre><code>public class Cindy extends Parent{
    static{
        System.out.println(&quot;Child was initialized.&quot;);
    }
}
</code></pre><p>现在通过Cindy访问父类的language成员</p>
<pre><code>package com.ice.passiveaccess;

public class PassiveAccessTest {
    public static void main(String args[]){
        System.out.println(Cindy.language);
    }
}
</code></pre><p>结果如下：</p>
<pre><code>Grandpa was initialized.
Parent was initialized.
Chinese
</code></pre><p>可见这是被动访问，Cindy自身并没有初始化</p>
<p>下面简要介绍装载、验证与初始化过程：<br>1.装载：</p>
<ul>
<li>(1).找到该类型的class文件，产生一个该类型的class文件二进制数据流(ClassLoader需要实现的loadClassData()方法)</li>
<li>(2).解析该二进制数据流为方法区内的数据结构</li>
<li>(3).创建一个该类型的java.lang.Class实例</li>
<li>在加载器的相关代码中可以看到，最终通过defineClass()创建一个Java类型对象(Class对象)。</li>
</ul>
<p>2.验证：<br>class文件校验器需要四趟独立的扫描来完成验证工作，其中：</p>
<p>第一趟扫描在装载时进行，会对class文件进行结构检查，如</p>
<blockquote>
<p>(1).对魔数进行检查，以判断该文件是否是一个正常的class文件<br>(2).对主次版本号进行检查，以判断class文件是否与java虚拟机兼容。<br>(3).对class文件的长度和类型进行检查，避免class文件部分缺失或被附加内容。</p>
</blockquote>
<p>第二趟扫描在连接过程中进行，会对类型数据进行语义检查，主要检查各个类的二进制兼容性(主要是查看超类和子类的关系)和类本身是否符合特定的语义条件</p>
<blockquote>
<p>(1).final类不能拥有子类<br>(2).final方法不能被重写(覆盖)<br>(3).子类和超类之间没有不兼容的方法声明<br>(4).检查常量池入口类型是否一致(如CONSTANT_Class常量池的内容是否指向一个CONSTANT_Utf8字符串常量池)<br>(5).检查常量池的所有特殊字符串，以确定它们是否是其所属类型的实例，以及是否符合特定的上下文无关语法、格式</p>
</blockquote>
<p>第三趟扫描为字节码验证，其验证内容和实现较为复杂，主要检验字节码是否可以被java虚拟机安全地执行。</p>
<p>第四趟扫描在解析过程中进行，为对符号引用的验证。在动态连接过程中，通过保存在常量池的符号引用查找被引用的类、接口、字段、方法时，在把符号引用替换成直接引用时，首先需要确认查找的元素真正存在，然后需要检查访问权限、查找的元素是否是静态类成员而非实例成员。</p>
<p>3.准备：</p>
<p>为类变量分配内存、设置默认初始值(内存设置初始值，而非对类变量真正地进行初始化，即类中声明int i = 5，但实际上这里是分配内存并设置初始值为0)</p>
<p>4.解析：</p>
<p>在类的常量池中寻找类、接口、字段、方法的符号引用，将这些符号引用替换成直接引用</p>
<p>5.初始化</p>
<p>对类变量赋予指定的初始值(这个时候int i = 5就必须赋予i以初值5)。这个初始值的给定方式有两种，一种是通过类变量的初始化语句，一种是静态初始化语句。而这些初始化语句都将被Java编译器一起放在方法中。<br>如前面所述，一个类的初始化需要初始化其直接超类，并递归初始化其祖先类，初始化是通过调用类的初始化方法完成的。此外，对于接口，并不需要初始化其父接口，而只需要执行该接口的接口初始化方法就可以了。</p>
<p>注意：</p>
<p>(1). 在初始化阶段，只会为类变量(静态全局变量)进行初始化工作，并且当类变量声明为final类型切初始化语句采用了常量表达式方式进行初始化赋值，那么， 也不会对其进行初始化，它将会直接被编译器计算并保存在常量池中，并且对这些变量的使用也将直接将其变量值嵌入到字节码中。</p>
<p>(2).接口的初始化与类有所不同，在初始化阶段，会为在接口中声明的所有public、static和final类型的、无法被编译为常量的字段进行初始化</p>
<p>6.类实例化</p>
<p>这里需要明白什么是类初始化，什么是类实例化，以及类的实例对象的初始化<br>如前面所述，类初始化时对类(静态)变量赋予指定的初始值，类初始化之后就可以访问类的静态字段和方法，而访问类的非静态(实例)字段和方法，就需要创建类的对象实例，故类的实例化是在类的初始化之后，是在堆上创建一个该类的对象。</p>
<p>类的静态方法和字段属于类，作为类型数据保存在方法区，其生命周期取决于类，而实例方法和字段位于Java堆，其生命周期取决于对象的生命周期。
　　</p>
<p>类的初始化会从祖先类到子类、按出现顺序，对类变量的初始化语句、静态初始化语句块依次进行初始化。而对类实例的初始化也类似，会从祖先类到子类、按出现顺序，对类成员的初始化语句、实例初始化块、构造方法依次进行初始化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Java虚拟机通过装载、连接、初始化来使得一个Java类型可以被Java程序所使用，如下图所示，其中连接过程又分为验证、准备、解析三个部分。其中部分类的解析过程可以推迟到程序真正使用其某个符号引用时再去解析。&lt;/p&gt;
&lt;p&gt;&lt;img sr
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql分页优化</title>
    <link href="http://yoursite.com/2016/09/22/mysql%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2016/09/22/mysql分页优化/</id>
    <published>2016-09-22T12:52:12.000Z</published>
    <updated>2016-09-22T08:58:07.172Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL的limit工作原理就是先读取n条记录，然后抛弃前n条，读m条想要的，所以n越大，性能会越差。<br><a id="more"></a></p>
<p>1.基本分页</p>
<pre><code>select * from Member limit 10, 100;  
#m表示要显示的页数，n表示显示的记录行数
</code></pre><p>2.子查询优化</p>
<pre><code>select * from Member where MemberID &gt;= (select MemberID from Member limit 100000,1) limit 100; 
</code></pre><p>3.反向查找</p>
<p>当偏移量大大于一半</p>
<pre><code>SELECT * FROM `abc` WHERE `BatchID` = 123 LIMIT 1199960, 40  
#时间：2.6493s
SELECT * FROM `abc` WHERE `BatchID` = 123 ORDER BY InputDate DESC LIMIT 428775, 40
#1.0035
</code></pre><p>4.limit限制优化法 </p>
<p>把limit偏移量限制低于某个数。。超过这个数等于没数据.<br>ps:…..</p>
<p>5.优化limit和offset </p>
<p>MySQL的limit工作原理就是先读取n条记录，然后抛弃前n条，读m条想要的，所以n越大，性能会越差。<br>优化前SQL: <code>SELECT * FROM member ORDER BY last_active LIMIT 50,5</code><br>优化后SQL:<code>SELECT * FROM member INNER JOIN (SELECT member_id FROM member ORDER BY last_active LIMIT 50, 5) USING (member_id)</code><br>分别在于，优化前的SQL需要更多I/O浪费，因为先读索引，再读数据，然后抛弃无需的行。而优化后的SQL(子查询那条)只读索引(Cover index)就可以了，然后通过member_id读取需要的列。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL的limit工作原理就是先读取n条记录，然后抛弃前n条，读m条想要的，所以n越大，性能会越差。&lt;br&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>Java集合</title>
    <link href="http://yoursite.com/2016/09/22/java%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2016/09/22/java集合/</id>
    <published>2016-09-22T12:52:12.000Z</published>
    <updated>2016-09-22T16:13:47.709Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>1.Java集合框架是什么？说出一些集合框架的优点？</p>
<p>每种编程语言中都有集合，最初的Java版本包含几种集合类：Vector、Stack、HashTable和Array。随着集合的广泛使用，Java1.2提出了囊括所有集合接口、实现和算法的集合框架。在保证线程安全的情况下使用泛型和并发集合类，Java已经经历了很久。它还包括在Java并发包中，阻塞接口以及它们的实现。集合框架的部分优点如下：</p>
<p>（1）使用核心集合类降低开发成本，而非实现我们自己的集合类。</p>
<p>（2）随着使用经过严格测试的集合框架类，代码质量会得到提高。</p>
<p>（3）通过使用JDK附带的集合类，可以降低代码维护成本。</p>
<p>（4）复用性和可操作性。</p>
<p>2.集合框架中的泛型有什么优点？</p>
<p>Java1.5引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现ClassCastException，因为你将会在编译时得到报错信息。泛型也使得代码整洁，我们不需要使用显式转换和instanceOf操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。</p>
<p>3.Java集合框架的基础接口有哪些？</p>
<p>Collection为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java平台不提供这个接口任何直接的实现。</p>
<p>Set是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。</p>
<p>List是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List更像长度动态变换的数组。</p>
<p>Map是一个将key映射到value的对象.一个Map不能包含重复的key：每个key最多只能映射一个value。</p>
<p>一些其它的接口有Queue、Dequeue、SortedSet、SortedMap和ListIterator。</p>
<p>4.为何Collection不从Cloneable和Serializable接口继承？</p>
<p>Collection接口指定一组对象，对象即为它的元素。如何维护这些元素由Collection的具体实现决定。例如，一些如List的Collection实现允许重复的元素，而其它的如Set就不允许。很多Collection实现有一个公有的clone方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为Collection是一个抽象表现。重要的是实现。</p>
<p>当与具体实现打交道的时候，克隆或序列化的语义和含义才发挥作用。所以，具体实现应该决定如何对它进行克隆或序列化，或它是否可以被克隆或序列化。</p>
<p>在所有的实现中授权克隆和序列化，最终导致更少的灵活性和更多的限制。特定的实现应该决定它是否可以被克隆和序列化。</p>
<p>5.为何Map接口不继承Collection接口？</p>
<p>尽管Map接口和它的实现也是集合框架的一部分，但Map不是集合，集合也不是Map。因此，Map继承Collection毫无意义，反之亦然。</p>
<p>如果Map继承Collection接口，那么元素去哪儿？Map包含key-value对，它提供抽取key或value列表集合的方法，但是它不适合“一组对象”规范。</p>
<p>6.Iterator是什么？</p>
<p>Iterator接口提供遍历任何Collection的接口。我们可以从一个Collection中使用迭代器方法来获取迭代器实例。迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者在迭代过程中移除元素。</p>
<p>7.Enumeration和Iterator接口的区别？</p>
<p>Enumeration的速度是Iterator的两倍，也使用更少的内存。Enumeration是非常基础的，也满足了基础的需要。但是，与Enumeration相比，Iterator更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。</p>
<p>迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者从集合中移除元素，而Enumeration不能做到。为了使它的功能更加清晰，迭代器方法名已经经过改善。</p>
<p>8.为何没有像Iterator.add()这样的方法，向集合中添加元素？</p>
<p>语义不明，已知的是，Iterator的协议不能确保迭代的次序。然而要注意，ListIterator没有提供一个add操作，它要确保迭代的顺序。</p>
<p>9.为何迭代器没有一个方法可以直接获取下一个元素，而不需要移动游标？</p>
<p>它可以在当前Iterator的顶层实现，但是它用得很少，如果将它加到接口中，每个继承都要去实现它，这没有意义。</p>
<p>10.Iterater和ListIterator之间有什么区别？</p>
<p>（1）我们可以使用Iterator来遍历Set和List集合，而ListIterator只能遍历List。</p>
<p>（2）Iterator只可以向前遍历，而LIstIterator可以双向遍历。</p>
<p>（3）ListIterator从Iterator接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p>
<p>11.遍历一个List有哪些不同的方式？</p>
<pre><code>List&lt;String&gt; strList = new ArrayList&lt;&gt;();
//使用for-each循环
for(String obj : strList){
  System.out.println(obj);
}
//using iterator
Iterator&lt;String&gt; it = strList.iterator();
while(it.hasNext()){
  String obj = it.next();
  System.out.println(obj);
}
</code></pre><p>使用迭代器更加线程安全，因为它可以确保，在当前遍历的集合元素被更改的时候，它会抛出ConcurrentModificationException。</p>
<p>12.通过迭代器fail-fast属性，你明白了什么？</p>
<p>每次我们尝试获取下一个元素的时候，Iterator fail-fast属性检查当前集合结构里的任何改动。如果发现任何改动，它抛出ConcurrentModificationException。Collection中所有Iterator的实现都是按fail-fast来设计的（ConcurrentHashMap和CopyOnWriteArrayList这类并发集合类除外）。</p>
<p>13.fail-fast与fail-safe有什么区别？</p>
<p>Iterator的fail-fast属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。Java.util包中的所有集合类都被设计为fail-fast的，而java.util.concurrent中的集合类都为fail-safe的。Fail-fast迭代器抛出ConcurrentModificationException，而fail-safe迭代器从不抛出ConcurrentModificationException。</p>
<p>14.在迭代一个集合的时候，如何避免ConcurrentModificationException？</p>
<p>在遍历一个集合的时候，我们可以使用并发集合类来避免ConcurrentModificationException，比如使用CopyOnWriteArrayList，而不是ArrayList。</p>
<p>15.为何Iterator接口没有具体的实现？</p>
<p>Iterator接口定义了遍历集合的方法，但它的实现则是集合实现类的责任。每个能够返回用于遍历的Iterator的集合类都有它自己的Iterator实现内部类。</p>
<p>这就允许集合类去选择迭代器是fail-fast还是fail-safe的。比如，ArrayList迭代器是fail-fast的，而CopyOnWriteArrayList迭代器是fail-safe的。</p>
<p>16.UnsupportedOperationException是什么？</p>
<p>UnsupportedOperationException是用于表明操作不支持的异常。在JDK类中已被大量运用，在集合框架java.util.Collections.UnmodifiableCollection将会在所有add和remove操作中抛出这个异常。</p>
<p>17.在Java中，HashMap是如何工作的？</p>
<p>HashMap在Map.Entry静态内部类实现中存储key-value对。HashMap使用哈希算法，在put和get方法中，它使用hashCode()和equals()方法。当我们通过传递key-value对调用put方法的时候，HashMap使用Key hashCode()和哈希算法来找出存储key-value对的索引。Entry存储在LinkedList中，所以如果存在entry，它使用equals()方法来检查传递的key是否已经存在，如果存在，它会覆盖value，如果不存在，它会创建一个新的entry然后保存。当我们通过传递key调用get方法时，它再次使用hashCode()来找到数组中的索引，然后使用equals()方法找出正确的Entry，然后返回它的值。下面的图片解释了详细内容。</p>
<p>其它关于HashMap比较重要的问题是容量、负荷系数和阀值调整。HashMap默认的初始容量是32，负荷系数是0.75。阀值是为负荷系数乘以容量，无论何时我们尝试添加一个entry，如果map的大小比阀值大的时候，HashMap会对map的内容进行重新哈希，且使用更大的容量。容量总是2的幂，所以如果你知道你需要存储大量的key-value对，比如缓存从数据库里面拉取的数据，使用正确的容量和负荷系数对HashMap进行初始化是个不错的做法。</p>
<p>18.hashCode()和equals()方法有何重要性？</p>
<p>HashMap使用Key对象的hashCode()和equals()方法去决定key-value对的索引。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。同样的，所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则：</p>
<p>（1）如果o1.equals(o2)，那么o1.hashCode() == o2.hashCode()总是为true的。</p>
<p>（2）如果o1.hashCode() == o2.hashCode()，并不意味着o1.equals(o2)会为true。</p>
<p>19.我们能否使用任何类作为Map的key？</p>
<p>我们可以使用任何类作为Map的key，然而在使用它们之前，需要考虑以下几点：</p>
<p>（1）如果类重写了equals()方法，它也应该重写hashCode()方法。</p>
<p>（2）类的所有实例需要遵循与equals()和hashCode()相关的规则。请参考之前提到的这些规则。</p>
<p>（3）如果一个类没有使用equals()，你不应该在hashCode()中使用它。</p>
<p>（4）用户自定义key类的最佳实践是使之为不可变的，这样，hashCode()值可以被缓存起来，拥有更好的性能。不可变的类也可以确保hashCode()和equals()在未来不会改变，这样就会解决与可变相关的问题了。</p>
<p>比如，我有一个类MyKey，在HashMap中使用它。</p>
<pre><code>//传递给MyKey的name参数被用于equals()和hashCode()中
MyKey key = new MyKey(&apos;Pankaj&apos;); //assume hashCode=1234
myHashMap.put(key, &apos;Value&apos;);
// 以下的代码会改变key的hashCode()和equals()值
key.setName(&apos;Amit&apos;); //assume new hashCode=7890
//下面会返回null，因为HashMap会尝试查找存储同样索引的key，而key已被改变了，匹配失败，返回null
myHashMap.get(new MyKey(&apos;Pankaj&apos;));
</code></pre><p>那就是为何String和Integer被作为HashMap的key大量使用。</p>
<p>20.Map接口提供了哪些不同的集合视图？</p>
<p>Map接口提供三个集合视图：</p>
<p>（1）Set keyset()：返回map中包含的所有key的一个Set视图。集合是受map支持的，map的变化会在集合中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若map被修改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。</p>
<p>（2）Collection values()：返回一个map中包含的所有value的一个Collection视图。这个collection受map支持的，map的变化会在collection中反映出来，反之亦然。当一个迭代器正在遍历一个collection时，若map被修改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。</p>
<p>（3）Set<map.entry<k,v>&gt; entrySet()：返回一个map钟包含的所有映射的一个集合视图。这个集合受map支持的，map的变化会在collection中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若map被修改了（除迭代器自身的移除操作，以及对迭代器返回的entry进行setValue外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。</map.entry<k,v></p>
<p>21.HashMap和HashTable有何不同？</p>
<p>（1）HashMap允许key和value为null，而HashTable不允许。</p>
<p>（2）HashTable是同步的，而HashMap不是。所以HashMap适合单线程环境，HashTable适合多线程环境。</p>
<p>（3）在Java1.4中引入了LinkedHashMap，HashMap的一个子类，假如你想要遍历顺序，你很容易从HashMap转向LinkedHashMap，但是HashTable不是这样的，它的顺序是不可预知的。</p>
<p>（4）HashMap提供对key的Set进行遍历，因此它是fail-fast的，但HashTable提供对key的Enumeration进行遍历，它不支持fail-fast。</p>
<p>（5）HashTable被认为是个遗留的类，如果你寻求在迭代的时候修改Map，你应该使用CocurrentHashMap。</p>
<p>22.如何决定选用HashMap还是TreeMap？</p>
<p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p>
<p>23.ArrayList和Vector有何异同点？</p>
<p>ArrayList和Vector在很多时候都很类似。</p>
<p>（1）两者都是基于索引的，内部由一个数组支持。</p>
<p>（2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。</p>
<p>（3）ArrayList和Vector的迭代器实现都是fail-fast的。</p>
<p>（4）ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问。</p>
<p>以下是ArrayList和Vector的不同点。</p>
<p>（1）Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。</p>
<p>（2）ArrayList比Vector快，它因为有同步，不会过载。</p>
<p>（3）ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</p>
<p>24.Array和ArrayList有何区别？什么时候更适合用Array？</p>
<p>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</p>
<p>Array是指定大小的，而ArrayList大小是固定的。</p>
<p>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。尽管ArrayList明显是更好的选择，但也有些时候Array比较好用。</p>
<p>（1）如果列表的大小已经指定，大部分情况下是存储和遍历它们。</p>
<p>（2）对于遍历基本数据类型，尽管Collections使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。</p>
<p>（3）如果你要使用多维数组，使用[][]比List<list<>&gt;更容易。</list<></p>
<p>25.ArrayList和LinkedList有何区别？</p>
<p>ArrayList和LinkedList两者都实现了List接口，但是它们之间有些不同。</p>
<p>（1）ArrayList是由Array所支持的基于一个索引的数据结构，所以它提供对元素的随机访问，复杂度为O(1)，但LinkedList存储一系列的节点数据，每个节点都与前一个和下一个节点相连接。所以，尽管有使用索引获取元素的方法，内部实现是从起始点开始遍历，遍历到索引的节点然后返回元素，时间复杂度为O(n)，比ArrayList要慢。</p>
<p>（2）与ArrayList相比，在LinkedList中插入、添加和删除一个元素会更快，因为在一个元素被插入到中间的时候，不会涉及改变数组的大小，或更新索引。</p>
<p>（3）LinkedList比ArrayList消耗更多的内存，因为LinkedList中的每个节点存储了前后节点的引用。</p>
<p>26.哪些集合类提供对元素的随机访问？</p>
<p>ArrayList、HashMap、TreeMap和HashTable类提供对元素的随机访问。</p>
<p>27.EnumSet是什么？</p>
<p>java.util.EnumSet是使用枚举类型的集合实现。当集合创建时，枚举集合中的所有元素必须来自单个指定的枚举类型，可以是显示的或隐示的。EnumSet是不同步的，不允许值为null的元素。它也提供了一些有用的方法，比如copyOf(Collection c)、of(E first,E…rest)和complementOf(EnumSet s)。</p>
<p>28.哪些集合类是线程安全的？</p>
<p>Vector、HashTable、Properties和Stack是同步类，所以它们是线程安全的，可以在多线程环境下使用。Java1.5并发API包括一些集合类，允许迭代时修改，因为它们都工作在集合的克隆上，所以它们在多线程环境中是安全的。</p>
<p>29.并发集合类是什么？</p>
<p>Java1.5并发包（java.util.concurrent）包含线程安全集合类，允许在迭代时修改集合。迭代器被设计为fail-fast的，会抛出ConcurrentModificationException。一部分类为：CopyOnWriteArrayList、 ConcurrentHashMap、CopyOnWriteArraySet。</p>
<p>30.BlockingQueue是什么？</p>
<p>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p>
<p>31.队列和栈是什么，列出它们的区别？</p>
<p>栈和队列两者都被用来预存储数据。java.util.Queue是一个接口，它的实现类在Java并发包中。队列允许先进先出（FIFO）检索元素，但并非总是这样。Deque接口允许从两端检索元素。</p>
<p>栈与队列很相似，但它允许对元素进行后进先出（LIFO）进行检索。</p>
<p>Stack是一个扩展自Vector的类，而Queue是一个接口。</p>
<p>32.Collections类是什么？</p>
<p>Java.util.Collections是一个工具类仅包含静态方法，它们操作或返回集合。它包含操作集合的多态算法，返回一个由指定集合支持的新集合和其它一些内容。这个类包含集合框架算法的方法，比如折半搜索、排序、混编和逆序等。</p>
<p>33.Comparable和Comparator接口是什么？</p>
<p>如果我们想使用Array或Collection的排序方法时，需要在自定义类里实现Java提供Comparable接口。Comparable接口有compareTo(T OBJ)方法，它被排序方法所使用。我们应该重写这个方法，如果“this”对象比传递的对象参数更小、相等或更大时，它返回一个负整数、0或正整数。但是，在大多数实际情况下，我们想根据不同参数进行排序。比如，作为一个CEO，我想对雇员基于薪资进行排序，一个HR想基于年龄对他们进行排序。这就是我们需要使用Comparator接口的情景，因为Comparable.compareTo(Object o)方法实现只能基于一个字段进行排序，我们不能根据对象排序的需要选择字段。Comparator接口的compare(Object o1, Object o2)方法的实现需要传递两个对象参数，若第一个参数比第二个小，返回负整数；若第一个等于第二个，返回0；若第一个比第二个大，返回正整数。</p>
<p>34.Comparable和Comparator接口有何区别？</p>
<p>Comparable和Comparator接口被用来对对象集合或者数组进行排序。Comparable接口被用来提供对象的自然排序，我们可以使用它来提供基于单个逻辑的排序。</p>
<p>Comparator接口被用来提供不同的排序算法，我们可以选择需要使用的Comparator来对给定的对象集合进行排序。</p>
<p>35.我们如何对一组对象进行排序？</p>
<p>如果我们需要对一个对象数组进行排序，我们可以使用Arrays.sort()方法。如果我们需要排序一个对象列表，我们可以使用Collection.sort()方法。两个类都有用于自然排序（使用Comparable）或基于标准的排序（使用Comparator）的重载方法sort()。Collections内部使用数组排序方法，所有它们两者都有相同的性能，只是Collections需要花时间将列表转换为数组。</p>
<p>36.当一个集合被作为参数传递给一个函数时，如何才可以确保函数不能修改它？</p>
<p>在作为参数传递之前，我们可以使用Collections.unmodifiableCollection(Collection c)方法创建一个只读集合，这将确保改变集合的任何操作都会抛出UnsupportedOperationException。</p>
<p>37.我们如何从给定集合那里创建一个synchronized的集合？</p>
<p>我们可以使用Collections.synchronizedCollection(Collection c)根据指定集合来获取一个synchronized（线程安全的）集合。</p>
<p>38.集合框架里实现的通用算法有哪些？</p>
<p>Java集合框架提供常用的算法实现，比如排序和搜索。Collections类包含这些方法实现。大部分算法是操作List的，但一部分对所有类型的集合都是可用的。部分算法有排序、搜索、混编、最大最小值。</p>
<p>39.大写的O是什么？举几个例子？</p>
<p>大写的O描述的是，就数据结构中的一系列元素而言，一个算法的性能。Collection类就是实际的数据结构，我们通常基于时间、内存和性能，使用大写的O来选择集合实现。比如：例子1：ArrayList的get(index i)是一个常量时间操作，它不依赖list中元素的数量。所以它的性能是O(1)。例子2：一个对于数组或列表的线性搜索的性能是O(n)，因为我们需要遍历所有的元素来查找需要的元素。</p>
<p>40.与Java集合框架相关的有哪些最好的实践？</p>
<p>（1）根据需要选择正确的集合类型。比如，如果指定了大小，我们会选用Array而非ArrayList。如果我们想根据插入顺序遍历一个Map，我们需要使用TreeMap。如果我们不想重复，我们应该使用Set。</p>
<p>（2）一些集合类允许指定初始容量，所以如果我们能够估计到存储元素的数量，我们可以使用它，就避免了重新哈希或大小调整。</p>
<p>（3）基于接口编程，而非基于实现编程，它允许我们后来轻易地改变实现。</p>
<p>（4）总是使用类型安全的泛型，避免在运行时出现ClassCastException。</p>
<p>（5）使用JDK提供的不可变类作为Map的key，可以避免自己实现hashCode()和equals()。</p>
<p>（6）尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的实现。它将会提供代码重用性，它有着更好的稳定性和可维护性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;1.Java集合框架是什么？说出一些集合框架的优点？&lt;/p&gt;
&lt;p&gt;每种编程语言中都有集合，最初的Java版本包含几种集合类：Vector、Stack、HashTable和Array。随着集合的广泛使用，Java1.2提出了囊括所有集合接
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
</feed>
