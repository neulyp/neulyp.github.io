<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lyp&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-17T07:38:12.607Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Loren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tcp3之连接</title>
    <link href="http://yoursite.com/2017/03/17/tcp3%E4%B9%8B%E8%BF%9E%E6%8E%A5/"/>
    <id>http://yoursite.com/2017/03/17/tcp3之连接/</id>
    <published>2017-03-17T12:52:12.000Z</published>
    <updated>2017-03-17T07:38:12.607Z</updated>
    
    <content type="html"><![CDATA[<p>ps：首先，tcp的行为对ip来说是不知道的。</p>
<p>在tcp中，面向连接的传输需要经过三个阶段，简历连接，数据传输，连接终止。</p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>TCP是TCP/IP的传输层控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:</p>
<p>首先需要了解几个名词：tcp标志位,有6种分别为：SYN(synchronous建立联机) 、ACK(acknowledgement 确认) 、PSH(push传送) 、FIN(finish结束)、 RST(reset重置) 、URG(urgent紧急);</p>
<ul>
<li>URG 紧急指针，告诉接收TCP模块紧要指针域指着紧要数据。</li>
<li>ACK 置1时表示确认号（为合法，为0的时候表示数据段不包含确认信息，确认号被忽略。 </li>
<li>PSH 置1时请求的数据段在接收方得到后就可直接送到应用程序，而不必等到缓冲区满时才传送。 </li>
<li>RST 置1时重建连接。如果接收到RST位时候，通常发生了某些错误。 </li>
<li>SYN 置1时用来发起一个连接。 </li>
<li>FIN 置1时表示发端完成发送任务。用来释放连接，表明发送方已经没有数据发送了。</li>
<li>另外还有 Sequence number(顺序号码) 、Acknowledge number(确认号码)在建立握手过程中发送的序列号。</li>
</ul>
<p>主机A(client)和主机B(server)开始建立握手过程：</p>
<ul>
<li>第一次握手：主机A发送位码为syn＝1,随机产生seq number=10001的数据包到服务器，主机B由SYN=1知道，A要求建立联机，此时状态为SYN_SENT；</li>
<li>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=20001的包，此时状态由LISTEN变为SYN_RECV；</li>
<li>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功，双方状态ESTABLISHED。</li>
</ul>
<p>完成三次握手，主机A与主机B开始传送数据。</p>
<p><img src="http://i.imgur.com/sNQUAgo.png" alt=""></p>
<p>syn洪泛攻击</p>
<p>当一个或多个而已的攻击者向某台服务器发送大量的syn报文段。并通过伪造报文段中的源ip地址来假装每一个报文段来自不同的客户时，这个问题就发生了。</p>
<p>一些策略：限定在指定时间内的连接请求次数，有些则吧来自不希望的原地址的数据报过滤掉。最近使用的一种策略是通过使用cookie，做到推迟资源分配，知道服务器核实是有效连接。在分配资源、</p>
<h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><ul>
<li>推送数据</li>
<li>紧急数据</li>
</ul>
<h3 id="连接终止"><a href="#连接终止" class="headerlink" title="连接终止"></a>连接终止</h3><p>目前，大多数tcp实现允许在连接终止时有两种选择：三向握手和具有半关闭选项的四向握手。</p>
<ul>
<li><p>三向握手</p>
</li>
<li><p>半关闭<br>在tcp中，连接的乙方停止发送数据，单仍然可以接收数据，称之为半关闭。</p>
</li>
</ul>
<h3 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h3><p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\8.jpg" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ps：首先，tcp的行为对ip来说是不知道的。&lt;/p&gt;
&lt;p&gt;在tcp中，面向连接的传输需要经过三个阶段，简历连接，数据传输，连接终止。&lt;/p&gt;
&lt;h3 id=&quot;建立连接&quot;&gt;&lt;a href=&quot;#建立连接&quot; class=&quot;headerlink&quot; title=&quot;建立连接&quot;&gt;&lt;/
    
    </summary>
    
      <category term="tcp-ip协议族" scheme="http://yoursite.com/categories/tcp-ip%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="tcpip" scheme="http://yoursite.com/tags/tcpip/"/>
    
  </entry>
  
  <entry>
    <title>tcp1之概述</title>
    <link href="http://yoursite.com/2017/03/17/tcp1%E4%B9%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2017/03/17/tcp1之概述/</id>
    <published>2017-03-17T12:52:12.000Z</published>
    <updated>2017-03-17T07:37:34.320Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>本章主要介绍一下几个目标</p>
<ol>
<li>介绍tcp这个能够提供可靠地流交付服务的协议</li>
<li>介绍tcp和udp的特点比较</li>
<li>定义tcp报文段的格式及其字段</li>
<li>tcp如何提供面向连接的服务</li>
<li>tcp状态转换图</li>
<li>tcp的流量控制和差错控制窗口</li>
<li>tcp计时器</li>
</ol>
<p> <img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\3.jpg" alt="image"></p>
<h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><ol>
<li>发送缓存和接收缓存</li>
</ol>
<p>因为发送进程和接受进程可能已不同的速度写入数据和读取数据，因此tcp需要用缓存存储数据。<br>一个发送缓存和一个接收缓存。</p>
<p> <img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\4.jpg" alt="image"></p>
<p>发送方：</p>
<ul>
<li>白色区域是空槽</li>
<li>深灰色是已经发送出去但还没有得到确认的字节</li>
<li>灰色表示将要发送的字节</li>
</ul>
<p>接收方：</p>
<ul>
<li>白色区域包含的空槽江北从网络中接受的字节填入。</li>
<li>灰色区域包含的是已经接收到的字节，这些字节将被接收进城读取。当一个字节被接受进程读取后，相应的槽就可以被回收，加入到空槽中。</li>
</ul>
<ol>
<li><p>报文段<br>ip层作为tcp的服务提供者，他必须以分组为单位发送数据，而不是字节。在传输层，tcp把若干字节组成一个分组，称之为报文段。</p>
</li>
<li><p>全双工通信</p>
</li>
</ol>
<p>数据可以同一时间双向流动。</p>
<ol>
<li>面向连接的服务</li>
<li>可靠地服务<br>tcp通过确认机制来检查数据是否安全完好的到达。</li>
</ol>
<p>tcp的特点：</p>
<ol>
<li>编号系统</li>
</ol>
<ul>
<li>字节号（0~2^32-1）</li>
<li>序号：字节被边上号以后，给每一个要发送的报文段指派一个序号。就是报文段中第一个数据字节的序号。</li>
<li>确认号：指他期望接受的下一个字节的编号。（它吧收到的最后一个完好的字节的编号加一为确认号）</li>
</ul>
<ol>
<li>流量控</li>
<li>差错控制（tcp的差错控制是面向字节的）</li>
<li>拥塞控制</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;p&gt;本章主要介绍一下几个目标&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;介绍tcp这个能够提供可靠地流交付服务的协议&lt;/li&gt;
&lt;li&gt;介绍tcp和udp的特点
    
    </summary>
    
      <category term="tcp-ip协议族" scheme="http://yoursite.com/categories/tcp-ip%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="tcpip" scheme="http://yoursite.com/tags/tcpip/"/>
    
  </entry>
  
  <entry>
    <title>tcp之滑动窗口及拥塞控制</title>
    <link href="http://yoursite.com/2017/03/17/tcp%E4%B9%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8F%8A%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2017/03/17/tcp之滑动窗口及拥塞控制/</id>
    <published>2017-03-17T12:52:12.000Z</published>
    <updated>2017-03-17T07:39:01.332Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TCP的滑动窗口机制"><a href="#TCP的滑动窗口机制" class="headerlink" title="TCP的滑动窗口机制"></a>TCP的滑动窗口机制</h4><p>TCP这个协议是网络中使用的比较广泛，他是一个面向连接的可靠的传输协议。既然是一个可靠的传输协议就需要对数据进行确认。TCP协议里窗口机制有2种：一种是固定的窗口大小；一种是滑动的窗口。这个窗口大小就是我们一次传输几个数据。对所有数据帧按顺序赋予编号，发送方在发送过程中始终保持着一个发送窗口，只有落在发送窗口内的帧才允许被发送；同时接收方也维持着一个接收窗口，只有落在接收窗口内的帧才允许接收。这样通过调整发送方窗口和接收方窗口的大小可以实现流量控制。</p>
<p>TCP滑动窗口技术通过动态改变窗口大小来调节两台主机间数据传输。每个TCP/IP主机支持全双工数据传输，因此TCP有两个滑动窗口：一个用于接收数据，另一个用于发送数据。TCP使用肯定确认技术，其确认号指的是下一个所期待的字节。 假定发送方设备以每一次三个数据包的方式发送数据，也就是说，窗口大小为3。发送方发送序列号为1、2、3的三个数据包，接收方设备成功接收数据包，用序列号4确认。发送方设备收到确认，继续以窗口大小3发送数据。当接收方设备要求降低或者增大网络流量时，可以对窗口大小进行减小或者增加，本例降低窗口大小为2，每一次发送两个数据包。当接收方设备要求窗口大小为0，表明接收方已经接收了全部数据，或者接收方应用程序没有时间读取数据，要求暂停发送。发送方接收到携带窗口号为0的确认，停止这一方向的数据传输。</p>
<p>固定窗口的坏处：</p>
<p>假设窗口的大小是1，也是就每次只能发送一个数据只有接受方对这个数据进行确认了以后才能发送第2个数据。我们可以看到发送方每发送一个数据接受方就要给发送方一个ACK对这个数据进行确认。只有接受到了这个确认数据以后发送方才能传输下个数据。 这样我们考虑一下如果说窗口过小，那么当传输比较大的数据的时候需要不停的对数据进行确认，这个时候就会造成很大的延迟。如果说窗口的大小定义的过大。我们假设发送方一次发送100个数据。但是接收方只能处理50个数据。这样每次都会只对这50个数据进行确认。发送方下一次还是发送100个数据，但是接受方还是只能处理50个数据。这样就避免了不必要的数据来拥塞我们的链路。所以我们就引入了滑动窗口机制，窗口的大小并不是固定的而是根据我们之间的链路的带宽的大小，这个时候链路是否拥护塞。接受方是否能处理这么多数据了。</p>
<p>滑动窗口如何工作：<br><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\1.png" alt="image"></p>
<p>首先是第一次发送数据这个时候的窗口大小是根据链路带宽的大小来决定的。我们假设这个时候窗口的大小是3。这个时候接受方收到数据以后会对数据进行确认告诉发送方我下次希望手到的是数据是多少。这里我们看到接收方发送的ACK=3(这是发送方发送序列2的回答确认，下一次接收方期望接收到的是3序列信号)。这个时候发送方收到这个数据以后就知道我第一次发送的3个数据对方只收到了2个。就知道第3个数据对方没有收到。下次在发送的时候就从第3个数据开始发。这个时候窗口大小就变成了2 。 </p>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\2.png" alt="image"></p>
<p>看到接收方发送的ACK是5就表示他下一次希望收到的数据是5，发送方就知道我刚才发送的2个数据对方收了这个时候开始发送第5个数据。<br>这就是滑动窗口的工作机制，当链路变好了或者变差了这个窗口还会发生变话，并不是第一次协商好了以后就永远不变了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TCP的滑动窗口机制&quot;&gt;&lt;a href=&quot;#TCP的滑动窗口机制&quot; class=&quot;headerlink&quot; title=&quot;TCP的滑动窗口机制&quot;&gt;&lt;/a&gt;TCP的滑动窗口机制&lt;/h4&gt;&lt;p&gt;TCP这个协议是网络中使用的比较广泛，他是一个面向连接的可靠的传输协议。既然
    
    </summary>
    
      <category term="tcp-ip协议族" scheme="http://yoursite.com/categories/tcp-ip%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="tcpip" scheme="http://yoursite.com/tags/tcpip/"/>
    
  </entry>
  
  <entry>
    <title>tcp2之报文段</title>
    <link href="http://yoursite.com/2017/03/17/tcp2%E4%B9%8B%E6%8A%A5%E6%96%87%E6%AE%B5/"/>
    <id>http://yoursite.com/2017/03/17/tcp2之报文段/</id>
    <published>2017-03-17T12:52:12.000Z</published>
    <updated>2017-03-17T07:37:54.022Z</updated>
    
    <content type="html"><![CDATA[<p>在更详细的讨论tcp之前 我们先来看看tcp的组成。</p>
<h3 id="报文段"><a href="#报文段" class="headerlink" title="报文段"></a>报文段</h3><p>报文段包括了20~60字节的首部和数据。首部在没有选项的时候是20字节，如果有选项最多可达60字节。</p>
<p> <img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\5.jpg" alt="image"></p>
<ul>
<li>源端口地址： 这是一个16位的字段，定义了发送这个报文段的主机中的应用程序的端口号。</li>
<li>目的端口地址：这是一个16位的字段，定义了接受这个报文段主机的应用端口</li>
<li>序号：本报文段第一个数据字节的编号</li>
<li>确认号</li>
<li>首部长度：这个4位字段支出tcp首部一共有多少个4字节字，首部长度为20-60.所以该字节范围为5-15</li>
<li>保留：这是一个6位字段，保留为今后使用</li>
<li>控制：这个字段定义了6中不同的控制位或标志。这些位用在tcp的流量控制建立连接和终止，数据传输等方面。</li>
<li>窗口大小：这个字段定义的是发送tcp的窗口大小哦，以字节为单位。请注意这个字段是16位。也就是窗口的最大长度是65535字节。这个值是接收窗口，由接收方决定。</li>
<li>检验和：这个16位字段包含的是检验和。udp是否使用检验和是可选的。而tcp使用检验和则是强制的。</li>
<li>紧急指针：只有当紧急标志位置位的时候，这个字段才生效。此时报文段包含了而紧急数据。</li>
<li>选项：tcp首部中可以有多大40字节的可选信息。</li>
</ul>
<p>封装：</p>
<p>tcp报文段从应用层接收到数据。他本身北风撞到ip数据报中。</p>
<p> <img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\7.jpg" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在更详细的讨论tcp之前 我们先来看看tcp的组成。&lt;/p&gt;
&lt;h3 id=&quot;报文段&quot;&gt;&lt;a href=&quot;#报文段&quot; class=&quot;headerlink&quot; title=&quot;报文段&quot;&gt;&lt;/a&gt;报文段&lt;/h3&gt;&lt;p&gt;报文段包括了20~60字节的首部和数据。首部在没有选项的时候是2
    
    </summary>
    
      <category term="tcp-ip协议族" scheme="http://yoursite.com/categories/tcp-ip%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="tcpip" scheme="http://yoursite.com/tags/tcpip/"/>
    
  </entry>
  
  <entry>
    <title>tcp4之流量控制差错控制和拥塞控制</title>
    <link href="http://yoursite.com/2017/03/17/tcp4%E4%B9%8B%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%8F%92%E5%BA%A7%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2017/03/17/tcp4之流量控制插座控制和拥塞控制/</id>
    <published>2017-03-17T12:52:12.000Z</published>
    <updated>2017-03-17T07:38:40.700Z</updated>
    
    <content type="html"><![CDATA[<p>在讨论流量 差错 阻塞之前。我们要先描述一下窗口。tcp为每个方向的数据传输各使用两个窗口。</p>
<h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><h4 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h4><p>发送窗口大小由接收方以及底层网络拥塞成都决定。图中描绘了打开 关闭 收缩。</p>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\9.jpg" alt="image"></p>
<p>注意事项：</p>
<ol>
<li>tcp中为字节编号。控制窗口的变量单位是以字节为单位的。</li>
<li>tcp只是用一个计数器。</li>
</ol>
<h4 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h4><p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\10.jpg" alt="image"></p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>平衡了生产者消费者之间的速度。</p>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\11.jpg" alt="image"></p>
<p>图中描述的数据走向是从发送进程乡下到达发送tcp，再从发送tcp到接受tcp，然后从接受不tcp向上到达接受进程。不过，流量控制的反馈走向是从接受tcp到发送tcp，以及从发送tcp向上到发送进程的。tcp的绝大多数实现都不提供从接受进程到接受tcp的流量控制反馈，而是让接受进程在准备就绪时去接受tcp哪里拉取数据。换言之，接受tcp控制了发送tcp。</p>
<p>为了实现流量控制，tcp强制发送方和接收方不断调整他们的窗口大小。</p>
<p>一个例子：<br><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\12.jpg" alt="image"></p>
<p>窗口关闭：<br>使发送窗口的右臂想做移动收缩是不希望的，但是有一个例外。接收端可以发送rwnd为0的报文来暂时关闭窗口。这种情况是由于接受方因某种原因在一段时间内不愿意从接受方接受任何数据。此时，发送方实际上并非真正的把窗口大小缩小了，只是暂定发送。直到收到一个新的通告为止。</p>
<p>糊涂窗口综合征：<br>加入tcp发送报文只包含一个字节的数据。那么意味着额外开销为41/1 （20个tcp首部 20个ip首部）。低效的。那么为了防指 就要强波发送tcp等待。怎么确定等待时间呢？</p>
<p>nagle算法：<br>1.发送tcp把他的第一个数据块发送出去，哪怕只有一个字节。<br>2.发送了第一个报文段后，发送tcp就能在输出缓存中积累数据等待，知道收到了tcp发来的确认。或者累计了足够多的 数据可以装成最大长度的报文段，这时，发送tcp就可以发送这个报文段了。<br>3.对省辖的传输，不断地重复步骤2.</p>
<h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>tcp使用差错控制来提供可靠性。差错控制包含以下的一些机制：检测和重传收到损伤的报文段，重传丢失的报文段，保存失序到达的报文段直至缺失的报文段到期，以及检测和丢弃重复的报文段。</p>
<p>tcp使用：检验和、确认、超时三个工具。</p>
<ol>
<li>每个报文段都有一个检验和字段。损伤就丢弃，病人伪是丢失了。</li>
<li>确认</li>
<li>重传</li>
<li>失序的报文段</li>
</ol>
<p>发送方tcp为每一条连接设置一个重传超时计数器。当计数器时间到，tcp发送队列中最前面的报文段，并重启计数器、</p>
<p>如果允许发送方更快的重传，而不用等待计时器超时，就能更有利于网络吞吐量。因此现在大多数实现都遵循收到三个重复ack就立刻重传丢失的报文段的规则。这一特性称为快重传。</p>
<p>失序的报文段</p>
<p>现在的tcp实现都不会丢弃失序到达的报文段，而是把这些报文段暂时保存下来，并把他们标记为失序报文段，直至缺失的报文段到期。</p>
<p>tcp数据传送的fsm</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>发送方有两个信息：接收方通告的窗口大小和拥塞窗口大小。窗口的真正大小去两者之中较小的一个。</p>
<p>tcp处理yongse一般策略是基于三个阶段：慢开始，拥塞避免，拥塞检测。</p>
<ul>
<li>慢开始： cwnd从1个报文段开始，每次ack回来，便想加，是一个指数级增大的。当窗口大小到达ssthresh（慢开始门限），该阶段就结束了，并进入下一个阶段。</li>
<li>拥塞避免：加法增大 当到达慢开始门限时，加法增加阶段就开始了。每当一争个“窗口”中的报文段都被确认后，拥塞窗口大小就增加1.</li>
<li>拥塞检查：乘法减小：如果拥塞发生，窗口大写哦就必须减少。<ol>
<li>如果计时器超时，出现拥塞可能性很大，某个报文段可能在网络中某处被抛弃了，后续报文段也没有消息。<br>a. 把门限值设置为当前窗口大小的一半<br>b. 把cwnd重新设置为一个报文段。<br>c. 再次从慢开始阶段开始。</li>
<li>如果是收到三个ack，那么出现拥塞可能性较小。某段可能被丢弃，但之后的几个安全到达，因为收到了三个重复ack，称之为快重传和快恢复。在这种情况下。tcp有以下反应<br>a. 把门限值设置为当前窗口值得一半<br>b. 把cwnd设置为门限值<br>c. 启动拥塞避免阶段。</li>
</ol>
</li>
</ul>
<p>小结：<br>给出一个例子。假设最大窗口大小的初始值是32个报文段。门限的初始值设置为16.在慢开始阶段，窗口从1开始增大，直到达到门限值。拥塞避免按照加法增大，当窗口发生超时现象，乘法减小过程开始生效，吧门限值减小到窗口大小的一半。</p>
<p><img src="C:\Users\neuly.DESKTOP-NBVHT1S\Desktop\mg\13.jpg" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在讨论流量 差错 阻塞之前。我们要先描述一下窗口。tcp为每个方向的数据传输各使用两个窗口。&lt;/p&gt;
&lt;h3 id=&quot;窗口&quot;&gt;&lt;a href=&quot;#窗口&quot; class=&quot;headerlink&quot; title=&quot;窗口&quot;&gt;&lt;/a&gt;窗口&lt;/h3&gt;&lt;h4 id=&quot;发送窗口&quot;&gt;&lt;a hr
    
    </summary>
    
      <category term="tcp-ip协议族" scheme="http://yoursite.com/categories/tcp-ip%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    
    
      <category term="tcpip" scheme="http://yoursite.com/tags/tcpip/"/>
    
  </entry>
  
  <entry>
    <title>mysql5之创建高性能的索引</title>
    <link href="http://yoursite.com/2017/03/15/mysql5%E4%B9%8B%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2017/03/15/mysql5之创建高性能的索引/</id>
    <published>2017-03-15T12:52:12.000Z</published>
    <updated>2017-03-15T11:45:58.200Z</updated>
    
    <content type="html"><![CDATA[<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ol>
<li><p>btree</p>
<p> 对索引列是顺序组织存储的，并且每一个叶子页到根的距离相同。B-Tree对索引是顺序组织存储的，所以很适合查找范围数据。<br>　　B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。索引还可以用于查询中的 order by 操作。<br>　　<br>　　一些限制：<br>　　- 如果不是安装索引的最左列开始查找，则无法使用索引<br>　　- 不能跳过索引中的列<br>　　- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找
　　</p>
</li>
<li><p>hash</p>
<p> 哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。<br> 哈希索引只需存储对应的哈希值，所以索引结构十分紧凑，使查找很快</p>
<p> 一些限制：</p>
<ul>
<li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行</li>
<li>哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序</li>
<li>哈希索引只支持等值比较查询</li>
</ul>
</li>
<li><p>创建自定义哈希索引</p>
</li>
</ol>
<h3 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h3><h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><p>如果查询中的列不是独立的，则MySQL就不会使用索引。“独立的列”是指索引的列不能是表达式的一部分，也不是函数的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt;SELECT actor_id FROM sakila.actor WHERE actor_id + 1 =5;</div><div class="line">mysql&gt;SELECt ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAY(date_col) &lt;= 10;</div></pre></td></tr></table></figure>
<h4 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h4><p>有时候需要索引很长的字符列，这会让索引变得大且慢。一个策略是前面提到过的模拟哈希索引。但有时候这样做还不够，通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率，但这样会降低索引的选择性。索引的选择性是指，不重复的索引值(也称为基数，cardinality)和数据表的记录总数(#T)的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高。唯一索引的选择性是1，这是最好的索引选择性，性能是最好的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">key</span>(col_name(prefix_length));</div></pre></td></tr></table></figure>
<h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><p>一个常见错误就是，为每个列创建独立索引，或者按照错误的顺序创建多列索引。在多个列上创建索引大部分情况下并不能提高MySQL的查询性能。MySQL 5.0 及更新的版本引入了索引合并策略（index merge），查询能够同时使用这两个单列索引进行扫描，并将结果进行合并。这种算法有三个变种：OR 条件的联合（union）， AND 条件的相交（intersection），组合前两种情况的联合及相交。</p>
<h4 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h4><p>在一个多列的 B-Tree 索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。索引可以安装升序或者降序进行扫描，以满足精确符合列顺序的 order by, group by, distinct 等子句的查询需求。考虑索引列的顺序时，将选择性最高的列放到索引列最前列，但通常不如避免随机 IO 和排序重要。性能不只是依赖于所有索引列的选择性，也和值的分布有关。（ 需要总和考虑选择性、基数、排序、分组、范围条件、值分布等因素 ）</p>
<h4 id="聚族索引"><a href="#聚族索引" class="headerlink" title="聚族索引"></a>聚族索引</h4><p>聚族索引（Oracle 里对应的是 索引组织表，index-organized table, IOT）并不是一种单独的索引类型，而是一种数据存储方式。</p>
<p>当表有聚族索引时，它的数据行实际上是存放在索引的叶子页中。聚族表示数据行和相邻的键值紧凑地存储在一起。聚族索引的叶子页包含了行的全部数据，但是节点页只包含了索引列。</p>
<p>聚族索引的优点:</p>
<ul>
<li>以把相关的数据保存在一起。（利用数据的临近性）</li>
<li>数据访问更快。由于索引和数据都在同一个 B-Tree 中，从聚族索引获取数据比非聚族索引要快。</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li>
</ul>
<p>聚族索引的缺点：</p>
<ul>
<li>插入速度严重依赖于插入顺序。按照聚族列的顺序插入是最快的方式。</li>
<li>更新聚族索引列的代价很高，因为 InnoDB 将强制每个被更新的行移动到新的位置。</li>
<li>基于聚族索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂（page split）的问题。</li>
<li>聚族索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续。</li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>通过覆盖索引来优化。</p>
<h4 id="使用索引扫描来排序"><a href="#使用索引扫描来排序" class="headerlink" title="使用索引扫描来排序"></a>使用索引扫描来排序</h4><p>MySQL通过两种方式生成有序结果：通过排序操作，或，按索引顺序扫描。当 Explain的结果中 type 为index，就说明MySQL用了索引扫描来做排序了。</p>
<h4 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(</div><div class="line">    <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</div><div class="line">    a <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    b <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">    <span class="keyword">unique</span>(<span class="keyword">id</span>),</div><div class="line">    <span class="keyword">index</span>(<span class="keyword">id</span>)</div><div class="line">) <span class="keyword">engine</span> =<span class="keyword">innodb</span></div></pre></td></tr></table></figure>
<p>一个经验不足的用户可能是想幢见一个主键，先加上唯一限制，然后再加上索引以供查询使用，事实上，唯一索引和主键限制都是通过索引实现的，上面的写法实际上创建了三个重复的索引。</p>
<p>冗余索引和重复所以有一些不同，如果创建了索引（a，b） 再创建a，就是冗余的。</p>
<h3 id="优化案例"><a href="#优化案例" class="headerlink" title="优化案例"></a>优化案例</h3><p>一个在线约惠王占，用户列表有很多咧，包括国家，地区城市性别，眼睛颜色等。网站比徐支持上面的这些特征的各种组合来搜索用户。还要允许根据用户的最后在线时间，其他会员对用户的评分等做排序并对结果进行排序，如何设计索引？</p>
<ol>
<li><p>支持多种过滤条件(利用in来使用索引，从而恶意匹配到后面的部分)<br>sex in(“m”,”f”) age放到最后面，因为是范围匹配。</p>
</li>
<li><p>避免多个范围条件</p>
</li>
</ol>
<p>例如 last_online&gt;date_sub(now(), interval 7 day) and age between 18 and 25</p>
<p>mysql无法同时使用last_online和age索引。</p>
<ol>
<li>优化排序</li>
</ol>
<p>对于一些选择性非常低的列，可以增加一些也输得索引来做排序，比如可以创建（sex，rating）索引用于下面的查询。</p>
<p>即使如厕，使用limit到哦后面的页数 也会很慢。可以使用延迟关联来优化。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> &lt;cols&gt; <span class="keyword">from</span> <span class="keyword">profiles</span> <span class="keyword">inner</span> <span class="keyword">join</span> (</div><div class="line">    <span class="keyword">select</span> &lt;primary <span class="keyword">key</span> cols&gt; <span class="keyword">from</span> <span class="keyword">profiles</span> </div><div class="line">    <span class="keyword">where</span> x.sex=<span class="string">'m'</span> <span class="keyword">order</span> <span class="keyword">by</span> rating <span class="keyword">limit</span> <span class="number">100000</span>,<span class="number">10</span></div><div class="line">) <span class="keyword">as</span> x <span class="keyword">using</span> (&lt;primary <span class="keyword">key</span> cols&gt;)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;索引类型&quot;&gt;&lt;a href=&quot;#索引类型&quot; class=&quot;headerlink&quot; title=&quot;索引类型&quot;&gt;&lt;/a&gt;索引类型&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;btree&lt;/p&gt;
&lt;p&gt; 对索引列是顺序组织存储的，并且每一个叶子页到根的距离相同。B-Tree对索引是
    
    </summary>
    
      <category term="高性能mysql" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
    
      <category term="高性能mysql" scheme="http://yoursite.com/tags/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql7之高级特性</title>
    <link href="http://yoursite.com/2017/03/15/mysql7%E4%B9%8B%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2017/03/15/mysql7之高级特性/</id>
    <published>2017-03-15T12:52:12.000Z</published>
    <updated>2017-03-15T11:51:49.141Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-分区表"><a href="#1-分区表" class="headerlink" title="1.分区表"></a>1.分区表</h3><p>对用户来说，分区表示一个独立的逻辑表，但是底层由多个物理子表组成。</p>
<p>实现分区的代码实际上是对一组底层表的句柄对象的封装。对分区表的请求，都会通过句柄对象转换成对存储引擎的接口调用。</p>
<p>MYSQL 实现分区表的方式-》 对底层表的封装 -》意味着索引也是按照分区的子表定义，而没有全局索引。</p>
<p>mysql实现分区表的方式–对地层表的封装–意味着索引也是按照分区的字表定义的。</p>
<p>分区的一个主要目的是 将数据按照一个较粗的粒度分在不同的表中。</p>
<p>分区表的索引只是在各个底层表各自加上一个完全相同的索引。之于存储引擎，分区表的底层表与普通表没有区别。</p>
<p>分区表的原理：</p>
<p>select :当查询一个分区表的时候，分区表先打开并锁住所有的底层表，优化器线盘短是否可以过滤部分分区，然后在调用对应的存储引擎接口访问各个分区的数据。</p>
<p>insert：当写入一条记录时，分区层先打开并锁住所有的底层表，然后确定哪个分区接受这条记录。再将记录写入到对应底层表中。</p>
<p>delete和update同上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">CREATE TABLE <span class="title">sales</span> <span class="params">(</span></span></div><div class="line">　　order_date DATETIME NOT NULL,</div><div class="line">　　-- Other columns omitted</div><div class="line">) ENGINE=<span class="function">InnoDB PARTITION BY <span class="title">RANGE</span><span class="params">(YEAR(order_date)</span>) <span class="params">(</span></span></div><div class="line">PARTITION p_2010 VALUES LESS THAN (<span class="number">2010</span>),</div><div class="line">PARTITION p_2011 VALUES LESS <span class="title">THAN</span> <span class="params">(<span class="number">2011</span>)</span>,</div><div class="line">PARTITION p_2012 VALUES LESS <span class="title">THAN</span> <span class="params">(<span class="number">2012</span>)</span>,</div><div class="line">PARTITION p_catchall VALUES LESS THAN MAXVALUE );</div></pre></td></tr></table></figure>
<h3 id="2-视图"><a href="#2-视图" class="headerlink" title="2.视图"></a>2.视图</h3><p>视图：</p>
<ul>
<li>视图本身是一个虚拟表，不存放任何数据。</li>
<li>在使用sql语句访问视图的时候，它返回的数据是Mysql从其他表生成的。</li>
<li>视图和表在同一个命名空间，MySQL在很多地方低于视图和表是同样对待的。</li>
<li>不过视图和表也有不同，例如，不能对视图创建触发器，也不呢过使用drop table 命令删除视图</li>
</ul>
<p>实现算法：</p>
<p>merge: 合并算法，尽可能使用这个</p>
<p>Temptable：临时表算法。如果视图中高寒GROUP BU, DISTINCT, 任何聚合函数, UNION, 子查询等<br>　　只要无法在原表记录和视图记录建立一一映射的场景中，mysql都将用临时表算法实现视图。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">view</span> oceania <span class="keyword">as</span> </div><div class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> country <span class="keyword">where</span> continent=<span class="string">'oceania'</span></div><div class="line">    <span class="keyword">with</span> <span class="keyword">check</span> opition;</div><div class="line"><span class="keyword">select</span> code,<span class="keyword">name</span> <span class="keyword">from</span> oceania <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'australia'</span>;</div><div class="line"></div><div class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span> tmp_oca <span class="keyword">as</span> </div><div class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> country <span class="keyword">where</span> cotinent=<span class="string">'sss'</span>;</div></pre></td></tr></table></figure>
<h3 id="3-外键约束"><a href="#3-外键约束" class="headerlink" title="3.外键约束"></a>3.外键约束</h3><h3 id="4-在mysql内部存储代码"><a href="#4-在mysql内部存储代码" class="headerlink" title="4.在mysql内部存储代码"></a>4.在mysql内部存储代码</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-分区表&quot;&gt;&lt;a href=&quot;#1-分区表&quot; class=&quot;headerlink&quot; title=&quot;1.分区表&quot;&gt;&lt;/a&gt;1.分区表&lt;/h3&gt;&lt;p&gt;对用户来说，分区表示一个独立的逻辑表，但是底层由多个物理子表组成。&lt;/p&gt;
&lt;p&gt;实现分区的代码实际上是对一组底层表
    
    </summary>
    
      <category term="高性能mysql" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
    
      <category term="高性能mysql" scheme="http://yoursite.com/tags/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL2之schema设计优化</title>
    <link href="http://yoursite.com/2017/03/15/MySQL2%E4%B9%8Bschema%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/03/15/MySQL2之schema设计优化/</id>
    <published>2017-03-15T12:52:12.000Z</published>
    <updated>2017-03-15T11:45:24.980Z</updated>
    
    <content type="html"><![CDATA[<p>良好的逻辑设计和物理设计是高性能的基石，应该根据系统要执行的查询语句来设计 schema。这往往需要权衡各种因素。</p>
<p>例如：反范式的设计可以加快某些类型的查询，但同时可能使另一些类型的查询变慢。比如添加计数表和汇总表是一种很好的优化查询的方式，</p>
<p>但是这些表的维护成本会很高。MySQL独有的特性和实现细节对性能影响也很大。</p>
<p>选择优化的数据类型的简单原则：</p>
<p>　　1.更小的通常更好</p>
<p>　　　　一般情况下，应该尽量使用可以正确存储数据的最小数据类型。</p>
<p>　　2.简单就好</p>
<p>　　　　简单数据类型的操作通常需要更少的cpu周期。</p>
<p>　　3.尽量避免NULL</p>
<p>　　　　如果查询包含可为NULL的列，对mysql来说更难优化，因为可为NULL的列使得索引，索引统计，值比较都更复杂。</p>
<p>　　　　可为NULL的列会使用更多的存储空间，在MySQL里也需要特殊处理。</p>
<p>schema设计的第一步，那就是建表，建表的第一步呢就是设计字段，然而了解mysql的数据类型又对设计字段有莫大的帮助。</p>
<p>那我们先来了解mysql的基本数据类型吧。</p>
<p>1.整数类型</p>
<p>　　TINYINT, SMALLINT,MEDIUMINT,INT,BIGINT</p>
<p>　　8，16，24，32，64，位存储空间。</p>
<p>　　MySQL可为整数类型制定宽度，例如INT（11），但对大多数应用这是没意义的；它不会限制值合法范围。对于存储和计算来说</p>
<p>　　INT(1) 和 INT(20)是相同的</p>
<p>2.实数类型</p>
<p>　　FLOAT,DOUBLE,DECIMAL(精确计算用的)</p>
<p>3.字符串类型</p>
<p>　　VARCHARE</p>
<p>　　　　最常见的字符串类型。它比定长类型更节省空间，因为它仅适用必要的空间。有一种情况例外，如果MySQL表使用ROW_FORMAT=FIXED创建的话。</p>
<p>　　　　VARCHAR需要适用1或2个额外字节记录字符串的长度。如果列的最大长度小于等于255，则使用一个字节记录长度。</p>
<p>　　CHAR</p>
<p> 　　　　是定长的。MySQL总是根据定义的字符串分配足够的空间。当存储CHAR值时，MySQL会删除所有的末尾空格。</p>
<p>　　　　CHAR值会根据需要采用空格填充以方便比较。</p>
<p>　　　　CHAR适合存储很短的字符串。对于经常变更的数据，CHAR也比VARCHAR更好，因为定长CHAR类型不容易产生碎片。</p>
<p>　　BLOB和TEXT</p>
<p>　　　　BLOB和TEXT都是为存储很大数据而设计的字符串数据类型，分别采用二进制和字符方式存储。</p>
<p>　　使用枚举（ENUM）代替字符串类型</p>
<p>4.日期和时间类型</p>
<p>　　DATETIME</p>
<p>　　　　这个类型能保存大范围的值。从1001年到9999年，精度为妙。</p>
<p>　　TIMESTAMP</p>
<p> 　　　　存储空间小，并且会根据时区变化，有特殊的自动更新能力。精度为妙。</p>
<p>　　如果要存储比秒更小粒度的时间时，可以用bigint类型存储微秒级别的时间戳。</p>
<p>5.位数据类型</p>
<p>　　BIT</p>
<p>标识符的选择：</p>
<p>　　整数类型</p>
<p>　　　　整数通常是标识列的最好选择。因为他们很快，并且可以使用auto_increment</p>
<p>　　enum 和 set 类型</p>
<p>　　</p>
<p>　　字符串类型</p>
<p>　　　　如果可能，尽量避免使用字符串类型作为标识符，因为它们很消耗空间，并且通常比数字类型慢。</p>
<p>　　　　尤其在MyISAM表里使用字符串作为标识列时要特别小心。MyISAM默认对字符串使用压缩索引，这会使查询很慢。</p>
<p>　　　　对于完全’随机’的字符串也需要多加注意，例如md5(),sha1(),uuid()产生的字符串。</p>
<p>　　　　这些函数生成的新值会任意分布在很大的空间内，这会导致insert以及一些select语句变得很慢：</p>
<p>　　　　　　1.因为插入值会随机写到索引的不同位置，所以使得insert语句更慢。这会导致页分裂，磁盘随机访问，以及对于聚簇存储引擎产生聚簇索引碎片。</p>
<p>　　　　　　2.select语句会变得更慢，因为逻辑上相邻的行为分布在磁盘和内存的不同地方。</p>
<p>　　　　　　3.随机值会导致缓存对所有类型的查询语句效果都很差。</p>
<p>schema设计中的陷阱</p>
<p>　　1.太多的列</p>
<p>　　2.太多的关联</p>
<p>　　3.全能的枚举</p>
<p>　　</p>
<p>范式和反范式</p>
<p>　　三大范式：　　</p>
<p>　　　　1.必须有主键，列不可分　　</p>
<p>　　　　2.当一个表是复合主键时，非主键的字段不依赖于部分主键(即必须依赖于全部的主键字段)</p>
<p>　　　　3.关系模式R（U，F）中的所有非主属性对任何候选关键字都不存在传递依赖</p>
<p>　　反范式，顾名思义，不遵守三大范式。</p>
<p>　　首先我们来看看范式的优缺点：</p>
<p>　　优点：</p>
<p>　　　　范式化的更新操作通常比反范式快。</p>
<p>　　　　当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据</p>
<p>　　　　范式化的表通常很小，可以更好的放在内存里，所以执行操作会更快。</p>
<p>　　　　很少有多余的数据意味着检索列表数据更少需要DISTINCT或者GROUP BY语句。</p>
<p>　　缺点：</p>
<p>　　　　过度依赖关联。这不但代价昂贵，也可能使一些索引策略无效。</p>
<p>　　反范式优缺点：</p>
<p>　　　　因为所有的数据在一张表中，可以很好的避免关联。</p>
<p>　　　　如果不需要关联，则对大部分查询最差的情况，即使没有使用索引，是全表扫描，当数据比内存大时这可能比关联要快得多，</p>
<p>　　　　因为这样避免了随机I/O。</p>
<p>　　　　单独的表能更好的使用索引策略。</p>
<p>　混用范式和反范式才是schema设计的主流。</p>
<p>缓存表和汇总表</p>
<p>　　方便查询，不易维护。</p>
<p>物化视图</p>
<p>　　</p>
<p>计数器表</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;良好的逻辑设计和物理设计是高性能的基石，应该根据系统要执行的查询语句来设计 schema。这往往需要权衡各种因素。&lt;/p&gt;
&lt;p&gt;例如：反范式的设计可以加快某些类型的查询，但同时可能使另一些类型的查询变慢。比如添加计数表和汇总表是一种很好的优化查询的方式，&lt;/p&gt;
&lt;p&gt;但
    
    </summary>
    
      <category term="高性能mysql" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
    
      <category term="高性能mysql" scheme="http://yoursite.com/tags/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL3之服务器性能剖析</title>
    <link href="http://yoursite.com/2017/03/15/MySQL3%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/"/>
    <id>http://yoursite.com/2017/03/15/MySQL3之服务器性能剖析/</id>
    <published>2017-03-15T12:52:12.000Z</published>
    <updated>2017-03-15T11:45:43.324Z</updated>
    
    <content type="html"><![CDATA[<p>关于mysql服务器性能，可能需要关注的点会比较多，如：如何确认服务器是否达到了性能最佳的状态，找出某条语句为什么执行不够快，以及诊断被用户描述成“停顿“,“堆积“或者“卡死“的某些间歇性疑难故障。这看起来很不简单。但是事实证明，有一个简单的方法能够从噪声中发现苗头。</p>
<p>这个方法就是专注于测量服务器的时间花费在哪里，使用的技术则是性能剖析。</p>
<p>mysql性能的问题，可能不同人会有不同的说法。例如：每秒查询数，cpu利用率，可扩展性  等等。</p>
<p>每个人在不同场景对性能有不同的理解。</p>
<p>但在这我们将给出一个正式的定义：</p>
<p>mysql性能指的是完成某件任务所需要的时间的度量，换句话说，性能即响应时间.</p>
<p>性能优化就是在一定得工作负载下尽可能的降低响应时间。</p>
<p>有人认为性能优化是降低cpu利用率，这是一个误解。资源是用来消耗并用来工作的，所以有时候消耗更多的资源能够加快查询速度。cpu利用率只是一种现象，而不是很好的可度量的目标。</p>
<p>同样，如果把性能优化仅仅看成提升每秒查询量，这其实只是吞吐量优化。吞吐量的提升可以看做性能优化的副产品。（吞吐量的定义是单位时间内的查询数量，这正好是我们对性能定义的倒数）</p>
<p>优化的第二原则：无法测量就无法有效的优化。所以，第一步应该测量时间花在什么地方。</p>
<p>不合适的测量：</p>
<p>　　在错误的时间启动和停止测量</p>
<p>　　测量的是聚合后的信息，而被捕是目标活动本身。</p>
<p>例如一个常见的错误是先查看慢查询，然后又去排查整个服务器的情况来判断问题的所在。</p>
<p>完成一项任务所需要的时间可以分为两部分：执行时间和等待时间。</p>
<p>剖析MySQL查询：</p>
<p>　　1.剖析服务器负载</p>
<p>　　　　捕获mysql的查询到日志文件中</p>
<p>　　　　分析查询日志</p>
<p>　　2.剖析单条查询</p>
<p>　　　　使用 show profile</p>
<p>　　　　使用 show status</p>
<p>　　　　使用 慢查询日志</p>
<p>　　3.使用性能剖析</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于mysql服务器性能，可能需要关注的点会比较多，如：如何确认服务器是否达到了性能最佳的状态，找出某条语句为什么执行不够快，以及诊断被用户描述成“停顿“,“堆积“或者“卡死“的某些间歇性疑难故障。这看起来很不简单。但是事实证明，有一个简单的方法能够从噪声中发现苗头。&lt;/p
    
    </summary>
    
      <category term="高性能mysql" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
    
      <category term="高性能mysql" scheme="http://yoursite.com/tags/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql6之查询性能优化</title>
    <link href="http://yoursite.com/2017/03/15/mysql6%E4%B9%8B%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/03/15/mysql6之查询性能优化/</id>
    <published>2017-03-15T12:52:12.000Z</published>
    <updated>2017-03-15T11:46:20.722Z</updated>
    
    <content type="html"><![CDATA[<p>前一章节讲解了如何设计库表结构及建索引。只有这些并不够。<br>本章主要介绍合理的查询设计。</p>
<h4 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h4><ol>
<li>是否向数据库请求了不需要的数据</li>
</ol>
<ul>
<li>查询不需要的记录（需要20条，查询了100）</li>
<li>多表关联时反悔了全部列 </li>
<li>总是去除所有列（select *）</li>
<li>重复查询相同的数据</li>
</ul>
<ol>
<li>在确定了查询只返回需要的数据以后，接下来看查询是否扫描了过多的数据、</li>
</ol>
<p>最简单的衡量查询的三个指标：</p>
<ul>
<li>响应时间（服务时间+排队时间）</li>
<li>扫描的行数</li>
<li>返回的行数</li>
</ul>
<h4 id="重构查询的方法"><a href="#重构查询的方法" class="headerlink" title="重构查询的方法"></a>重构查询的方法</h4><ol>
<li>一个复杂查询还是多个简单查询</li>
<li>切分查询</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">delete</span> <span class="keyword">from</span> messages <span class="keyword">where</span> created&lt; <span class="keyword">date_sub</span>(<span class="keyword">now</span>(),<span class="built_in">interval</span> <span class="number">3</span> <span class="keyword">month</span>);</div><div class="line"></div><div class="line">rows_affected=</div><div class="line"><span class="keyword">do</span>&#123;</div><div class="line">    rows_affected=do_query(</div><div class="line">    <span class="string">"delete from messages where &lt; date_sub(now(),interval 3 month) limit 10000</span></div><div class="line">    ")</div><div class="line">&#125; <span class="keyword">while</span> rows_affected&gt;<span class="number">0</span></div></pre></td></tr></table></figure>
<ol>
<li>分解关联查询</li>
</ol>
<ul>
<li>让缓存的效率更高</li>
<li>将查询分解后，执行单个查询可以减少锁的竞争</li>
<li>查询本身小老板也可能hi有所提升</li>
<li>可以减少荣誉记录。咋应用层做关联查询</li>
</ul>
<h4 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h4><p>客户端—通信协议—服务器（sql—查询缓存—解析器—解析树—预处理器—解析树<br>—查询优化器—查询执行计划—查询执行引擎—api接口调用—存储引擎—数据<br>）</p>
<p>根据以上步骤 下面分别描述。</p>
<ol>
<li>mysql客户端和服务器通信协议。</li>
</ol>
<p>通信协议是半双工的。要么是服务器向客户端发送，要么是客户端向服务器发送。</p>
<p>查询状态：</p>
<ul>
<li>sleep</li>
<li>query</li>
<li>locked</li>
<li>analyzing and statics</li>
<li>copying to tmp table [on disk]:线程正在执行查询，并且将结果及复制到一个临时表，</li>
<li>sorting result 正在对结果集进行排序</li>
<li>sending data</li>
</ul>
<ol>
<li>查询缓存</li>
</ol>
<p>如果查询缓存是打开的，mysql会优先检查这个查询是否命中查询缓存中的数据，这个检查是通过一个队大小写敏感的哈希查找实现的。查询和缓存中的查询及时只有一个字节不同，那也不会匹配缓存结果。进入下一阶段。</p>
<p>如果刚好命中查询缓存，会进行一次用户权限检查。没问题 返回。</p>
<ol>
<li>查询优化处理</li>
</ol>
<p>语法解析器和预处理：语法正确合法么？数据表数据列存在么？ 验证权限？</p>
<p>查询优化器：</p>
<p>一条查询可以有很多执行方法，都返回相同的结果，优化器的作用找出最好的执行计划。<br>基于成本的优化器、<br>优化策略：静态优化和动态优化。静态优化对解析树直接进行分析，完成优化。通过简单的代数变换将where换成另一等价形式。</p>
<p>能够处理的一些优化类型：</p>
<ul>
<li>重新定义关联表的顺序</li>
<li>将外链接变成内连接</li>
<li>利用等价变换原则</li>
<li><p>优化count min max等</p>
<p>  举例说明：如果查找一列的最小值，只要查询对应btree索引最左端的记录，mysql可以直接获取索引的第一行记录。在优化器生成执行计划的时候，就可以利用这一点。在btree索引中，优化器会将这个表达式当做一个常数暗袋。 最大值同上。<br>  “select tables optimized away”</p>
</li>
<li>预估并转化为常数表达式</li>
<li>覆盖索引扫描</li>
<li>子查询优化</li>
<li>提前终止查询</li>
<li>等值传播： 如果两个列通过登时关联，那么mysql能够把其中一个列的where条件传递到另一列上。</li>
</ul>
<p>执行计划</p>
<p>关联优化器 </p>
<p>排序优化</p>
<ol>
<li><p>查询执行引擎</p>
</li>
<li><p>返回结果给客户端</p>
</li>
</ol>
<p>mysql将结果集返回客户duan是一个增量逐步返回的结果。<br>结果集中的每一行都会以一个满足mysql客户端服务器通信协议的封包发送，再通过tcp协议进行传输。在tcp传输过程中，可能对mysql封包进行缓存然后批量传输。</p>
<h4 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h4><ul>
<li>count</li>
<li>关联查询 a和b用c列关联，优化顺序是ba，只需要在a上建索引就好，没用到的索引只会是负担。</li>
<li>优化子查询 尽量用关联插叙代替</li>
<li>优化group by 和distinct</li>
<li>优化limit： 使用索引覆盖扫描，延迟加载</li>
<li>优化sql_calc_found_rows</li>
<li>union</li>
<li>使用用户自定义变量</li>
</ul>
<h3 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h3><ol>
<li>使用mysql构建一个队列表。</li>
<li>计算两点之间的距离</li>
<li>使用用户自定义函数</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一章节讲解了如何设计库表结构及建索引。只有这些并不够。&lt;br&gt;本章主要介绍合理的查询设计。&lt;/p&gt;
&lt;h4 id=&quot;慢查询基础：优化数据访问&quot;&gt;&lt;a href=&quot;#慢查询基础：优化数据访问&quot; class=&quot;headerlink&quot; title=&quot;慢查询基础：优化数据访问&quot;&gt;
    
    </summary>
    
      <category term="高性能mysql" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
    
      <category term="高性能mysql" scheme="http://yoursite.com/tags/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql之简介</title>
    <link href="http://yoursite.com/2017/03/15/mysql1%E4%B9%8B%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2017/03/15/mysql1之简介/</id>
    <published>2017-03-15T12:52:12.000Z</published>
    <updated>2017-03-15T11:44:44.117Z</updated>
    
    <content type="html"><![CDATA[<p>如果能在头脑中构建衣服MySQL各组件之间如何协同工作的架构图，就会有助于深入了解MySQL服务器。</p>
<p>该架构分为三层：</p>
<p>　　最上层的服务并不是MySQL所独有的，大多数基于网络的客户/服务器的工具或者服务都有类似的架构。</p>
<p>　　第二层架构是MySQL比较有意思的部分。大多数MySQL的核心服务功能都在这一层，包括查询解析，分析，优化</p>
<p>　　缓存，以及所有的内置函数，所有的跨存储引擎的功能都在这一层实现： 存储过程，触发器，视图等。</p>
<p>　　第三层包含了存储引擎。存储引擎负责MySQL中数据的存储和提取。每个存储引擎都有它的优势和劣势。服务器通过</p>
<p>　　API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。</p>
<p>　　存储引擎API包含几十个底层函数，用于执行诸如”开始一个事务” 或者 “根据主键提取一行记录”等操作。</p>
<p>　　但存储引擎不会去解析SQL，不同存储引擎之间也不会相互通信，而只是简单的响应上层服务器的请求。<br>　　<br>　　<br>然后让我们再来认识认识一些MySQL的基本概念。</p>
<ol>
<li>连接管理与安全性</li>
</ol>
<p>　　每个客户端连接都会服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。</p>
<p>　　服务器会负责缓存线程，因为不需要为每一个新建的连接创建或者销毁线程。</p>
<p>　　客户端连接MySQL服务器是需要进行验证的。</p>
<p>2.优化和执行</p>
<p>　　MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行优化， 包括重写查询，决定表的读取顺序，以及选择合适的索引等。</p>
<p>　　用户还可以通过特殊的关键字提示（hint）优化器来影响它的决策过程。（后续都会有详细介绍）</p>
<p>　　优化器并不关心表使用的是什么存储引擎，但存储引擎对优化查询是有影响的。</p>
<p>3.并发控制</p>
<p>　　MySQL在多个查询需要在同一时刻修改数据，都会产生并发控制的问题。</p>
<p>　　MySQL在两个不同的层面存在并发控制：服务器层和存储引擎层。</p>
<p>4.读写锁</p>
<p>　　并发控制的一种很简单的解决方案，就是读写锁。在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。</p>
<p>　　这两种类型的锁通常被称为共享锁和排他锁，也叫读锁和写锁。</p>
<p>　　锁的具体概念如下：读锁是共享的，或者说是互相不阻塞的。写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁。</p>
<p>5.锁粒度</p>
<p>　　表锁</p>
<p>　　行级锁 （innoDB和XtraDB以及其他一些存储引擎中实现了行级锁，行级锁只在存储引擎层实现，MySQL服务器层没有实现）</p>
<p>6.事务</p>
<p>　　ACID：</p>
<p>　　原子性（atomicity），一致性（consistency），隔离性（isolation），持久性（durability）</p>
<p>7.隔离级别</p>
<p>　　READ UNCOMMITED（未提交读）</p>
<p>　　READ COMMITTE（提交读）</p>
<p>　　REPEATABLE READ（可重复读）</p>
<p>　　SERIALIZABLE(可串行化)</p>
<p>8.死锁</p>
<p>9.事务日志</p>
<p>　　它可以帮助提高事务的效率。它减少随机磁盘I/O。</p>
<p>　　目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（write-Ahead Logging），修改数据需要写两次磁盘。</p>
<p>　　（在事务提交后，如果直接写入数据，就会产生大量的随机磁盘I/O.</p>
<p>　　如果使用事务日志，首先将日志写入磁盘，是顺序磁盘I/O，开销会比较小，其次在真正需要写入数据的时候，存储引擎会做相关的顺序优化，尽量减少</p>
<p>　　I/O的产生，然后再慢慢地刷回到磁盘。）</p>
<ol>
<li>存储引擎</li>
</ol>
<p>　　InnoDB引擎</p>
<p>　　MyISAM引擎　　</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果能在头脑中构建衣服MySQL各组件之间如何协同工作的架构图，就会有助于深入了解MySQL服务器。&lt;/p&gt;
&lt;p&gt;该架构分为三层：&lt;/p&gt;
&lt;p&gt;　　最上层的服务并不是MySQL所独有的，大多数基于网络的客户/服务器的工具或者服务都有类似的架构。&lt;/p&gt;
&lt;p&gt;　　第二层
    
    </summary>
    
      <category term="高性能mysql" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
    
      <category term="高性能mysql" scheme="http://yoursite.com/tags/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"/>
    
  </entry>
  
  <entry>
    <title>java面试宝典注意点</title>
    <link href="http://yoursite.com/2017/03/02/java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>http://yoursite.com/2017/03/02/java面试宝典注意点/</id>
    <published>2017-03-02T01:38:44.000Z</published>
    <updated>2017-03-03T10:34:10.303Z</updated>
    
    <content type="html"><![CDATA[<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ol>
<li><p>字符串对象池的作用？</p>
</li>
<li><p>stringbuffer stringbuild？</p>
</li>
<li><p>如何使用指定的字符集创建对象？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String a=&quot;中文&quot;;</div><div class="line">String b= new String(a.getbytes(),&quot;UTF-8&quot;);</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ol>
<li><p>java 数组是一个类么？<br>本质上是一个类。</p>
</li>
<li><p>数组拷贝？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arrays.copyof();</div><div class="line">system.arraycopy();</div></pre></td></tr></table></figure>
</li>
<li><p>iterator迭代器</p>
</li>
<li>比较器 comparable comparator</li>
<li>vector 和 arraylist的区别</li>
<li>hashmap hashtable</li>
<li>集合使用泛型的好处 （可以达到元素类型明确的目的，避免手动类型转换）</li>
<li>符合什么条件的数据集合可以使用foreach ？ 数组或者实现iterable</li>
</ol>
<h4 id="io"><a href="#io" class="headerlink" title="io"></a>io</h4><ol>
<li><p>文件复制</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String inputpath, String outpath)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		File rfile = <span class="keyword">new</span> File(inputpath);<span class="comment">//读取的文件</span></div><div class="line">		File wfile = <span class="keyword">new</span> File(outpath);<span class="comment">//写入的文件</span></div><div class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(rfile)));</div><div class="line">		BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(wfile,<span class="keyword">true</span>)));</div><div class="line">		<span class="keyword">for</span>(String line = br.readLine(); line != <span class="keyword">null</span>; line = br.readLine())&#123;</div><div class="line">		   bw.write(line);</div><div class="line">		   bw.newLine();</div><div class="line">		   bw.flush();</div><div class="line">		&#125;</div><div class="line">		bw.close();</div><div class="line">		br.close();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>随机存取文件  RandomAccessFile</p>
</li>
<li><p>字节流的处理方式<br> 字节流处理单位是byte，操作byte数组，通过read和write方法进行操作。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span>[] buff=nnew <span class="keyword">byte</span>[<span class="number">256</span>];</div><div class="line"><span class="keyword">int</span> len=<span class="number">0</span>;</div><div class="line"><span class="keyword">while</span>((len=fin.read(buff))&gt;<span class="number">0</span>)&#123;</div><div class="line">	fout.write(buff,<span class="number">0</span>,len);&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>字符流的处理方式</p>
</li>
<li>序列化？ java.io.serializable Externalizable</li>
</ol>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ol>
<li>编写一个生产者消费者模型</li>
<li>线程池怎么使用？ threadpoolexecutor</li>
</ol>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><ol>
<li>反射的原理？</li>
<li>反射。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span>.<span class="title">forname</span>().<span class="title">newInstance</span>()</span>;</div><div class="line">constructor(Student) con=<span class="class"><span class="keyword">class</span>.<span class="title">forname</span>().<span class="title">getconstructor</span>(<span class="title">String</span>.<span class="title">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</div><div class="line">con.newInstance(<span class="string">"zzz"</span>,<span class="number">1</span>);</div><div class="line">Class clazz=obj.getclass();</div><div class="line">field f=clazz.getDeclaredField(<span class="string">"ss"</span>);</div><div class="line">f.setaccessible（<span class="keyword">true</span>）;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h4><ol>
<li><p>tcp协议的特点</p>
<p> 面向连接的 可靠地 基于字节流的运输层通信协议。</p>
<p> 应用层向tcp层发送8位字节表示的数据流，然后tcp吧数据流分割成适当长度的报文段，之后tcp把结果传给ip层，有他通过网络将包传送给接收端实体的tcp层。tcp为了保证不发生丢包，采用一种精确地确认机制，一旦发送失败将提供重新发送的机会。可以保证数据的可靠传输。</p>
<p> tcp提供一种端口机制，用于区分各种网络应用程序。</p>
</li>
<li><p>java中tcp变成模型</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">serversocket ss = <span class="keyword">new</span> serversocket(<span class="number">8080</span>);</div><div class="line">socket  socket=ss.accept();</div><div class="line">outputstream os=socket.getoutputstream();</div><div class="line">inputstream is=socket.getinputstream();</div></pre></td></tr></table></figure>
</li>
<li><p>udp的特点</p>
<p> 面向数据包的传输层协议，不提供对ip协议的可靠机制 流控制和错误恢复机制。 他的头部包含比较少的字节，比tcp负载消耗少，熟读快、</p>
<p> udp是一个无连接的协议。传输数据之前源端和终端不建立连接，当它想传送石就简单的去抓送来自应用程序的数据，并尽可能块的把它扔到网络上。<br> 不需要维护连接状态，包括收发状态。字节开销少。</p>
</li>
<li><p>udp编程模型</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">datagramsocket ds= <span class="keyword">new</span> datagramsocket(<span class="number">9999</span>);</div><div class="line"><span class="keyword">byte</span>[] buff= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">datagrampacket dp= <span class="keyword">new</span> datagrampacket(buff,<span class="number">1024</span>);</div><div class="line">ds.receive(dp)</div></pre></td></tr></table></figure>
</li>
<li><p>如何创建tcp通信的服务器端的多线程模型</p>
</li>
<li>用tcp通信模型创建一个web服务器</li>
<li></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;字符串对象池的作用？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;stringbuffer stri
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍15-nio1</title>
    <link href="http://yoursite.com/2017/02/27/15-javanio/"/>
    <id>http://yoursite.com/2017/02/27/15-javanio/</id>
    <published>2017-02-27T12:52:12.000Z</published>
    <updated>2017-02-27T08:30:22.464Z</updated>
    
    <content type="html"><![CDATA[<p>在Java1.4之前的I/O系统中，提供的都是面向流的I/O系统，系统一次一个字节地处理数据，一个输入流产生一个字节的数据，一个输出流消费一个字节的数据，面向流的I/O速度非常慢，而在Java 1.4中推出了NIO，这是一个面向块的I/O系统，系统以块的方式处理处理，每一个操作在一步中产生或者消费一个数据库，按块处理要比按字节处理数据快的多。</p>
<p>在NIO中有几个核心对象需要掌握：缓冲区（Buffer）、通道（Channel）、选择器（Selector）。</p>
<h4 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h4><p>缓冲区实际上是一个容器对象，更直接的说，其实就是一个数组，在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的； 在写入数据时，它也是写入到缓冲区中的；任何时候访问 NIO 中的数据，都是将它放到缓冲区中。</p>
<p>在NIO中，所有的缓冲区类型都继承于抽象类Buffer，最常用的就是ByteBuffer.继承关系如下：</p>
<ul>
<li>buffer<ul>
<li>bytebuffer - mappedbytedbuffer </li>
<li>charbuffer</li>
<li>doublebuffer</li>
<li>floatbuffer</li>
<li>intbuffer</li>
<li>longbuffer</li>
<li>shortbuffer</li>
</ul>
</li>
</ul>
<h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><p>通道是一个对象，通过它可以读取和写入数据，当然了所有数据都通过Buffer对象来处理。我们永远不会将字节直接写入通道中，相反是将数据写入包含一个或者多个字节的缓冲区。同样不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</p>
<h4 id="使用NIO读取数据"><a href="#使用NIO读取数据" class="headerlink" title="使用NIO读取数据"></a>使用NIO读取数据</h4><p>一个简单的读写例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> nio;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">niotest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		write();</div><div class="line">		FileInputStream fin= <span class="keyword">new</span> FileInputStream(<span class="string">"e:\\test.txt"</span>);</div><div class="line">		FileChannel fc= fin.getChannel();</div><div class="line">		</div><div class="line">		ByteBuffer buffer=ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">		</div><div class="line">		fc.read(buffer);</div><div class="line">		</div><div class="line">		buffer.flip();</div><div class="line">		</div><div class="line">		<span class="keyword">while</span>(buffer.remaining()&gt;<span class="number">0</span>)&#123;</div><div class="line">			<span class="keyword">byte</span> b=buffer.get();</div><div class="line">			System.out.print((<span class="keyword">char</span>)b);</div><div class="line">		&#125;</div><div class="line">		fin.close();</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">		<span class="keyword">byte</span> message[] = &#123; <span class="number">83</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">32</span>,  </div><div class="line">		        <span class="number">98</span>, <span class="number">121</span>, <span class="number">116</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">46</span> &#125;;</div><div class="line">		FileOutputStream fout = <span class="keyword">new</span> FileOutputStream( <span class="string">"e:\\test.txt"</span> );  </div><div class="line">        </div><div class="line">        FileChannel fc = fout.getChannel();  </div><div class="line">          </div><div class="line">        ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );  </div><div class="line">          </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;message.length; ++i) &#123;  </div><div class="line">            buffer.put( message[i] );  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        buffer.flip();  </div><div class="line">          </div><div class="line">        fc.write( buffer );  </div><div class="line">          </div><div class="line">        fout.close();  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java1.4之前的I/O系统中，提供的都是面向流的I/O系统，系统一次一个字节地处理数据，一个输入流产生一个字节的数据，一个输出流消费一个字节的数据，面向流的I/O速度非常慢，而在Java 1.4中推出了NIO，这是一个面向块的I/O系统，系统以块的方式处理处理，每一个
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍15-nio 总结</title>
    <link href="http://yoursite.com/2017/02/27/15-javanio5/"/>
    <id>http://yoursite.com/2017/02/27/15-javanio5/</id>
    <published>2017-02-27T12:52:12.000Z</published>
    <updated>2017-02-27T10:29:49.608Z</updated>
    
    <content type="html"><![CDATA[<p>Java NIO 由以下几个核心部分组成：</p>
<ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>
<p>下面是JAVA NIO中的一些主要Channel的实现：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>正如你所看到的，这些通道涵盖了UDP 和 TCP 网络IO，以及文件IO。</p>
<p>以下是Java NIO里关键的Buffer实现：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如，在一个聊天服务器中。</p>
<p>要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。</p>
<p>总结：</p>
<p>为什么使用nio？</p>
<p>NIO 的创建目的是为了让 Java 程序员可以实现高速 I/O 而无需编写自定义的本机代码。NIO 将最耗时的 I/O 操作(即填充和提取缓冲区)转移回操作系统，因而可以极大地提高速度。</p>
<p>文件读写实例:</p>
<p><a href="http://blog.csdn.net/chenleixing/article/details/44207469" target="_blank" rel="external">http://blog.csdn.net/chenleixing/article/details/44207469</a></p>
<p>nio和io比较分析：</p>
<p>NIO 设计背后的基石：反应器模式，用于事件多路分离和分派的体系结构模式。 </p>
<p>反应器（Reactor）：用于事件多路分离和分派的体系结构模式 </p>
<p>通常的，对一个文件描述符指定的文件或设备, 有两种工作方式: 阻塞 与非阻塞 。所谓阻塞方式的意思是指, 当试图对该文件描述符进行读写时, 如果当时没有东西可读,或者暂时不可写, 程序就进入等待 状态, 直到有东西可读或者可写为止。而对于非阻塞状态, 如果没有东西可读, 或者不可写, 读写函数马上返回, 而不会等待 。 </p>
<p>一种常用做法是：每建立一个Socket连接时，同时创建一个新线程对该Socket进行单独通信（采用阻塞的方式通信）。这种方式具有很高的响应速度，并且控制起来也很简单，在连接数较少的时候非常有效，但是如果对每一个连接都产生一个线程的无疑是对系统资源的一种浪费，如果连接数较多将会出现资源不足的情况。 </p>
<p>另一种较高效的做法是：服务器端保存一个Socket连接列表，然后对这个列表进行轮询，如果发现某个Socket端口上有数据可读时（读就绪），则调用该socket连接的相应读操作；如果发现某个 Socket端口上有数据可写时（写就绪），则调用该socket连接的相应写操作；如果某个端口的Socket连接已经中断，则调用相应的析构方法关闭该端口。这样能充分利用服务器资源，效率得到了很大提高。 </p>
<p>转自：<a href="http://javag.javaeye.com/blog/221641" target="_blank" rel="external">http://javag.javaeye.com/blog/221641</a> </p>
<p>传统的阻塞式IO，每个连接必须要开一个线程来处理，并且没处理完线程不能退出。 </p>
<p>非阻塞式IO，由于基于反应器模式，用于事件多路分离和分派的体系结构模式，所以可以利用线程池来处理。事件来了就处理，处理完了就把线程归还。而传统阻塞方式不能使用线程池来处理，假设当前有10000个连接，非阻塞方式可能用1000个线程的线程池就搞定了，而传统阻塞方式就需要开10000个来处理。如果连接数较多将会出现资源不足的情况。非阻塞的核心优势就在这里。 </p>
<p>为什么会这样，下面就对他们做进一步细致具体的分析： </p>
<p>首先，我们来分析传统阻塞式IO的瓶颈在哪里。在连接数不多的情况下，传统IO编写容易方便使用。但是随着连接数的增多，问题传统IO就不行了。因为前面说过，传统IO处理每个连接都要消耗一个线程，而程序的效率当线程数不多时是随着线程数的增加而增加，但是到一定的数量之后，是随着线程数的增加而减少。这里我们得出结论，传统阻塞式IO的瓶颈在于不能处理过多的连接。 </p>
<p>然后，非阻塞式IO的出现的目的就是为了解决这个瓶颈。而非阻塞式IO是怎么实现的呢？非阻塞IO处理连接的线程数和连接数没有联系，也就是说处理 10000个连接非阻塞IO不需要10000个线程，你可以用1000个也可以用2000个线程来处理。因为非阻塞IO处理连接是异步的。当某个连接发送请求到服务器，服务器把这个连接请求当作一个请求”事件”，并把这个”事件”分配给相应的函数处理。我们可以把这个处理函数放到线程中去执行，执行完就把线程归还。这样一个线程就可以异步的处理多个事件。而阻塞式IO的线程的大部分时间都浪费在等待请求上了。 </p>
<p>所谓阻塞式IO流，就是指在从数据流当中读写数据的的时候，阻塞当前线程，直到IO流可以<br>重新使用为止，你也可以使用流的avaliableBytes()函数看看当前流当中有多少字节可以读取，这样<br>就不会再阻塞了。 </p>
<p>实例连接：<br><a href="http://blog.csdn.net/zmx729618/article/details/51859456" target="_blank" rel="external">http://blog.csdn.net/zmx729618/article/details/51859456</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java NIO 由以下几个核心部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Channels&lt;/li&gt;
&lt;li&gt;Buffers&lt;/li&gt;
&lt;li&gt;Selectors&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是JAVA NIO中的一些主要Channel的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;F
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍15-nio4</title>
    <link href="http://yoursite.com/2017/02/27/15-javanio4/"/>
    <id>http://yoursite.com/2017/02/27/15-javanio4/</id>
    <published>2017-02-27T12:52:12.000Z</published>
    <updated>2017-02-27T10:29:25.281Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中介绍了关于缓冲区的一些细节内容，现在终于可以进入NIO中最有意思的部分非阻塞I/O。通常在进行同步I/O操作时，如果读取数据，代码会阻塞直至有 可供读取的数据。同样，写入调用将会阻塞直至数据能够写入。传统的Server/Client模式会基于TPR（Thread per Request）,服务器会为每个客户端请求建立一个线程，由该线程单独负责处理一个客户请求。这种模式带来的一个问题就是线程数量的剧增，大量的线程会增大服务器的开销。大多数的实现为了避免这个问题，都采用了线程池模型，并设置线程池线程的最大数量，这由带来了新的问题，如果线程池中有200个线程，而有200个用户都在进行大文件下载，会导致第201个用户的请求无法及时处理，即便第201个用户只想请求一个几KB大小的页面</p>
<p>NIO中非阻塞I/O采用了基于Reactor模式的工作方式，I/O调用不会被阻塞，相反是注册感兴趣的特定I/O事件，如可读数据到达，新的套接字连接等等，在发生特定事件时，系统再通知我们。NIO中实现非阻塞I/O的核心对象就是Selector，Selector就是注册各种I/O事件地 方，而且当那些事件发生时，就是这个对象告诉我们所发生的事件。</p>
<p>当有读或写等任何注册的事件发生时，可以从Selector中获得相应的SelectionKey，同时从 SelectionKey中可以找到发生的事件和该事件所发生的具体的SelectableChannel，以获得客户端发送过来的数据。关于 SelectableChannel的可以参考Java NIO使用及原理分析（一）<br>使用NIO中非阻塞I/O编写服务器处理程序，大体上可以分为下面三个步骤：</p>
<ol>
<li>向Selector对象注册感兴趣的事件 </li>
<li>从Selector中获取感兴趣的事件 </li>
<li>根据不同的事件进行相应的处理</li>
</ol>
<p>接下来我们用一个简单的示例来说明整个过程。首先是向Selector对象注册感兴趣的事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 注册事件 </div><div class="line"> * */  </div><div class="line"><span class="function"><span class="keyword">protected</span> Selector <span class="title">getSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </div><div class="line">    <span class="comment">// 创建Selector对象  </span></div><div class="line">    Selector sel = Selector.open();  </div><div class="line">      </div><div class="line">    <span class="comment">// 创建可选择通道，并配置为非阻塞模式  </span></div><div class="line">    ServerSocketChannel server = ServerSocketChannel.open();  </div><div class="line">    server.configureBlocking(<span class="keyword">false</span>);  </div><div class="line">      </div><div class="line">    <span class="comment">// 绑定通道到指定端口  </span></div><div class="line">    ServerSocket socket = server.socket();  </div><div class="line">    InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(port);  </div><div class="line">    socket.bind(address);  </div><div class="line">      </div><div class="line">    <span class="comment">// 向Selector中注册感兴趣的事件  </span></div><div class="line">    server.register(sel, SelectionKey.OP_ACCEPT);   </div><div class="line">    <span class="keyword">return</span> sel;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建了ServerSocketChannel对象，并调用configureBlocking()方法，配置为非阻塞模式，接下来的三行代码把该通道绑定到指定端口，最后向Selector中注册事件，此处指定的是参数是OP_ACCEPT，即指定我们想要监听accept事件，也就是新的连接发 生时所产生的事件，对于ServerSocketChannel通道来说，我们唯一可以指定的参数就是OP_ACCEPT。<br>从Selector中获取感兴趣的事件，即开始监听，进入内部循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 开始监听 </div><div class="line"> * */   </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;   </div><div class="line">    System.out.println(<span class="string">"listen on "</span> + port);  </div><div class="line">    <span class="keyword">try</span> &#123;   </div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;   </div><div class="line">            <span class="comment">// 该调用会阻塞，直到至少有一个事件发生  </span></div><div class="line">            selector.select();   </div><div class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();  </div><div class="line">            Iterator&lt;SelectionKey&gt; iter = keys.iterator();  </div><div class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;   </div><div class="line">                SelectionKey key = (SelectionKey) iter.next();   </div><div class="line">                iter.remove();   </div><div class="line">                process(key);   </div><div class="line">            &#125;   </div><div class="line">        &#125;   </div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;   </div><div class="line">        e.printStackTrace();  </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在非阻塞I/O中，内部循环模式基本都是遵循这种方式。首先调用select()方法，该方法会阻塞，直到至少有一个事件发生，然后再使用selectedKeys()方法获取发生事件的SelectionKey，再使用迭代器进行循环。<br>最后一步就是根据不同的事件，编写相应的处理代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 根据不同的事件做处理 </div><div class="line"> * */  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>&#123;  </div><div class="line">    <span class="comment">// 接收请求  </span></div><div class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;  </div><div class="line">        ServerSocketChannel server = (ServerSocketChannel) key.channel();  </div><div class="line">        SocketChannel channel = server.accept();  </div><div class="line">        channel.configureBlocking(<span class="keyword">false</span>);  </div><div class="line">        channel.register(selector, SelectionKey.OP_READ);  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 读信息  </span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;  </div><div class="line">        SocketChannel channel = (SocketChannel) key.channel();   </div><div class="line">        <span class="keyword">int</span> count = channel.read(buffer);   </div><div class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;   </div><div class="line">            buffer.flip();   </div><div class="line">            CharBuffer charBuffer = decoder.decode(buffer);   </div><div class="line">            name = charBuffer.toString();   </div><div class="line">            SelectionKey sKey = channel.register(selector, SelectionKey.OP_WRITE);   </div><div class="line">            sKey.attach(name);   </div><div class="line">        &#125; <span class="keyword">else</span> &#123;   </div><div class="line">            channel.close();   </div><div class="line">        &#125;   </div><div class="line">        buffer.clear();   </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 写事件  </span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;  </div><div class="line">        SocketChannel channel = (SocketChannel) key.channel();   </div><div class="line">        String name = (String) key.attachment();   </div><div class="line">          </div><div class="line">        ByteBuffer block = encoder.encode(CharBuffer.wrap(<span class="string">"Hello "</span> + name));   </div><div class="line">        <span class="keyword">if</span>(block != <span class="keyword">null</span>)  </div><div class="line">        &#123;  </div><div class="line">            channel.write(block);  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span>  </div><div class="line">        &#123;  </div><div class="line">            channel.close();  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">     &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>zhuanzai:<a href="http://blog.csdn.net/wuxianglong/article/details/6612282" target="_blank" rel="external">http://blog.csdn.net/wuxianglong/article/details/6612282</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中介绍了关于缓冲区的一些细节内容，现在终于可以进入NIO中最有意思的部分非阻塞I/O。通常在进行同步I/O操作时，如果读取数据，代码会阻塞直至有 可供读取的数据。同样，写入调用将会阻塞直至数据能够写入。传统的Server/Client模式会基于TPR（Threa
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍15-nio3</title>
    <link href="http://yoursite.com/2017/02/27/15-javanio3/"/>
    <id>http://yoursite.com/2017/02/27/15-javanio3/</id>
    <published>2017-02-27T12:52:12.000Z</published>
    <updated>2017-02-27T09:42:01.792Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中介绍了缓冲区内部对于状态变化的跟踪机制，而对于NIO中缓冲区来说，还有很多的内容值的学习，如缓冲区的分片与数据共享，只读缓冲区等。在本文中我们来看一下缓冲区一些更细节的内容。</p>
<h4 id="缓冲区的分配"><a href="#缓冲区的分配" class="headerlink" title="缓冲区的分配"></a>缓冲区的分配</h4><p>在前面的几个例子中，我们已经看过了，在创建一个缓冲区对象时，会调用静态方法allocate()来指定缓冲区的容量，其实调用 allocate()相当于创建了一个指定大小的数组，并把它包装为缓冲区对象。或者我们也可以直接将一个现有的数组，包装为缓冲区对象，如下示例代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferWrap</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span>  </span></div><div class="line">    &#123;  </div><div class="line">        <span class="comment">// 分配指定大小的缓冲区  </span></div><div class="line">        ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">10</span>);  </div><div class="line">          </div><div class="line">        <span class="comment">// 包装一个现有的数组  </span></div><div class="line">        <span class="keyword">byte</span> array[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];  </div><div class="line">        ByteBuffer buffer2 = ByteBuffer.wrap( array );  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="缓冲区分片"><a href="#缓冲区分片" class="headerlink" title="缓冲区分片"></a>缓冲区分片</h4><p>在NIO中，除了可以分配或者包装一个缓冲区对象外，还可以根据现有的缓冲区对象来创建一个子缓冲区，即在现有缓冲区上切出一片来作为一个新的缓冲区，但现有的缓冲区与创建的子缓冲区在底层数组层面上是数据共享的，也就是说，子缓冲区相当于是现有缓冲区的一个视图窗口。调用slice()方法可以创建一个子缓冲区，让我们通过例子来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.nio.*;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        ByteBuffer buffer = ByteBuffer.allocate( <span class="number">10</span> );  </div><div class="line">          </div><div class="line">        <span class="comment">// 缓冲区中的数据0-9  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buffer.capacity(); ++i) &#123;  </div><div class="line">            buffer.put( (<span class="keyword">byte</span>)i );  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        <span class="comment">// 创建子缓冲区  </span></div><div class="line">        buffer.position( <span class="number">3</span> );  </div><div class="line">        buffer.limit( <span class="number">7</span> );  </div><div class="line">        ByteBuffer slice = buffer.slice();  </div><div class="line">          </div><div class="line">        <span class="comment">// 改变子缓冲区的内容  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;slice.capacity(); ++i) &#123;  </div><div class="line">            <span class="keyword">byte</span> b = slice.get( i );  </div><div class="line">            b *= <span class="number">10</span>;  </div><div class="line">            slice.put( i, b );  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        buffer.position( <span class="number">0</span> );  </div><div class="line">        buffer.limit( buffer.capacity() );  </div><div class="line">          </div><div class="line">        <span class="keyword">while</span> (buffer.remaining()&gt;<span class="number">0</span>) &#123;  </div><div class="line">            System.out.println( buffer.get() );  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在该示例中，分配了一个容量大小为10的缓冲区，并在其中放入了数据0-9，而在该缓冲区基础之上又创建了一个子缓冲区，并改变子缓冲区中的内容，从最后输出的结果来看，只有子缓冲区“可见的”那部分数据发生了变化，并且说明子缓冲区与原缓冲区是数据共享的，输出结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">30</div><div class="line">40</div><div class="line">50</div><div class="line">60</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td></tr></table></figure>
<h4 id="只读缓存区"><a href="#只读缓存区" class="headerlink" title="只读缓存区"></a>只读缓存区</h4><p>只读缓冲区非常简单，可以读取它们，但是不能向它们写入数据。可以通过调用缓冲区的asReadOnlyBuffer()方法，将任何常规缓冲区转 换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区，并与原缓冲区共享数据，只不过它是只读的。如果原缓冲区的内容发生了变化，只读缓冲区的内容也随之发生变化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.nio.*;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        ByteBuffer buffer = ByteBuffer.allocate( <span class="number">10</span> );  </div><div class="line">          </div><div class="line">        <span class="comment">// 缓冲区中的数据0-9  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buffer.capacity(); ++i) &#123;  </div><div class="line">            buffer.put( (<span class="keyword">byte</span>)i );  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="comment">// 创建只读缓冲区  </span></div><div class="line">        ByteBuffer readonly = buffer.asReadOnlyBuffer();  </div><div class="line">          </div><div class="line">        <span class="comment">// 改变原缓冲区的内容  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buffer.capacity(); ++i) &#123;  </div><div class="line">            <span class="keyword">byte</span> b = buffer.get( i );  </div><div class="line">            b *= <span class="number">10</span>;  </div><div class="line">            buffer.put( i, b );  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        readonly.position(<span class="number">0</span>);  </div><div class="line">        readonly.limit(buffer.capacity());  </div><div class="line">          </div><div class="line">        <span class="comment">// 只读缓冲区的内容也随之改变  </span></div><div class="line">        <span class="keyword">while</span> (readonly.remaining()&gt;<span class="number">0</span>) &#123;  </div><div class="line">            System.out.println( readonly.get());  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果尝试修改只读缓冲区的内容，则会报ReadOnlyBufferException异常。只读缓冲区对于保护数据很有用。在将缓冲区传递给某个 对象的方法时，无法知道这个方法是否会修改缓冲区中的数据。创建一个只读的缓冲区可以保证该缓冲区不会被修改。只可以把常规缓冲区转换为只读缓冲区，而不能将只读的缓冲区转换为可写的缓冲区。</p>
<h4 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h4><p>直接缓冲区是为加快I/O速度，使用一种特殊方式为其分配内存的缓冲区，JDK文档中的描述为：给定一个直接字节缓冲区，Java虚拟机将尽最大努 力直接对它执行本机I/O操作。也就是说，它会在每一次调用底层操作系统的本机I/O操作之前(或之后)，尝试避免将缓冲区的内容拷贝到一个中间缓冲区中 或者从一个中间缓冲区中拷贝数据。要分配直接缓冲区，需要调用allocateDirect()方法，而不是allocate()方法，使用方式与普通缓冲区并无区别，如下面的拷贝文件示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;  </div><div class="line"><span class="keyword">import</span> java.nio.*;  </div><div class="line"><span class="keyword">import</span> java.nio.channels.*;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        String infile = <span class="string">"c:\\test.txt"</span>;  </div><div class="line">        FileInputStream fin = <span class="keyword">new</span> FileInputStream( infile );  </div><div class="line">        FileChannel fcin = fin.getChannel();  </div><div class="line">          </div><div class="line">        String outfile = String.format(<span class="string">"c:\\testcopy.txt"</span>);  </div><div class="line">        FileOutputStream fout = <span class="keyword">new</span> FileOutputStream( outfile );      </div><div class="line">        FileChannel fcout = fout.getChannel();  </div><div class="line">          </div><div class="line">        <span class="comment">// 使用allocateDirect，而不是allocate  </span></div><div class="line">        ByteBuffer buffer = ByteBuffer.allocateDirect( <span class="number">1024</span> );  </div><div class="line">          </div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </div><div class="line">            buffer.clear();  </div><div class="line">              </div><div class="line">            <span class="keyword">int</span> r = fcin.read( buffer );  </div><div class="line">              </div><div class="line">            <span class="keyword">if</span> (r==-<span class="number">1</span>) &#123;  </div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">            &#125;  </div><div class="line">              </div><div class="line">            buffer.flip();  </div><div class="line">              </div><div class="line">            fcout.write( buffer );  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内存映射文件I/O</p>
<p>内存映射文件I/O是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的I/O快的多。内存映射文件I/O是通过使文件中的数据出现为 内存数组的内容来完成的，这其中听起来似乎不过就是将整个文件读到内存中，但是事实上并不是这样。一般来说，只有文件中实际读取或者写入的部分才会映射到内存中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中介绍了缓冲区内部对于状态变化的跟踪机制，而对于NIO中缓冲区来说，还有很多的内容值的学习，如缓冲区的分片与数据共享，只读缓冲区等。在本文中我们来看一下缓冲区一些更细节的内容。&lt;/p&gt;
&lt;h4 id=&quot;缓冲区的分配&quot;&gt;&lt;a href=&quot;#缓冲区的分配&quot; clas
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍16-nio2</title>
    <link href="http://yoursite.com/2017/02/27/15-javanio2/"/>
    <id>http://yoursite.com/2017/02/27/15-javanio2/</id>
    <published>2017-02-27T12:52:12.000Z</published>
    <updated>2017-02-27T08:44:34.886Z</updated>
    
    <content type="html"><![CDATA[<p>在第一篇中，我们介绍了NIO中的两个核心对象：缓冲区和通道，在谈到缓冲区时，我们说缓冲区对象本质上是一个数组，但它其实是一个特殊的数组，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况，如果我们使用get()方法从缓冲区获取数据或者使用put()方法把数据写入缓冲区，都会引起缓冲区状态的变化。本文为NIO使用及原理分析的第二篇，将会分析NIO中的Buffer对象。</p>
<p>在缓冲区中，最重要的属性有下面三个，它们一起合作完成对缓冲区内部状态的变化跟踪：</p>
<ul>
<li>position：指定了下一个将要被写入或者读取的元素索引，它的值由get()/put()方法自动更新，在新创建一个Buffer对象时，position被初始化为0。</li>
<li>limit：指定还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。</li>
<li>capacity：指定了可以存储在缓冲区中的最大数据容量，实际上，它指定了底层数组的大小，或者至少是指定了准许我们使用的底层数组的容量。<br>以上四个属性值之间有一些相对大小的关系：0 &lt;= position &lt;= limit &lt;= capacity。如果我们创建一个新的容量大小为10的ByteBuffer对象，在初始化的时候，position设置为0，limit和 capacity被设置为10，在以后使用ByteBuffer对象过程中，capacity的值不会再发生变化，而其它两个个将会随着使用而变化。</li>
</ul>
<h4 id="变化过程"><a href="#变化过程" class="headerlink" title="变化过程"></a>变化过程</h4><p>以上四个属性值之间有一些相对大小的关系：0 &lt;= position &lt;= limit &lt;= capacity。如果我们创建一个新的容量大小为10的ByteBuffer对象，在初始化的时候，position设置为0，limit和 capacity被设置为10，在以后使用ByteBuffer对象过程中，capacity的值不会再发生变化，而其它两个个将会随着使用而变化、</p>
<p>现在我们可以从通道中读取一些数据到缓冲区中，注意从通道读取数据，相当于往缓冲区中写入数据。如果读取4个自己的数据，则此时position的值为4，即下一个将要被写入的字节索引为4，而limit仍然是10</p>
<p>下一步把读取的数据写入到输出通道中，相当于从缓冲区中读取数据，在此之前，必须调用flip()方法，该方法将会完成两件事情：</p>
<ol>
<li>把limit设置为当前的position值 </li>
<li>把position设置为0</li>
</ol>
<p>由于position被设置为0，所以可以保证在下一步输出时读取到的是缓冲区中的第一个字节，而limit被设置为当前的position，可以保证读取的数据正好是之前写入到缓冲区中的数据，</p>
<p>现在调用get()方法从缓冲区中读取数据写入到输出通道，这会导致position的增加而limit保持不变，但position不会超过limit的值，所以在读取我们之前写入到缓冲区中的4个自己之后，position和limit的值都为4</p>
<p>在从缓冲区中读取数据完毕后，limit的值仍然保持在我们调用flip()方法时的值，调用clear()方法能够把所有的状态变化设置为初始化时的值。</p>
<p>实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> nio;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</div><div class="line"><span class="keyword">import</span> java.nio.Buffer;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">niotest2</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(String step, Buffer buffer)</span> </span>&#123;  </div><div class="line">        System.out.println(step + <span class="string">" : "</span>);  </div><div class="line">        System.out.print(<span class="string">"capacity: "</span> + buffer.capacity() + <span class="string">", "</span>);  </div><div class="line">        System.out.print(<span class="string">"position: "</span> + buffer.position() + <span class="string">", "</span>);  </div><div class="line">        System.out.println(<span class="string">"limit: "</span> + buffer.limit());  </div><div class="line">        System.out.println();  </div><div class="line">    &#125;  </div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		FileInputStream fin=<span class="keyword">new</span> FileInputStream(<span class="string">"e:\\test.txt"</span> );</div><div class="line">		FileChannel fc=fin.getChannel();</div><div class="line">		</div><div class="line">		ByteBuffer buffer= ByteBuffer.allocate(<span class="number">10</span>);</div><div class="line">		output(<span class="string">"初始化"</span>, buffer);</div><div class="line">		</div><div class="line">		fc.read(buffer);  </div><div class="line">        output(<span class="string">"调用read()"</span>, buffer);</div><div class="line">        </div><div class="line">        buffer.flip();  </div><div class="line">        output(<span class="string">"调用flip()"</span>, buffer);  </div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (buffer.remaining() &gt; <span class="number">0</span>) &#123;  </div><div class="line">            <span class="keyword">byte</span> b = buffer.get();  </div><div class="line">            <span class="comment">// System.out.print(((char)b));  </span></div><div class="line">        &#125;  </div><div class="line">        output(<span class="string">"调用get()"</span>, buffer); </div><div class="line">        </div><div class="line">        buffer.clear();  </div><div class="line">        output(<span class="string">"调用clear()"</span>, buffer);  </div><div class="line">  </div><div class="line">        fin.close();  </div><div class="line">		</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>result:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">初始化 : </div><div class="line">capacity: <span class="number">10</span>, position: <span class="number">0</span>, limit: <span class="number">10</span></div><div class="line"></div><div class="line">调用read() : </div><div class="line">capacity: <span class="number">10</span>, position: <span class="number">10</span>, limit: <span class="number">10</span></div><div class="line"></div><div class="line">调用flip() : </div><div class="line">capacity: <span class="number">10</span>, position: <span class="number">0</span>, limit: <span class="number">10</span></div><div class="line"></div><div class="line">调用get() : </div><div class="line">capacity: <span class="number">10</span>, position: <span class="number">10</span>, limit: <span class="number">10</span></div><div class="line"></div><div class="line">调用clear() : </div><div class="line">capacity: <span class="number">10</span>, position: <span class="number">0</span>, limit: <span class="number">10</span></div></pre></td></tr></table></figure>
<p>转载：<a href="http://blog.csdn.net/wuxianglong/article/details/6612246" target="_blank" rel="external">http://blog.csdn.net/wuxianglong/article/details/6612246</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在第一篇中，我们介绍了NIO中的两个核心对象：缓冲区和通道，在谈到缓冲区时，我们说缓冲区对象本质上是一个数组，但它其实是一个特殊的数组，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况，如果我们使用get()方法从缓冲区获取数据或者使用put()方法把数据写入缓
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍4-stack&amp;queue</title>
    <link href="http://yoursite.com/2017/02/25/4-Stack%20and%20Queue/"/>
    <id>http://yoursite.com/2017/02/25/4-Stack and Queue/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T06:24:51.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stack-and-Queue"><a href="#Stack-and-Queue" class="headerlink" title="Stack and Queue"></a>Stack and Queue</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java里有一个叫做<em>Stack</em>的类，却没有叫做<em>Queue</em>的类（它是个接口名字）。当需要使用栈时，Java已不推荐使用<em>Stack</em>，而是推荐使用更高效的<em>ArrayDeque</em>；既然<em>Queue</em>只是一个接口，当需要使用队列时也就首选<em>ArrayDeque</em>了（次选是<em>LinkedList</em>）。</p>
<h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>要讲栈和队列，首先要讲<em>Deque</em>接口。<em>Deque</em>的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了<em>Deque</em>与<em>Queue</em>相对应的接口：</p>
<table>
<thead>
<tr>
<th>Queue Method</th>
<th>Equivalent Deque Method</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add(e)</code></td>
<td><code>addLast(e)</code></td>
<td>向队尾插入元素，失败则抛出异常</td>
</tr>
<tr>
<td><code>offer(e)</code></td>
<td><code>offerLast(e)</code></td>
<td>向队尾插入元素，失败则返回<code>false</code></td>
</tr>
<tr>
<td><code>remove()</code></td>
<td><code>removeFirst()</code></td>
<td>获取并删除队首元素，失败则抛出异常</td>
</tr>
<tr>
<td><code>poll()</code></td>
<td><code>pollFirst()</code></td>
<td>获取并删除队首元素，失败则返回<code>null</code></td>
</tr>
<tr>
<td><code>element()</code></td>
<td><code>getFirst()</code></td>
<td>获取但不删除队首元素，失败则抛出异常</td>
</tr>
<tr>
<td><code>peek()</code></td>
<td><code>peekFirst()</code></td>
<td>获取但不删除队首元素，失败则返回<code>null</code></td>
</tr>
</tbody>
</table>
<p>下表列出了<em>Deque</em>与<em>Stack</em>对应的接口：</p>
<table>
<thead>
<tr>
<th>Stack Method</th>
<th>Equivalent Deque Method</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>push(e)</code></td>
<td><code>addFirst(e)</code></td>
<td>向栈顶插入元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td><code>offerFirst(e)</code></td>
<td>向栈顶插入元素，失败则返回<code>false</code></td>
</tr>
<tr>
<td><code>pop()</code></td>
<td><code>removeFirst()</code></td>
<td>获取并删除栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td><code>pollFirst()</code></td>
<td>获取并删除栈顶元素，失败则返回<code>null</code></td>
</tr>
<tr>
<td><code>peek()</code></td>
<td><code>peekFirst()</code></td>
<td>获取但不删除栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td><code>peekFirst()</code></td>
<td>获取但不删除栈顶元素，失败则返回<code>null</code></td>
</tr>
</tbody>
</table>
<p>上面两个表共定义了<em>Deque</em>的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。<strong>一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值（<code>false</code>或<code>null</code>）</strong>。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。<strong>虽然<em>Deque</em>的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看</strong>。明白了这一点讲解起来就会非常简单。</p>
<p><em>ArrayDeque</em>和<em>LinkedList</em>是<em>Deque</em>的两个通用实现，由于官方更推荐使用<em>AarryDeque</em>用作栈和队列，加之上一篇已经讲解过<em>LinkedList</em>，本文将着重讲解<em>ArrayDeque</em>的具体实现。</p>
<p>从名字可以看出<em>ArrayDeque</em>底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即<strong>循环数组（circular array）</strong>，也就是说数组的任何一点都可能被看作起点或者终点。<em>ArrayDeque</em>是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入<code>null</code>元素。</p>
<p><img src="../PNGFigures/ArrayDeque_base.png" alt="ArrayDeque_base.png"></p>
<p>上图中我们看到，<strong><code>head</code>指向首端第一个有效元素，<code>tail</code>指向尾端第一个可以插入元素的空位</strong>。因为是循环数组，所以<code>head</code>不一定总等于0，<code>tail</code>也不一定总是比<code>head</code>大。</p>
<h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst()"></a>addFirst()</h2><p><code>addFirst(E e)</code>的作用是在<em>Deque</em>的首端插入元素，也就是在<code>head</code>的前面插入元素，在空间足够且下标没有越界的情况下，只需要将<code>elements[--head] = e</code>即可。</p>
<p><img src="../PNGFigures/ArrayDeque_addFirst.png" alt="ArrayDeque_addFirst.png"></p>
<p>实际需要考虑：1.空间是否够用，以及2.下标是否越界的问题。上图中，如果<code>head</code>为<code>0</code>之后接着调用<code>addFirst()</code>，虽然空余空间还够用，但<code>head</code>为<code>-1</code>，下标越界了。下列代码很好的解决了这两个问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//addFirst(E e)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//不允许放入null</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;<span class="comment">//2.下标是否越界</span></div><div class="line">    <span class="keyword">if</span> (head == tail)<span class="comment">//1.空间是否够用</span></div><div class="line">        doubleCapacity();<span class="comment">//扩容</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码我们看到，<strong>空间问题是在插入之后解决的</strong>，因为<code>tail</code>总是指向下一个可插入的空位，也就意味着<code>elements</code>数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p>
<p>下标越界的处理解决起来非常简单，<code>head = (head - 1) &amp; (elements.length - 1)</code>就可以了，<strong>这段代码相当于取余，同时解决了<code>head</code>为负值的情况</strong>。因为<code>elements.length</code>必需是<code>2</code>的指数倍，<code>elements - 1</code>就是二进制低位全<code>1</code>，跟<code>head - 1</code>相与之后就起到了取模的作用，如果<code>head - 1</code>为负数（其实只可能是-1），则相当于对其取相对于<code>elements.length</code>的补码。</p>
<p>下面再说说扩容函数<code>doubleCapacity()</code>，其逻辑是申请一个更大的数组（原数组的两倍），然后将原数组复制过去。过程如下图所示：</p>
<p><img src="../PNGFigures/ArrayDeque_doubleCapacity.png" alt="ArrayDeque_doubleCapacity.png"></p>
<p>图中我们看到，复制分两次进行，第一次复制<code>head</code>右边的元素，第二次复制<code>head</code>左边的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//doubleCapacity()</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doubleCapacity</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> head == tail;</div><div class="line">    <span class="keyword">int</span> p = head;</div><div class="line">    <span class="keyword">int</span> n = elements.length;</div><div class="line">    <span class="keyword">int</span> r = n - p; <span class="comment">// head右边元素的个数</span></div><div class="line">    <span class="keyword">int</span> newCapacity = n &lt;&lt; <span class="number">1</span>;<span class="comment">//原空间的2倍</span></div><div class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Sorry, deque too big"</span>);</div><div class="line">    Object[] a = <span class="keyword">new</span> Object[newCapacity];</div><div class="line">    System.arraycopy(elements, p, a, <span class="number">0</span>, r);<span class="comment">//复制右半部分，对应上图中绿色部分</span></div><div class="line">    System.arraycopy(elements, <span class="number">0</span>, a, r, p);<span class="comment">//复制左半部分，对应上图中灰色部分</span></div><div class="line">    elements = (E[])a;</div><div class="line">    head = <span class="number">0</span>;</div><div class="line">    tail = n;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="addLast"><a href="#addLast" class="headerlink" title="addLast()"></a>addLast()</h2><p><code>addLast(E e)</code>的作用是在<em>Deque</em>的尾端插入元素，也就是在<code>tail</code>的位置插入元素，由于<code>tail</code>总是指向下一个可以插入的空位，因此只需要<code>elements[tail] = e;</code>即可。插入完成后再检查空间，如果空间已经用光，则调用<code>doubleCapacity()</code>进行扩容。</p>
<p><img src="../PNGFigures/ArrayDeque_addLast.png" alt="ArrayDeque_addLast.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//不允许放入null</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    elements[tail] = e;<span class="comment">//赋值</span></div><div class="line">    <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)<span class="comment">//下标越界处理</span></div><div class="line">        doubleCapacity();<span class="comment">//扩容</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下标越界处理方式<code>addFirt()</code>中已经讲过，不再赘述。</p>
<h2 id="pollFirst"><a href="#pollFirst" class="headerlink" title="pollFirst()"></a>pollFirst()</h2><p><code>pollFirst()</code>的作用是删除并返回<em>Deque</em>首端元素，也即是<code>head</code>位置处的元素。如果容器不空，只需要直接返回<code>elements[head]</code>即可，当然还需要处理下标的问题。由于<code>ArrayDeque</code>中不允许放入<code>null</code>，当<code>elements[head] == null</code>时，意味着容器为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">    E result = elements[head];</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)<span class="comment">//null值意味着deque为空</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    elements[h] = <span class="keyword">null</span>;<span class="comment">//let GC work</span></div><div class="line">    head = (head + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);<span class="comment">//下标越界处理</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="pollLast"><a href="#pollLast" class="headerlink" title="pollLast()"></a>pollLast()</h2><p><code>pollLast()</code>的作用是删除并返回<em>Deque</em>尾端元素，也即是<code>tail</code>位置前面的那个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> t = (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);<span class="comment">//tail的上一个位置是最后一个元素</span></div><div class="line">    E result = elements[t];</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)<span class="comment">//null值意味着deque为空</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    elements[t] = <span class="keyword">null</span>;<span class="comment">//let GC work</span></div><div class="line">    tail = t;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="peekFirst"><a href="#peekFirst" class="headerlink" title="peekFirst()"></a>peekFirst()</h2><p><code>peekFirst()</code>的作用是返回但不删除<em>Deque</em>首端元素，也即是<code>head</code>位置处的元素，直接返回<code>elements[head]</code>即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> elements[head]; <span class="comment">// elements[head] is null if deque empty</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="peekLast"><a href="#peekLast" class="headerlink" title="peekLast()"></a>peekLast()</h2><p><code>peekLast()</code>的作用是返回但不删除<em>Deque</em>尾端元素，也即是<code>tail</code>位置前面的那个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> elements[(tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Stack-and-Queue&quot;&gt;&lt;a href=&quot;#Stack-and-Queue&quot; class=&quot;headerlink&quot; title=&quot;Stack and Queue&quot;&gt;&lt;/a&gt;Stack and Queue&lt;/h1&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍11-hashtable</title>
    <link href="http://yoursite.com/2017/02/25/11-hashtable/"/>
    <id>http://yoursite.com/2017/02/25/11-hashtable/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T07:01:27.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h1><p>转载:<a href="http://www.cnblogs.com/skywang12345/p/3310887.html" target="_blank" rel="external">http://www.cnblogs.com/skywang12345/p/3310887.html</a></p>
<h4 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h4><p>和HashMap一样，Hashtable 也是一个散列表，它存储的内容是键值对(key-value)映射。<br>Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。<br>Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。此外，Hashtable中的映射不是有序的。</p>
<p>Hashtable 的实例有两个参数影响其性能：初始容量 和 加载因子。容量 是哈希表中桶 的数量，初始容量 就是哈希表创建时的容量。注意，哈希表的状态为 open：在发生“哈希冲突”的情况下，单个桶会存储多个条目，这些条目必须按顺序搜索。加载因子 是对哈希表在其容量自动增加之前可以达到多满的一个尺度。初始容量和加载因子这两个参数只是对该实现的提示。关于何时以及是否调用 rehash 方法的具体细节则依赖于该实现。<br>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查找某个条目的时间（在大多数 Hashtable 操作中，包括 get 和 put 操作，都反映了这一点）。</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div><div class="line">573</div><div class="line">574</div><div class="line">575</div><div class="line">576</div><div class="line">577</div><div class="line">578</div><div class="line">579</div><div class="line">580</div><div class="line">581</div><div class="line">582</div><div class="line">583</div><div class="line">584</div><div class="line">585</div><div class="line">586</div><div class="line">587</div><div class="line">588</div><div class="line">589</div><div class="line">590</div><div class="line">591</div><div class="line">592</div><div class="line">593</div><div class="line">594</div><div class="line">595</div><div class="line">596</div><div class="line">597</div><div class="line">598</div><div class="line">599</div><div class="line">600</div><div class="line">601</div><div class="line">602</div><div class="line">603</div><div class="line">604</div><div class="line">605</div><div class="line">606</div><div class="line">607</div><div class="line">608</div><div class="line">609</div><div class="line">610</div><div class="line">611</div><div class="line">612</div><div class="line">613</div><div class="line">614</div><div class="line">615</div><div class="line">616</div><div class="line">617</div><div class="line">618</div><div class="line">619</div><div class="line">620</div><div class="line">621</div><div class="line">622</div><div class="line">623</div><div class="line">624</div><div class="line">625</div><div class="line">626</div><div class="line">627</div><div class="line">628</div><div class="line">629</div><div class="line">630</div><div class="line">631</div><div class="line">632</div><div class="line">633</div><div class="line">634</div><div class="line">635</div><div class="line">636</div><div class="line">637</div><div class="line">638</div><div class="line">639</div><div class="line">640</div><div class="line">641</div><div class="line">642</div><div class="line">643</div><div class="line">644</div><div class="line">645</div><div class="line">646</div><div class="line">647</div><div class="line">648</div><div class="line">649</div><div class="line">650</div><div class="line">651</div><div class="line">652</div><div class="line">653</div><div class="line">654</div><div class="line">655</div><div class="line">656</div><div class="line">657</div><div class="line">658</div><div class="line">659</div><div class="line">660</div><div class="line">661</div><div class="line">662</div><div class="line">663</div><div class="line">664</div><div class="line">665</div><div class="line">666</div><div class="line">667</div><div class="line">668</div><div class="line">669</div><div class="line">670</div><div class="line">671</div><div class="line">672</div><div class="line">673</div><div class="line">674</div><div class="line">675</div><div class="line">676</div><div class="line">677</div><div class="line">678</div><div class="line">679</div><div class="line">680</div><div class="line">681</div><div class="line">682</div><div class="line">683</div><div class="line">684</div><div class="line">685</div><div class="line">686</div><div class="line">687</div><div class="line">688</div><div class="line">689</div><div class="line">690</div><div class="line">691</div><div class="line">692</div><div class="line">693</div><div class="line">694</div><div class="line">695</div><div class="line">696</div><div class="line">697</div><div class="line">698</div><div class="line">699</div><div class="line">700</div><div class="line">701</div><div class="line">702</div><div class="line">703</div><div class="line">704</div><div class="line">705</div><div class="line">706</div><div class="line">707</div><div class="line">708</div><div class="line">709</div><div class="line">710</div><div class="line">711</div><div class="line">712</div><div class="line">713</div><div class="line">714</div><div class="line">715</div><div class="line">716</div><div class="line">717</div><div class="line">718</div><div class="line">719</div><div class="line">720</div><div class="line">721</div><div class="line">722</div><div class="line">723</div><div class="line">724</div><div class="line">725</div><div class="line">726</div><div class="line">727</div><div class="line">728</div><div class="line">729</div><div class="line">730</div><div class="line">731</div><div class="line">732</div><div class="line">733</div><div class="line">734</div><div class="line">735</div><div class="line">736</div><div class="line">737</div><div class="line">738</div><div class="line">739</div><div class="line">740</div><div class="line">741</div><div class="line">742</div><div class="line">743</div><div class="line">744</div><div class="line">745</div><div class="line">746</div><div class="line">747</div><div class="line">748</div><div class="line">749</div><div class="line">750</div><div class="line">751</div><div class="line">752</div><div class="line">753</div><div class="line">754</div><div class="line">755</div><div class="line">756</div><div class="line">757</div><div class="line">758</div><div class="line">759</div><div class="line">760</div><div class="line">761</div><div class="line">762</div><div class="line">763</div><div class="line">764</div><div class="line">765</div><div class="line">766</div><div class="line">767</div><div class="line">768</div><div class="line">769</div><div class="line">770</div><div class="line">771</div><div class="line">772</div><div class="line">773</div><div class="line">774</div><div class="line">775</div><div class="line">776</div><div class="line">777</div><div class="line">778</div><div class="line">779</div><div class="line">780</div><div class="line">781</div><div class="line">782</div><div class="line">783</div><div class="line">784</div><div class="line">785</div><div class="line">786</div><div class="line">787</div><div class="line">788</div><div class="line">789</div><div class="line">790</div><div class="line">791</div><div class="line">792</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.util;</div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</div><div class="line">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</div><div class="line"></div><div class="line">    <span class="comment">// Hashtable保存key-value的数组。</span></div><div class="line">    <span class="comment">// Hashtable是采用拉链法实现的，每一个Entry本质上是一个单向链表</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry[] table;</div><div class="line"></div><div class="line">    <span class="comment">// Hashtable中元素的实际数量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="comment">// 阈值，用于判断是否需要调整Hashtable的容量（threshold = 容量*加载因子）</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;</div><div class="line"></div><div class="line">    <span class="comment">// 加载因子</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</div><div class="line"></div><div class="line">    <span class="comment">// Hashtable被改变的次数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 序列版本号</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1421746759512286392L</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</div><div class="line">                                               initialCapacity);</div><div class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load: "</span>+loadFactor);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</div><div class="line">            initialCapacity = <span class="number">1</span>;</div><div class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">        table = <span class="keyword">new</span> Entry[initialCapacity];</div><div class="line">        threshold = (<span class="keyword">int</span>)(initialCapacity * loadFactor);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 指定“容量大小”的构造函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 默认构造函数。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 默认构造函数，指定的容量大小是11；加载因子是0.75</span></div><div class="line">        <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 包含“子Map”的构造函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</div><div class="line">        <span class="comment">// 将“子Map”的全部元素都添加到Hashtable中</span></div><div class="line">        putAll(t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 返回“所有key”的枚举对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;K&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.&lt;K&gt;getEnumeration(KEYS);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 返回“所有value”的枚举对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;V&gt; <span class="title">elements</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.&lt;V&gt;getEnumeration(VALUES);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 判断Hashtable是否包含“值(value)”</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line">        <span class="comment">// Hashtable中“键值对”的value不能是null，</span></div><div class="line">        <span class="comment">// 若是null的话，抛出异常!</span></div><div class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 从后向前遍历table数组中的元素(Entry)</span></div><div class="line">        <span class="comment">// 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value</span></div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tab.length ; i-- &gt; <span class="number">0</span> ;) &#123;</div><div class="line">            <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">                <span class="keyword">if</span> (e.value.equals(value)) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> contains(value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 判断Hashtable是否包含key</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">        <span class="comment">// 计算索引值，</span></div><div class="line">        <span class="comment">// % tab.length 的目的是防止数据越界</span></div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="comment">// 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素</span></div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 返回key对应的value，没有的话返回null</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">        <span class="comment">// 计算索引值，</span></div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="comment">// 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素</span></div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                <span class="keyword">return</span> e.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 调整Hashtable的长度，将长度变成原来的(2倍+1)</span></div><div class="line">    <span class="comment">// (01) 将“旧的Entry数组”赋值给一个临时变量。</span></div><div class="line">    <span class="comment">// (02) 创建一个“新的Entry数组”，并赋值给“旧的Entry数组”</span></div><div class="line">    <span class="comment">// (03) 将“Hashtable”中的全部元素依次添加到“新的Entry数组”中</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> oldCapacity = table.length;</div><div class="line">        Entry[] oldMap = table;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> newCapacity = oldCapacity * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line">        Entry[] newMap = <span class="keyword">new</span> Entry[newCapacity];</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</div><div class="line">        table = newMap;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</div><div class="line">            <span class="keyword">for</span> (Entry&lt;K,V&gt; old = oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</div><div class="line">                Entry&lt;K,V&gt; e = old;</div><div class="line">                old = old.next;</div><div class="line"></div><div class="line">                <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</div><div class="line">                e.next = newMap[index];</div><div class="line">                newMap[index] = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将“key-value”添加到Hashtable中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="comment">// Hashtable中不能插入value为null的元素！！！</span></div><div class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 若“Hashtable中已存在键为key的键值对”，</span></div><div class="line">        <span class="comment">// 则用“新的value”替换“旧的value”</span></div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                V old = e.value;</div><div class="line">                e.value = value;</div><div class="line">                <span class="keyword">return</span> old;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 若“Hashtable中不存在键为key的键值对”，</span></div><div class="line">        <span class="comment">// (01) 将“修改统计数”+1</span></div><div class="line">        modCount++;</div><div class="line">        <span class="comment">// (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子)</span></div><div class="line">        <span class="comment">//  则调整Hashtable的大小</span></div><div class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;</div><div class="line">            <span class="comment">// Rehash the table if the threshold is exceeded</span></div><div class="line">            rehash();</div><div class="line"></div><div class="line">            tab = table;</div><div class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// (03) 将“Hashtable中index”位置的Entry(链表)保存到e中</span></div><div class="line">        Entry&lt;K,V&gt; e = tab[index];</div><div class="line">        <span class="comment">// (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。        </span></div><div class="line">        tab[index] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</div><div class="line">        <span class="comment">// (05) 将“Hashtable的实际容量”+1</span></div><div class="line">        count++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除Hashtable中键为key的元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="comment">// 找到“key对应的Entry(链表)”</span></div><div class="line">        <span class="comment">// 然后在链表中找出要删除的节点，并删除该节点。</span></div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index], prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                modCount++;</div><div class="line">                <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</div><div class="line">                    prev.next = e.next;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    tab[index] = e.next;</div><div class="line">                &#125;</div><div class="line">                count--;</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将“Map(t)”的中全部元素逐一添加到Hashtable中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet())</div><div class="line">            put(e.getKey(), e.getValue());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 清空Hashtable</span></div><div class="line">    <span class="comment">// 将Hashtable的table数组的值全部设为null</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        Entry tab[] = table;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = tab.length; --index &gt;= <span class="number">0</span>; )</div><div class="line">            tab[index] = <span class="keyword">null</span>;</div><div class="line">        count = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 克隆一个Hashtable，并以Object的形式返回。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Hashtable&lt;K,V&gt; t = (Hashtable&lt;K,V&gt;) <span class="keyword">super</span>.clone();</div><div class="line">            t.table = <span class="keyword">new</span> Entry[table.length];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = table.length ; i-- &gt; <span class="number">0</span> ; ) &#123;</div><div class="line">                t.table[i] = (table[i] != <span class="keyword">null</span>)</div><div class="line">                ? (Entry&lt;K,V&gt;) table[i].clone() : <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            t.keySet = <span class="keyword">null</span>;</div><div class="line">            t.entrySet = <span class="keyword">null</span>;</div><div class="line">            t.values = <span class="keyword">null</span>;</div><div class="line">            t.modCount = <span class="number">0</span>;</div><div class="line">            <span class="keyword">return</span> t;</div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">            <span class="comment">// this shouldn't happen, since we are Cloneable</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> max = size() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (max == -<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="string">"&#123;&#125;"</span>;</div><div class="line"></div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = entrySet().iterator();</div><div class="line"></div><div class="line">        sb.append(<span class="string">'&#123;'</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</div><div class="line">            Map.Entry&lt;K,V&gt; e = it.next();</div><div class="line">            K key = e.getKey();</div><div class="line">            V value = e.getValue();</div><div class="line">            sb.append(key   == <span class="keyword">this</span> ? <span class="string">"(this Map)"</span> : key.toString());</div><div class="line">            sb.append(<span class="string">'='</span>);</div><div class="line">            sb.append(value == <span class="keyword">this</span> ? <span class="string">"(this Map)"</span> : value.toString());</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (i == max)</div><div class="line">                <span class="keyword">return</span> sb.append(<span class="string">'&#125;'</span>).toString();</div><div class="line">            sb.append(<span class="string">", "</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 获取Hashtable的枚举类对象</span></div><div class="line">    <span class="comment">// 若Hashtable的实际大小为0,则返回“空枚举类”对象；</span></div><div class="line">    <span class="comment">// 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口)</span></div><div class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">Enumeration&lt;T&gt; <span class="title">getEnumeration</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> (Enumeration&lt;T&gt;)emptyEnumerator;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Enumerator&lt;T&gt;(type, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 获取Hashtable的迭代器</span></div><div class="line">    <span class="comment">// 若Hashtable的实际大小为0,则返回“空迭代器”对象；</span></div><div class="line">    <span class="comment">// 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口)</span></div><div class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">Iterator&lt;T&gt; <span class="title">getIterator</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> (Iterator&lt;T&gt;) emptyIterator;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Enumerator&lt;T&gt;(type, <span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Hashtable的“key的集合”。它是一个Set，意味着没有重复元素</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Set&lt;K&gt; keySet = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// Hashtable的“key-value的集合”。它是一个Set，意味着没有重复元素</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// Hashtable的“key-value的集合”。它是一个Collection，意味着可以有重复元素</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Collection&lt;V&gt; values = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 返回一个被synchronizedSet封装后的KeySet对象</span></div><div class="line">    <span class="comment">// synchronizedSet封装的目的是对KeySet的所有方法都添加synchronized，实现多线程同步</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (keySet == <span class="keyword">null</span>)</div><div class="line">            keySet = Collections.synchronizedSet(<span class="keyword">new</span> KeySet(), <span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> keySet;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Hashtable的Key的Set集合。</span></div><div class="line">    <span class="comment">// KeySet继承于AbstractSet，所以，KeySet中的元素没有重复的。</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> getIterator(KEYS);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> count;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> containsKey(o);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Hashtable.<span class="keyword">this</span>.remove(o) != <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">            Hashtable.<span class="keyword">this</span>.clear();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 返回一个被synchronizedSet封装后的EntrySet对象</span></div><div class="line">    <span class="comment">// synchronizedSet封装的目的是对EntrySet的所有方法都添加synchronized，实现多线程同步</span></div><div class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</div><div class="line">        <span class="keyword">if</span> (entrySet==<span class="keyword">null</span>)</div><div class="line">            entrySet = Collections.synchronizedSet(<span class="keyword">new</span> EntrySet(), <span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> entrySet;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Hashtable的Entry的Set集合。</span></div><div class="line">    <span class="comment">// EntrySet继承于AbstractSet，所以，EntrySet中的元素没有重复的。</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</div><div class="line">        <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</div><div class="line">            <span class="keyword">return</span> getIterator(ENTRIES);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Map.Entry&lt;K,V&gt; o)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.add(o);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 查找EntrySet中是否包含Object(0)</span></div><div class="line">        <span class="comment">// 首先，在table中找到o对应的Entry(Entry是一个单向链表)</span></div><div class="line">        <span class="comment">// 然后，查找Entry链表中是否存在Object</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            Map.Entry entry = (Map.Entry)o;</div><div class="line">            Object key = entry.getKey();</div><div class="line">            Entry[] tab = table;</div><div class="line">            <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">            <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (Entry e = tab[index]; e != <span class="keyword">null</span>; e = e.next)</div><div class="line">                <span class="keyword">if</span> (e.hash==hash &amp;&amp; e.equals(entry))</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 删除元素Object(0)</span></div><div class="line">        <span class="comment">// 首先，在table中找到o对应的Entry(Entry是一个单向链表)</span></div><div class="line">        <span class="comment">// 然后，删除链表中的元素Object</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;</div><div class="line">            K key = entry.getKey();</div><div class="line">            Entry[] tab = table;</div><div class="line">            <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">            <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index], prev = <span class="keyword">null</span>; e != <span class="keyword">null</span>;</div><div class="line">                 prev = e, e = e.next) &#123;</div><div class="line">                <span class="keyword">if</span> (e.hash==hash &amp;&amp; e.equals(entry)) &#123;</div><div class="line">                    modCount++;</div><div class="line">                    <span class="keyword">if</span> (prev != <span class="keyword">null</span>)</div><div class="line">                        prev.next = e.next;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        tab[index] = e.next;</div><div class="line"></div><div class="line">                    count--;</div><div class="line">                    e.value = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> count;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">            Hashtable.<span class="keyword">this</span>.clear();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 返回一个被synchronizedCollection封装后的ValueCollection对象</span></div><div class="line">    <span class="comment">// synchronizedCollection封装的目的是对ValueCollection的所有方法都添加synchronized，实现多线程同步</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (values==<span class="keyword">null</span>)</div><div class="line">        values = Collections.synchronizedCollection(<span class="keyword">new</span> ValueCollection(),</div><div class="line">                                                        <span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> values;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Hashtable的value的Collection集合。</span></div><div class="line">    <span class="comment">// ValueCollection继承于AbstractCollection，所以，ValueCollection中的元素可以重复的。</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueCollection</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> getIterator(VALUES);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> count;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> containsValue(o);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">            Hashtable.<span class="keyword">this</span>.clear();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 重新equals()函数</span></div><div class="line">    <span class="comment">// 若两个Hashtable的所有key-value键值对都相等，则判断它们两个相等</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Map&lt;K,V&gt; t = (Map&lt;K,V&gt;) o;</div><div class="line">        <span class="keyword">if</span> (t.size() != size())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 通过迭代器依次取出当前Hashtable的key-value键值对</span></div><div class="line">            <span class="comment">// 并判断该键值对，存在于Hashtable(o)中。</span></div><div class="line">            <span class="comment">// 若不存在，则立即返回false；否则，遍历完“当前Hashtable”并返回true。</span></div><div class="line">            Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</div><div class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</div><div class="line">                Map.Entry&lt;K,V&gt; e = i.next();</div><div class="line">                K key = e.getKey();</div><div class="line">                V value = e.getValue();</div><div class="line">                <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (!(t.get(key)==<span class="keyword">null</span> &amp;&amp; t.containsKey(key)))</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (!value.equals(t.get(key)))</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassCastException unused)   &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 计算Hashtable的哈希值</span></div><div class="line">    <span class="comment">// 若 Hashtable的实际大小为0 或者 加载因子&lt;0，则返回0。</span></div><div class="line">    <span class="comment">// 否则，返回“Hashtable中的每个Entry的key和value的异或值 的总和”。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (count == <span class="number">0</span> || loadFactor &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> h;  <span class="comment">// Returns zero</span></div><div class="line"></div><div class="line">        loadFactor = -loadFactor;  <span class="comment">// Mark hashCode computation in progress</span></div><div class="line">        Entry[] tab = table;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i++)</div><div class="line">            <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</div><div class="line">                h += e.key.hashCode() ^ e.value.hashCode();</div><div class="line">        loadFactor = -loadFactor;  <span class="comment">// Mark hashCode computation complete</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> h;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// java.io.Serializable的写入函数</span></div><div class="line">    <span class="comment">// 将Hashtable的“总的容量，实际容量，所有的Entry”都写入到输出流中</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></div><div class="line">        <span class="keyword">throws</span> IOException</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// Write out the length, threshold, loadfactor</span></div><div class="line">        s.defaultWriteObject();</div><div class="line"></div><div class="line">        <span class="comment">// Write out length, count of elements and then the key/value objects</span></div><div class="line">        s.writeInt(table.length);</div><div class="line">        s.writeInt(count);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = table.length-<span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</div><div class="line">            Entry entry = table[index];</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (entry != <span class="keyword">null</span>) &#123;</div><div class="line">            s.writeObject(entry.key);</div><div class="line">            s.writeObject(entry.value);</div><div class="line">            entry = entry.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// java.io.Serializable的读取函数：根据写入方式读出</span></div><div class="line">    <span class="comment">// 将Hashtable的“总的容量，实际容量，所有的Entry”依次读出</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></div><div class="line">         <span class="keyword">throws</span> IOException, ClassNotFoundException</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// Read in the length, threshold, and loadfactor</span></div><div class="line">        s.defaultReadObject();</div><div class="line"></div><div class="line">        <span class="comment">// Read the original length of the array and number of elements</span></div><div class="line">        <span class="keyword">int</span> origlength = s.readInt();</div><div class="line">        <span class="keyword">int</span> elements = s.readInt();</div><div class="line"></div><div class="line">        <span class="comment">// Compute new size with a bit of room 5% to grow but</span></div><div class="line">        <span class="comment">// no larger than the original size.  Make the length</span></div><div class="line">        <span class="comment">// odd if it's large enough, this helps distribute the entries.</span></div><div class="line">        <span class="comment">// Guard against the length ending up zero, that's not valid.</span></div><div class="line">        <span class="keyword">int</span> length = (<span class="keyword">int</span>)(elements * loadFactor) + (elements / <span class="number">20</span>) + <span class="number">3</span>;</div><div class="line">        <span class="keyword">if</span> (length &gt; elements &amp;&amp; (length &amp; <span class="number">1</span>) == <span class="number">0</span>)</div><div class="line">            length--;</div><div class="line">        <span class="keyword">if</span> (origlength &gt; <span class="number">0</span> &amp;&amp; length &gt; origlength)</div><div class="line">            length = origlength;</div><div class="line"></div><div class="line">        Entry[] table = <span class="keyword">new</span> Entry[length];</div><div class="line">        count = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Read the number of elements and then all the key/value objects</span></div><div class="line">        <span class="keyword">for</span> (; elements &gt; <span class="number">0</span>; elements--) &#123;</div><div class="line">            K key = (K)s.readObject();</div><div class="line">            V value = (V)s.readObject();</div><div class="line">                <span class="comment">// synch could be eliminated for performance</span></div><div class="line">                reconstitutionPut(table, key, value);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.table = table;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reconstitutionPut</span><span class="params">(Entry[] tab, K key, V value)</span></span></div><div class="line">        <span class="keyword">throws</span> StreamCorruptedException</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></div><div class="line">        <span class="comment">// This should not happen in deserialized version.</span></div><div class="line">        <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Creates the new entry.</span></div><div class="line">        Entry&lt;K,V&gt; e = tab[index];</div><div class="line">        tab[index] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Hashtable的Entry节点，它本质上是一个单向链表。</span></div><div class="line">    <span class="comment">// 也因此，我们才能推断出Hashtable是由拉链法实现的散列表</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="comment">// 哈希值</span></div><div class="line">        <span class="keyword">int</span> hash;</div><div class="line">        K key;</div><div class="line">        V value;</div><div class="line">        <span class="comment">// 指向的下一个Entry，即链表的下一个节点</span></div><div class="line">        Entry&lt;K,V&gt; next;</div><div class="line"></div><div class="line">        <span class="comment">// 构造函数</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Entry&lt;K,V&gt; next)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.hash = hash;</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.value = value;</div><div class="line">            <span class="keyword">this</span>.next = next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value,</div><div class="line">                  (next==<span class="keyword">null</span> ? <span class="keyword">null</span> : (Entry&lt;K,V&gt;) next.clone()));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> key;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> value;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 设置value。若value是null，则抛出异常。</span></div><div class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line"></div><div class="line">            V oldValue = <span class="keyword">this</span>.value;</div><div class="line">            <span class="keyword">this</span>.value = value;</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 覆盖equals()方法，判断两个Entry是否相等。</span></div><div class="line">        <span class="comment">// 若两个Entry的key和value都相等，则认为它们相等。</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            Map.Entry e = (Map.Entry)o;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> (key==<span class="keyword">null</span> ? e.getKey()==<span class="keyword">null</span> : key.equals(e.getKey())) &amp;&amp;</div><div class="line">               (value==<span class="keyword">null</span> ? e.getValue()==<span class="keyword">null</span> : value.equals(e.getValue()));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> hash ^ (value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> key.toString()+<span class="string">"="</span>+value.toString();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEYS = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALUES = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENTRIES = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Enumerator的作用是提供了“通过elements()遍历Hashtable的接口” 和 “通过entrySet()遍历Hashtable的接口”。因为，它同时实现了 “Enumerator接口”和“Iterator接口”。</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Enumerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Enumeration</span>&lt;<span class="title">T</span>&gt;, <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">        <span class="comment">// 指向Hashtable的table</span></div><div class="line">        Entry[] table = Hashtable.<span class="keyword">this</span>.table;</div><div class="line">        <span class="comment">// Hashtable的总的大小</span></div><div class="line">        <span class="keyword">int</span> index = table.length;</div><div class="line">        Entry&lt;K,V&gt; entry = <span class="keyword">null</span>;</div><div class="line">        Entry&lt;K,V&gt; lastReturned = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">int</span> type;</div><div class="line"></div><div class="line">        <span class="comment">// Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志</span></div><div class="line">        <span class="comment">// iterator为true，表示它是迭代器；否则，是枚举类。</span></div><div class="line">        <span class="keyword">boolean</span> iterator;</div><div class="line"></div><div class="line">        <span class="comment">// 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。</span></div><div class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line"></div><div class="line">        Enumerator(<span class="keyword">int</span> type, <span class="keyword">boolean</span> iterator) &#123;</div><div class="line">            <span class="keyword">this</span>.type = type;</div><div class="line">            <span class="keyword">this</span>.iterator = iterator;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</div><div class="line">            Entry&lt;K,V&gt; e = entry;</div><div class="line">            <span class="keyword">int</span> i = index;</div><div class="line">            Entry[] t = table;</div><div class="line">            <span class="comment">/* Use locals for faster loop iteration */</span></div><div class="line">            <span class="keyword">while</span> (e == <span class="keyword">null</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;</div><div class="line">                e = t[--i];</div><div class="line">            &#125;</div><div class="line">            entry = e;</div><div class="line">            index = i;</div><div class="line">            <span class="keyword">return</span> e != <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 获取下一个元素</span></div><div class="line">        <span class="comment">// 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式”</span></div><div class="line">        <span class="comment">// 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。</span></div><div class="line">        <span class="comment">// 然后，依次向后遍历单向链表Entry。</span></div><div class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</div><div class="line">            Entry&lt;K,V&gt; et = entry;</div><div class="line">            <span class="keyword">int</span> i = index;</div><div class="line">            Entry[] t = table;</div><div class="line">            <span class="comment">/* Use locals for faster loop iteration */</span></div><div class="line">            <span class="keyword">while</span> (et == <span class="keyword">null</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;</div><div class="line">                et = t[--i];</div><div class="line">            &#125;</div><div class="line">            entry = et;</div><div class="line">            index = i;</div><div class="line">            <span class="keyword">if</span> (et != <span class="keyword">null</span>) &#123;</div><div class="line">                Entry&lt;K,V&gt; e = lastReturned = entry;</div><div class="line">                entry = e.next;</div><div class="line">                <span class="keyword">return</span> type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Hashtable Enumerator"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 迭代器Iterator的判断是否存在下一个元素</span></div><div class="line">        <span class="comment">// 实际上，它是调用的hasMoreElements()</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> hasMoreElements();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 迭代器获取下一个元素</span></div><div class="line">        <span class="comment">// 实际上，它是调用的nextElement()</span></div><div class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">            <span class="keyword">return</span> nextElement();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 迭代器的remove()接口。</span></div><div class="line">        <span class="comment">// 首先，它在table数组中找出要删除元素所在的Entry，</span></div><div class="line">        <span class="comment">// 然后，删除单向链表Entry中的元素。</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (!iterator)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">            <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Hashtable Enumerator"</span>);</div><div class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line"></div><div class="line">            <span class="keyword">synchronized</span>(Hashtable.<span class="keyword">this</span>) &#123;</div><div class="line">                Entry[] tab = Hashtable.<span class="keyword">this</span>.table;</div><div class="line">                <span class="keyword">int</span> index = (lastReturned.hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index], prev = <span class="keyword">null</span>; e != <span class="keyword">null</span>;</div><div class="line">                     prev = e, e = e.next) &#123;</div><div class="line">                    <span class="keyword">if</span> (e == lastReturned) &#123;</div><div class="line">                        modCount++;</div><div class="line">                        expectedModCount++;</div><div class="line">                        <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</div><div class="line">                            tab[index] = e.next;</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            prev.next = e.next;</div><div class="line">                        count--;</div><div class="line">                        lastReturned = <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Enumeration emptyEnumerator = <span class="keyword">new</span> EmptyEnumerator();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Iterator emptyIterator = <span class="keyword">new</span> EmptyIterator();</div><div class="line"></div><div class="line">    <span class="comment">// 空枚举类</span></div><div class="line">    <span class="comment">// 当Hashtable的实际大小为0；此时，又要通过Enumeration遍历Hashtable时，返回的是“空枚举类”的对象。</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyEnumerator</span> <span class="keyword">implements</span> <span class="title">Enumeration</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">        EmptyEnumerator() &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 空枚举类的hasMoreElements() 始终返回false</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 空枚举类的nextElement() 抛出异常</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Hashtable Enumerator"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// 空迭代器</span></div><div class="line">    <span class="comment">// 当Hashtable的实际大小为0；此时，又要通过迭代器遍历Hashtable时，返回的是“空迭代器”的对象。</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">        EmptyIterator() &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Hashtable Iterator"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Hashtable Iterator"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;hashtable&quot;&gt;&lt;a href=&quot;#hashtable&quot; class=&quot;headerlink&quot; title=&quot;hashtable&quot;&gt;&lt;/a&gt;hashtable&lt;/h1&gt;&lt;p&gt;转载:&lt;a href=&quot;http://www.cnblogs.com/skywang
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍12-iterator</title>
    <link href="http://yoursite.com/2017/02/25/12-iterator/"/>
    <id>http://yoursite.com/2017/02/25/12-iterator/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T07:18:10.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h1><p>转载:<a href="http://www.cnblogs.com/skywang12345/p/3310887.html" target="_blank" rel="external">http://www.cnblogs.com/skywang12345/p/3310887.html</a></p>
<h4 id="Iterator和Enumeration区别"><a href="#Iterator和Enumeration区别" class="headerlink" title="Iterator和Enumeration区别"></a>Iterator和Enumeration区别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.util;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Enumeration</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">nextElement</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">package</span> java.util;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(01) 函数接口不同</p>
<pre><code>Enumeration只有2个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。
Iterator只有3个函数接口。Iterator除了能读取集合的数据之外，也能数据进行删除操作。
</code></pre><p>(02) Iterator支持fail-fast机制，而Enumeration不支持。</p>
<pre><code>Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK 1.0中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步。
而Iterator 是JDK 1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iterator&quot;&gt;&lt;a href=&quot;#iterator&quot; class=&quot;headerlink&quot; title=&quot;iterator&quot;&gt;&lt;/a&gt;iterator&lt;/h1&gt;&lt;p&gt;转载:&lt;a href=&quot;http://www.cnblogs.com/skywang1234
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
</feed>
