<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lyp&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-02-27T08:30:22.464Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Loren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jcf介绍15-nio1</title>
    <link href="http://yoursite.com/2017/02/27/15-javanio/"/>
    <id>http://yoursite.com/2017/02/27/15-javanio/</id>
    <published>2017-02-27T12:52:12.000Z</published>
    <updated>2017-02-27T08:30:22.464Z</updated>
    
    <content type="html"><![CDATA[<p>在Java1.4之前的I/O系统中，提供的都是面向流的I/O系统，系统一次一个字节地处理数据，一个输入流产生一个字节的数据，一个输出流消费一个字节的数据，面向流的I/O速度非常慢，而在Java 1.4中推出了NIO，这是一个面向块的I/O系统，系统以块的方式处理处理，每一个操作在一步中产生或者消费一个数据库，按块处理要比按字节处理数据快的多。</p>
<p>在NIO中有几个核心对象需要掌握：缓冲区（Buffer）、通道（Channel）、选择器（Selector）。</p>
<h4 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h4><p>缓冲区实际上是一个容器对象，更直接的说，其实就是一个数组，在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的； 在写入数据时，它也是写入到缓冲区中的；任何时候访问 NIO 中的数据，都是将它放到缓冲区中。</p>
<p>在NIO中，所有的缓冲区类型都继承于抽象类Buffer，最常用的就是ByteBuffer.继承关系如下：</p>
<ul>
<li>buffer<ul>
<li>bytebuffer - mappedbytedbuffer </li>
<li>charbuffer</li>
<li>doublebuffer</li>
<li>floatbuffer</li>
<li>intbuffer</li>
<li>longbuffer</li>
<li>shortbuffer</li>
</ul>
</li>
</ul>
<h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><p>通道是一个对象，通过它可以读取和写入数据，当然了所有数据都通过Buffer对象来处理。我们永远不会将字节直接写入通道中，相反是将数据写入包含一个或者多个字节的缓冲区。同样不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</p>
<h4 id="使用NIO读取数据"><a href="#使用NIO读取数据" class="headerlink" title="使用NIO读取数据"></a>使用NIO读取数据</h4><p>一个简单的读写例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> nio;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">niotest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		write();</div><div class="line">		FileInputStream fin= <span class="keyword">new</span> FileInputStream(<span class="string">"e:\\test.txt"</span>);</div><div class="line">		FileChannel fc= fin.getChannel();</div><div class="line">		</div><div class="line">		ByteBuffer buffer=ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">		</div><div class="line">		fc.read(buffer);</div><div class="line">		</div><div class="line">		buffer.flip();</div><div class="line">		</div><div class="line">		<span class="keyword">while</span>(buffer.remaining()&gt;<span class="number">0</span>)&#123;</div><div class="line">			<span class="keyword">byte</span> b=buffer.get();</div><div class="line">			System.out.print((<span class="keyword">char</span>)b);</div><div class="line">		&#125;</div><div class="line">		fin.close();</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">		<span class="keyword">byte</span> message[] = &#123; <span class="number">83</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">32</span>,  </div><div class="line">		        <span class="number">98</span>, <span class="number">121</span>, <span class="number">116</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">46</span> &#125;;</div><div class="line">		FileOutputStream fout = <span class="keyword">new</span> FileOutputStream( <span class="string">"e:\\test.txt"</span> );  </div><div class="line">        </div><div class="line">        FileChannel fc = fout.getChannel();  </div><div class="line">          </div><div class="line">        ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );  </div><div class="line">          </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;message.length; ++i) &#123;  </div><div class="line">            buffer.put( message[i] );  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        buffer.flip();  </div><div class="line">          </div><div class="line">        fc.write( buffer );  </div><div class="line">          </div><div class="line">        fout.close();  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java1.4之前的I/O系统中，提供的都是面向流的I/O系统，系统一次一个字节地处理数据，一个输入流产生一个字节的数据，一个输出流消费一个字节的数据，面向流的I/O速度非常慢，而在Java 1.4中推出了NIO，这是一个面向块的I/O系统，系统以块的方式处理处理，每一个
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍15-nio3</title>
    <link href="http://yoursite.com/2017/02/27/15-javanio3/"/>
    <id>http://yoursite.com/2017/02/27/15-javanio3/</id>
    <published>2017-02-27T12:52:12.000Z</published>
    <updated>2017-02-27T09:42:01.792Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中介绍了缓冲区内部对于状态变化的跟踪机制，而对于NIO中缓冲区来说，还有很多的内容值的学习，如缓冲区的分片与数据共享，只读缓冲区等。在本文中我们来看一下缓冲区一些更细节的内容。</p>
<h4 id="缓冲区的分配"><a href="#缓冲区的分配" class="headerlink" title="缓冲区的分配"></a>缓冲区的分配</h4><p>在前面的几个例子中，我们已经看过了，在创建一个缓冲区对象时，会调用静态方法allocate()来指定缓冲区的容量，其实调用 allocate()相当于创建了一个指定大小的数组，并把它包装为缓冲区对象。或者我们也可以直接将一个现有的数组，包装为缓冲区对象，如下示例代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferWrap</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span>  </span></div><div class="line">    &#123;  </div><div class="line">        <span class="comment">// 分配指定大小的缓冲区  </span></div><div class="line">        ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">10</span>);  </div><div class="line">          </div><div class="line">        <span class="comment">// 包装一个现有的数组  </span></div><div class="line">        <span class="keyword">byte</span> array[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];  </div><div class="line">        ByteBuffer buffer2 = ByteBuffer.wrap( array );  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="缓冲区分片"><a href="#缓冲区分片" class="headerlink" title="缓冲区分片"></a>缓冲区分片</h4><p>在NIO中，除了可以分配或者包装一个缓冲区对象外，还可以根据现有的缓冲区对象来创建一个子缓冲区，即在现有缓冲区上切出一片来作为一个新的缓冲区，但现有的缓冲区与创建的子缓冲区在底层数组层面上是数据共享的，也就是说，子缓冲区相当于是现有缓冲区的一个视图窗口。调用slice()方法可以创建一个子缓冲区，让我们通过例子来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.nio.*;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        ByteBuffer buffer = ByteBuffer.allocate( <span class="number">10</span> );  </div><div class="line">          </div><div class="line">        <span class="comment">// 缓冲区中的数据0-9  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buffer.capacity(); ++i) &#123;  </div><div class="line">            buffer.put( (<span class="keyword">byte</span>)i );  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        <span class="comment">// 创建子缓冲区  </span></div><div class="line">        buffer.position( <span class="number">3</span> );  </div><div class="line">        buffer.limit( <span class="number">7</span> );  </div><div class="line">        ByteBuffer slice = buffer.slice();  </div><div class="line">          </div><div class="line">        <span class="comment">// 改变子缓冲区的内容  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;slice.capacity(); ++i) &#123;  </div><div class="line">            <span class="keyword">byte</span> b = slice.get( i );  </div><div class="line">            b *= <span class="number">10</span>;  </div><div class="line">            slice.put( i, b );  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        buffer.position( <span class="number">0</span> );  </div><div class="line">        buffer.limit( buffer.capacity() );  </div><div class="line">          </div><div class="line">        <span class="keyword">while</span> (buffer.remaining()&gt;<span class="number">0</span>) &#123;  </div><div class="line">            System.out.println( buffer.get() );  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在该示例中，分配了一个容量大小为10的缓冲区，并在其中放入了数据0-9，而在该缓冲区基础之上又创建了一个子缓冲区，并改变子缓冲区中的内容，从最后输出的结果来看，只有子缓冲区“可见的”那部分数据发生了变化，并且说明子缓冲区与原缓冲区是数据共享的，输出结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">30</div><div class="line">40</div><div class="line">50</div><div class="line">60</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td></tr></table></figure>
<h4 id="只读缓存区"><a href="#只读缓存区" class="headerlink" title="只读缓存区"></a>只读缓存区</h4><p>只读缓冲区非常简单，可以读取它们，但是不能向它们写入数据。可以通过调用缓冲区的asReadOnlyBuffer()方法，将任何常规缓冲区转 换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区，并与原缓冲区共享数据，只不过它是只读的。如果原缓冲区的内容发生了变化，只读缓冲区的内容也随之发生变化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.nio.*;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        ByteBuffer buffer = ByteBuffer.allocate( <span class="number">10</span> );  </div><div class="line">          </div><div class="line">        <span class="comment">// 缓冲区中的数据0-9  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buffer.capacity(); ++i) &#123;  </div><div class="line">            buffer.put( (<span class="keyword">byte</span>)i );  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="comment">// 创建只读缓冲区  </span></div><div class="line">        ByteBuffer readonly = buffer.asReadOnlyBuffer();  </div><div class="line">          </div><div class="line">        <span class="comment">// 改变原缓冲区的内容  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buffer.capacity(); ++i) &#123;  </div><div class="line">            <span class="keyword">byte</span> b = buffer.get( i );  </div><div class="line">            b *= <span class="number">10</span>;  </div><div class="line">            buffer.put( i, b );  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        readonly.position(<span class="number">0</span>);  </div><div class="line">        readonly.limit(buffer.capacity());  </div><div class="line">          </div><div class="line">        <span class="comment">// 只读缓冲区的内容也随之改变  </span></div><div class="line">        <span class="keyword">while</span> (readonly.remaining()&gt;<span class="number">0</span>) &#123;  </div><div class="line">            System.out.println( readonly.get());  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果尝试修改只读缓冲区的内容，则会报ReadOnlyBufferException异常。只读缓冲区对于保护数据很有用。在将缓冲区传递给某个 对象的方法时，无法知道这个方法是否会修改缓冲区中的数据。创建一个只读的缓冲区可以保证该缓冲区不会被修改。只可以把常规缓冲区转换为只读缓冲区，而不能将只读的缓冲区转换为可写的缓冲区。</p>
<h4 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h4><p>直接缓冲区是为加快I/O速度，使用一种特殊方式为其分配内存的缓冲区，JDK文档中的描述为：给定一个直接字节缓冲区，Java虚拟机将尽最大努 力直接对它执行本机I/O操作。也就是说，它会在每一次调用底层操作系统的本机I/O操作之前(或之后)，尝试避免将缓冲区的内容拷贝到一个中间缓冲区中 或者从一个中间缓冲区中拷贝数据。要分配直接缓冲区，需要调用allocateDirect()方法，而不是allocate()方法，使用方式与普通缓冲区并无区别，如下面的拷贝文件示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.*;  </div><div class="line"><span class="keyword">import</span> java.nio.*;  </div><div class="line"><span class="keyword">import</span> java.nio.channels.*;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        String infile = <span class="string">"c:\\test.txt"</span>;  </div><div class="line">        FileInputStream fin = <span class="keyword">new</span> FileInputStream( infile );  </div><div class="line">        FileChannel fcin = fin.getChannel();  </div><div class="line">          </div><div class="line">        String outfile = String.format(<span class="string">"c:\\testcopy.txt"</span>);  </div><div class="line">        FileOutputStream fout = <span class="keyword">new</span> FileOutputStream( outfile );      </div><div class="line">        FileChannel fcout = fout.getChannel();  </div><div class="line">          </div><div class="line">        <span class="comment">// 使用allocateDirect，而不是allocate  </span></div><div class="line">        ByteBuffer buffer = ByteBuffer.allocateDirect( <span class="number">1024</span> );  </div><div class="line">          </div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </div><div class="line">            buffer.clear();  </div><div class="line">              </div><div class="line">            <span class="keyword">int</span> r = fcin.read( buffer );  </div><div class="line">              </div><div class="line">            <span class="keyword">if</span> (r==-<span class="number">1</span>) &#123;  </div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">            &#125;  </div><div class="line">              </div><div class="line">            buffer.flip();  </div><div class="line">              </div><div class="line">            fcout.write( buffer );  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内存映射文件I/O</p>
<p>内存映射文件I/O是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的I/O快的多。内存映射文件I/O是通过使文件中的数据出现为 内存数组的内容来完成的，这其中听起来似乎不过就是将整个文件读到内存中，但是事实上并不是这样。一般来说，只有文件中实际读取或者写入的部分才会映射到内存中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中介绍了缓冲区内部对于状态变化的跟踪机制，而对于NIO中缓冲区来说，还有很多的内容值的学习，如缓冲区的分片与数据共享，只读缓冲区等。在本文中我们来看一下缓冲区一些更细节的内容。&lt;/p&gt;
&lt;h4 id=&quot;缓冲区的分配&quot;&gt;&lt;a href=&quot;#缓冲区的分配&quot; clas
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍16-nio2</title>
    <link href="http://yoursite.com/2017/02/27/15-javanio2/"/>
    <id>http://yoursite.com/2017/02/27/15-javanio2/</id>
    <published>2017-02-27T12:52:12.000Z</published>
    <updated>2017-02-27T08:44:34.886Z</updated>
    
    <content type="html"><![CDATA[<p>在第一篇中，我们介绍了NIO中的两个核心对象：缓冲区和通道，在谈到缓冲区时，我们说缓冲区对象本质上是一个数组，但它其实是一个特殊的数组，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况，如果我们使用get()方法从缓冲区获取数据或者使用put()方法把数据写入缓冲区，都会引起缓冲区状态的变化。本文为NIO使用及原理分析的第二篇，将会分析NIO中的Buffer对象。</p>
<p>在缓冲区中，最重要的属性有下面三个，它们一起合作完成对缓冲区内部状态的变化跟踪：</p>
<ul>
<li>position：指定了下一个将要被写入或者读取的元素索引，它的值由get()/put()方法自动更新，在新创建一个Buffer对象时，position被初始化为0。</li>
<li>limit：指定还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。</li>
<li>capacity：指定了可以存储在缓冲区中的最大数据容量，实际上，它指定了底层数组的大小，或者至少是指定了准许我们使用的底层数组的容量。<br>以上四个属性值之间有一些相对大小的关系：0 &lt;= position &lt;= limit &lt;= capacity。如果我们创建一个新的容量大小为10的ByteBuffer对象，在初始化的时候，position设置为0，limit和 capacity被设置为10，在以后使用ByteBuffer对象过程中，capacity的值不会再发生变化，而其它两个个将会随着使用而变化。</li>
</ul>
<h4 id="变化过程"><a href="#变化过程" class="headerlink" title="变化过程"></a>变化过程</h4><p>以上四个属性值之间有一些相对大小的关系：0 &lt;= position &lt;= limit &lt;= capacity。如果我们创建一个新的容量大小为10的ByteBuffer对象，在初始化的时候，position设置为0，limit和 capacity被设置为10，在以后使用ByteBuffer对象过程中，capacity的值不会再发生变化，而其它两个个将会随着使用而变化、</p>
<p>现在我们可以从通道中读取一些数据到缓冲区中，注意从通道读取数据，相当于往缓冲区中写入数据。如果读取4个自己的数据，则此时position的值为4，即下一个将要被写入的字节索引为4，而limit仍然是10</p>
<p>下一步把读取的数据写入到输出通道中，相当于从缓冲区中读取数据，在此之前，必须调用flip()方法，该方法将会完成两件事情：</p>
<ol>
<li>把limit设置为当前的position值 </li>
<li>把position设置为0</li>
</ol>
<p>由于position被设置为0，所以可以保证在下一步输出时读取到的是缓冲区中的第一个字节，而limit被设置为当前的position，可以保证读取的数据正好是之前写入到缓冲区中的数据，</p>
<p>现在调用get()方法从缓冲区中读取数据写入到输出通道，这会导致position的增加而limit保持不变，但position不会超过limit的值，所以在读取我们之前写入到缓冲区中的4个自己之后，position和limit的值都为4</p>
<p>在从缓冲区中读取数据完毕后，limit的值仍然保持在我们调用flip()方法时的值，调用clear()方法能够把所有的状态变化设置为初始化时的值。</p>
<p>实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> nio;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</div><div class="line"><span class="keyword">import</span> java.nio.Buffer;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">niotest2</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(String step, Buffer buffer)</span> </span>&#123;  </div><div class="line">        System.out.println(step + <span class="string">" : "</span>);  </div><div class="line">        System.out.print(<span class="string">"capacity: "</span> + buffer.capacity() + <span class="string">", "</span>);  </div><div class="line">        System.out.print(<span class="string">"position: "</span> + buffer.position() + <span class="string">", "</span>);  </div><div class="line">        System.out.println(<span class="string">"limit: "</span> + buffer.limit());  </div><div class="line">        System.out.println();  </div><div class="line">    &#125;  </div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		FileInputStream fin=<span class="keyword">new</span> FileInputStream(<span class="string">"e:\\test.txt"</span> );</div><div class="line">		FileChannel fc=fin.getChannel();</div><div class="line">		</div><div class="line">		ByteBuffer buffer= ByteBuffer.allocate(<span class="number">10</span>);</div><div class="line">		output(<span class="string">"初始化"</span>, buffer);</div><div class="line">		</div><div class="line">		fc.read(buffer);  </div><div class="line">        output(<span class="string">"调用read()"</span>, buffer);</div><div class="line">        </div><div class="line">        buffer.flip();  </div><div class="line">        output(<span class="string">"调用flip()"</span>, buffer);  </div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (buffer.remaining() &gt; <span class="number">0</span>) &#123;  </div><div class="line">            <span class="keyword">byte</span> b = buffer.get();  </div><div class="line">            <span class="comment">// System.out.print(((char)b));  </span></div><div class="line">        &#125;  </div><div class="line">        output(<span class="string">"调用get()"</span>, buffer); </div><div class="line">        </div><div class="line">        buffer.clear();  </div><div class="line">        output(<span class="string">"调用clear()"</span>, buffer);  </div><div class="line">  </div><div class="line">        fin.close();  </div><div class="line">		</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>result:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">初始化 : </div><div class="line">capacity: <span class="number">10</span>, position: <span class="number">0</span>, limit: <span class="number">10</span></div><div class="line"></div><div class="line">调用read() : </div><div class="line">capacity: <span class="number">10</span>, position: <span class="number">10</span>, limit: <span class="number">10</span></div><div class="line"></div><div class="line">调用flip() : </div><div class="line">capacity: <span class="number">10</span>, position: <span class="number">0</span>, limit: <span class="number">10</span></div><div class="line"></div><div class="line">调用get() : </div><div class="line">capacity: <span class="number">10</span>, position: <span class="number">10</span>, limit: <span class="number">10</span></div><div class="line"></div><div class="line">调用clear() : </div><div class="line">capacity: <span class="number">10</span>, position: <span class="number">0</span>, limit: <span class="number">10</span></div></pre></td></tr></table></figure>
<p>转载：<a href="http://blog.csdn.net/wuxianglong/article/details/6612246" target="_blank" rel="external">http://blog.csdn.net/wuxianglong/article/details/6612246</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在第一篇中，我们介绍了NIO中的两个核心对象：缓冲区和通道，在谈到缓冲区时，我们说缓冲区对象本质上是一个数组，但它其实是一个特殊的数组，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况，如果我们使用get()方法从缓冲区获取数据或者使用put()方法把数据写入缓
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍15-nio4</title>
    <link href="http://yoursite.com/2017/02/27/15-javanio4/"/>
    <id>http://yoursite.com/2017/02/27/15-javanio4/</id>
    <published>2017-02-27T12:52:12.000Z</published>
    <updated>2017-02-27T10:29:25.281Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中介绍了关于缓冲区的一些细节内容，现在终于可以进入NIO中最有意思的部分非阻塞I/O。通常在进行同步I/O操作时，如果读取数据，代码会阻塞直至有 可供读取的数据。同样，写入调用将会阻塞直至数据能够写入。传统的Server/Client模式会基于TPR（Thread per Request）,服务器会为每个客户端请求建立一个线程，由该线程单独负责处理一个客户请求。这种模式带来的一个问题就是线程数量的剧增，大量的线程会增大服务器的开销。大多数的实现为了避免这个问题，都采用了线程池模型，并设置线程池线程的最大数量，这由带来了新的问题，如果线程池中有200个线程，而有200个用户都在进行大文件下载，会导致第201个用户的请求无法及时处理，即便第201个用户只想请求一个几KB大小的页面</p>
<p>NIO中非阻塞I/O采用了基于Reactor模式的工作方式，I/O调用不会被阻塞，相反是注册感兴趣的特定I/O事件，如可读数据到达，新的套接字连接等等，在发生特定事件时，系统再通知我们。NIO中实现非阻塞I/O的核心对象就是Selector，Selector就是注册各种I/O事件地 方，而且当那些事件发生时，就是这个对象告诉我们所发生的事件。</p>
<p>当有读或写等任何注册的事件发生时，可以从Selector中获得相应的SelectionKey，同时从 SelectionKey中可以找到发生的事件和该事件所发生的具体的SelectableChannel，以获得客户端发送过来的数据。关于 SelectableChannel的可以参考Java NIO使用及原理分析（一）<br>使用NIO中非阻塞I/O编写服务器处理程序，大体上可以分为下面三个步骤：</p>
<ol>
<li>向Selector对象注册感兴趣的事件 </li>
<li>从Selector中获取感兴趣的事件 </li>
<li>根据不同的事件进行相应的处理</li>
</ol>
<p>接下来我们用一个简单的示例来说明整个过程。首先是向Selector对象注册感兴趣的事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 注册事件 </div><div class="line"> * */  </div><div class="line"><span class="function"><span class="keyword">protected</span> Selector <span class="title">getSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </div><div class="line">    <span class="comment">// 创建Selector对象  </span></div><div class="line">    Selector sel = Selector.open();  </div><div class="line">      </div><div class="line">    <span class="comment">// 创建可选择通道，并配置为非阻塞模式  </span></div><div class="line">    ServerSocketChannel server = ServerSocketChannel.open();  </div><div class="line">    server.configureBlocking(<span class="keyword">false</span>);  </div><div class="line">      </div><div class="line">    <span class="comment">// 绑定通道到指定端口  </span></div><div class="line">    ServerSocket socket = server.socket();  </div><div class="line">    InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(port);  </div><div class="line">    socket.bind(address);  </div><div class="line">      </div><div class="line">    <span class="comment">// 向Selector中注册感兴趣的事件  </span></div><div class="line">    server.register(sel, SelectionKey.OP_ACCEPT);   </div><div class="line">    <span class="keyword">return</span> sel;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建了ServerSocketChannel对象，并调用configureBlocking()方法，配置为非阻塞模式，接下来的三行代码把该通道绑定到指定端口，最后向Selector中注册事件，此处指定的是参数是OP_ACCEPT，即指定我们想要监听accept事件，也就是新的连接发 生时所产生的事件，对于ServerSocketChannel通道来说，我们唯一可以指定的参数就是OP_ACCEPT。<br>从Selector中获取感兴趣的事件，即开始监听，进入内部循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 开始监听 </div><div class="line"> * */   </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;   </div><div class="line">    System.out.println(<span class="string">"listen on "</span> + port);  </div><div class="line">    <span class="keyword">try</span> &#123;   </div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;   </div><div class="line">            <span class="comment">// 该调用会阻塞，直到至少有一个事件发生  </span></div><div class="line">            selector.select();   </div><div class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();  </div><div class="line">            Iterator&lt;SelectionKey&gt; iter = keys.iterator();  </div><div class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;   </div><div class="line">                SelectionKey key = (SelectionKey) iter.next();   </div><div class="line">                iter.remove();   </div><div class="line">                process(key);   </div><div class="line">            &#125;   </div><div class="line">        &#125;   </div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;   </div><div class="line">        e.printStackTrace();  </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在非阻塞I/O中，内部循环模式基本都是遵循这种方式。首先调用select()方法，该方法会阻塞，直到至少有一个事件发生，然后再使用selectedKeys()方法获取发生事件的SelectionKey，再使用迭代器进行循环。<br>最后一步就是根据不同的事件，编写相应的处理代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> * 根据不同的事件做处理 </div><div class="line"> * */  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>&#123;  </div><div class="line">    <span class="comment">// 接收请求  </span></div><div class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;  </div><div class="line">        ServerSocketChannel server = (ServerSocketChannel) key.channel();  </div><div class="line">        SocketChannel channel = server.accept();  </div><div class="line">        channel.configureBlocking(<span class="keyword">false</span>);  </div><div class="line">        channel.register(selector, SelectionKey.OP_READ);  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 读信息  </span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;  </div><div class="line">        SocketChannel channel = (SocketChannel) key.channel();   </div><div class="line">        <span class="keyword">int</span> count = channel.read(buffer);   </div><div class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;   </div><div class="line">            buffer.flip();   </div><div class="line">            CharBuffer charBuffer = decoder.decode(buffer);   </div><div class="line">            name = charBuffer.toString();   </div><div class="line">            SelectionKey sKey = channel.register(selector, SelectionKey.OP_WRITE);   </div><div class="line">            sKey.attach(name);   </div><div class="line">        &#125; <span class="keyword">else</span> &#123;   </div><div class="line">            channel.close();   </div><div class="line">        &#125;   </div><div class="line">        buffer.clear();   </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 写事件  </span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;  </div><div class="line">        SocketChannel channel = (SocketChannel) key.channel();   </div><div class="line">        String name = (String) key.attachment();   </div><div class="line">          </div><div class="line">        ByteBuffer block = encoder.encode(CharBuffer.wrap(<span class="string">"Hello "</span> + name));   </div><div class="line">        <span class="keyword">if</span>(block != <span class="keyword">null</span>)  </div><div class="line">        &#123;  </div><div class="line">            channel.write(block);  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span>  </div><div class="line">        &#123;  </div><div class="line">            channel.close();  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">     &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>zhuanzai:<a href="http://blog.csdn.net/wuxianglong/article/details/6612282" target="_blank" rel="external">http://blog.csdn.net/wuxianglong/article/details/6612282</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中介绍了关于缓冲区的一些细节内容，现在终于可以进入NIO中最有意思的部分非阻塞I/O。通常在进行同步I/O操作时，如果读取数据，代码会阻塞直至有 可供读取的数据。同样，写入调用将会阻塞直至数据能够写入。传统的Server/Client模式会基于TPR（Threa
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍15-nio 总结</title>
    <link href="http://yoursite.com/2017/02/27/15-javanio5/"/>
    <id>http://yoursite.com/2017/02/27/15-javanio5/</id>
    <published>2017-02-27T12:52:12.000Z</published>
    <updated>2017-02-27T10:29:49.608Z</updated>
    
    <content type="html"><![CDATA[<p>Java NIO 由以下几个核心部分组成：</p>
<ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>
<p>下面是JAVA NIO中的一些主要Channel的实现：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>正如你所看到的，这些通道涵盖了UDP 和 TCP 网络IO，以及文件IO。</p>
<p>以下是Java NIO里关键的Buffer实现：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如，在一个聊天服务器中。</p>
<p>要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。</p>
<p>总结：</p>
<p>为什么使用nio？</p>
<p>NIO 的创建目的是为了让 Java 程序员可以实现高速 I/O 而无需编写自定义的本机代码。NIO 将最耗时的 I/O 操作(即填充和提取缓冲区)转移回操作系统，因而可以极大地提高速度。</p>
<p>文件读写实例:</p>
<p><a href="http://blog.csdn.net/chenleixing/article/details/44207469" target="_blank" rel="external">http://blog.csdn.net/chenleixing/article/details/44207469</a></p>
<p>nio和io比较分析：</p>
<p>NIO 设计背后的基石：反应器模式，用于事件多路分离和分派的体系结构模式。 </p>
<p>反应器（Reactor）：用于事件多路分离和分派的体系结构模式 </p>
<p>通常的，对一个文件描述符指定的文件或设备, 有两种工作方式: 阻塞 与非阻塞 。所谓阻塞方式的意思是指, 当试图对该文件描述符进行读写时, 如果当时没有东西可读,或者暂时不可写, 程序就进入等待 状态, 直到有东西可读或者可写为止。而对于非阻塞状态, 如果没有东西可读, 或者不可写, 读写函数马上返回, 而不会等待 。 </p>
<p>一种常用做法是：每建立一个Socket连接时，同时创建一个新线程对该Socket进行单独通信（采用阻塞的方式通信）。这种方式具有很高的响应速度，并且控制起来也很简单，在连接数较少的时候非常有效，但是如果对每一个连接都产生一个线程的无疑是对系统资源的一种浪费，如果连接数较多将会出现资源不足的情况。 </p>
<p>另一种较高效的做法是：服务器端保存一个Socket连接列表，然后对这个列表进行轮询，如果发现某个Socket端口上有数据可读时（读就绪），则调用该socket连接的相应读操作；如果发现某个 Socket端口上有数据可写时（写就绪），则调用该socket连接的相应写操作；如果某个端口的Socket连接已经中断，则调用相应的析构方法关闭该端口。这样能充分利用服务器资源，效率得到了很大提高。 </p>
<p>转自：<a href="http://javag.javaeye.com/blog/221641" target="_blank" rel="external">http://javag.javaeye.com/blog/221641</a> </p>
<p>传统的阻塞式IO，每个连接必须要开一个线程来处理，并且没处理完线程不能退出。 </p>
<p>非阻塞式IO，由于基于反应器模式，用于事件多路分离和分派的体系结构模式，所以可以利用线程池来处理。事件来了就处理，处理完了就把线程归还。而传统阻塞方式不能使用线程池来处理，假设当前有10000个连接，非阻塞方式可能用1000个线程的线程池就搞定了，而传统阻塞方式就需要开10000个来处理。如果连接数较多将会出现资源不足的情况。非阻塞的核心优势就在这里。 </p>
<p>为什么会这样，下面就对他们做进一步细致具体的分析： </p>
<p>首先，我们来分析传统阻塞式IO的瓶颈在哪里。在连接数不多的情况下，传统IO编写容易方便使用。但是随着连接数的增多，问题传统IO就不行了。因为前面说过，传统IO处理每个连接都要消耗一个线程，而程序的效率当线程数不多时是随着线程数的增加而增加，但是到一定的数量之后，是随着线程数的增加而减少。这里我们得出结论，传统阻塞式IO的瓶颈在于不能处理过多的连接。 </p>
<p>然后，非阻塞式IO的出现的目的就是为了解决这个瓶颈。而非阻塞式IO是怎么实现的呢？非阻塞IO处理连接的线程数和连接数没有联系，也就是说处理 10000个连接非阻塞IO不需要10000个线程，你可以用1000个也可以用2000个线程来处理。因为非阻塞IO处理连接是异步的。当某个连接发送请求到服务器，服务器把这个连接请求当作一个请求”事件”，并把这个”事件”分配给相应的函数处理。我们可以把这个处理函数放到线程中去执行，执行完就把线程归还。这样一个线程就可以异步的处理多个事件。而阻塞式IO的线程的大部分时间都浪费在等待请求上了。 </p>
<p>所谓阻塞式IO流，就是指在从数据流当中读写数据的的时候，阻塞当前线程，直到IO流可以<br>重新使用为止，你也可以使用流的avaliableBytes()函数看看当前流当中有多少字节可以读取，这样<br>就不会再阻塞了。 </p>
<p>实例连接：<br><a href="http://blog.csdn.net/zmx729618/article/details/51859456" target="_blank" rel="external">http://blog.csdn.net/zmx729618/article/details/51859456</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java NIO 由以下几个核心部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Channels&lt;/li&gt;
&lt;li&gt;Buffers&lt;/li&gt;
&lt;li&gt;Selectors&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是JAVA NIO中的一些主要Channel的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;F
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍2-arraylist</title>
    <link href="http://yoursite.com/2017/02/25/2-ArrayList/"/>
    <id>http://yoursite.com/2017/02/25/2-ArrayList/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T06:24:03.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p><em>ArrayList</em>实现了<em>List</em>接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过<strong>数组实现</strong>。除该类未实现同步外，其余跟<em>Vector</em>大致相同。每个<em>ArrayList</em>都有一个容量（capacity），表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。</p>
<p><img src="../PNGFigures/ArrayList_base.png" alt="ArrayList_base"></p>
<p>size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。</p>
<p>为追求效率，ArrayList没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。</p>
<h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h2><p>既然底层是一个数组<em>ArrayList</em>的<code>set()</code>方法也就变得非常简单，直接对数组的指定位置赋值即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    rangeCheck(index);<span class="comment">//下标越界检查</span></div><div class="line">    E oldValue = elementData(index);</div><div class="line">    elementData[index] = element;<span class="comment">//赋值到指定位置，复制的仅仅是引用</span></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p><code>get()</code>方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line">    <span class="keyword">return</span> (E) elementData[index];<span class="comment">//注意类型转换</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h2><p>跟C++ 的<em>vector</em>不同，<em>ArrayList</em>没有<code>push_back()</code>方法，对应的方法是<code>add(E e)</code>，<em>ArrayList</em>也没有<code>insert()</code>方法，对应的方法是<code>add(int index, E e)</code>。这两个方法都是向容器中添加新元素，这可能会导致<em>capacity</em>不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过<code>grow()</code>方法完成的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//原来的1.5倍</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);<span class="comment">//扩展空间并复制</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于Java GC自动管理了内存，这里也就不需要考虑源数组释放的问题。</p>
<p><img src="../PNGFigures/ArrayList_grow.png" alt="ArrayList_grow"></p>
<p>空间的问题解决后，插入过程就显得非常简单。</p>
<p><img src="../PNGFigures/ArrayList_add.png" alt="ArrayList_add"></p>
<p><code>add(int index, E e)</code>需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。</p>
<h2 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h2><p><code>addAll()</code>方法能够一次添加多个元素，根据位置不同也有两个把本，一个是在末尾添加的<code>addAll(Collection&lt;? extends E&gt; c)</code>方法，一个是从指定位置开始插入的<code>addAll(int index, Collection&lt;? extends E&gt; c)</code>方法。跟<code>add()</code>方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。<br><code>addAll()</code>的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。</p>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><p><code>remove()</code>方法也有两个版本，一个是<code>remove(int index)</code>删除指定位置的元素，另一个是<code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素。删除操作是<code>add()</code>操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋<code>null</code>值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line">    modCount++;</div><div class="line">    E oldValue = elementData(index);</div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">//清除该位置的引用，让GC起作用</span></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于Java GC这里需要特别说明一下，<strong>有了垃圾收集器并不意味着一定不会有内存泄漏</strong>。对象能否被GC的依据是是否还有引用指向它，上面代码中如果不手动赋<code>null</code>值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot; title=&quot;ArrayList&quot;&gt;&lt;/a&gt;ArrayList&lt;/h1&gt;&lt;h1 id=&quot;总体介绍&quot;&gt;&lt;a href=&quot;#总体介绍&quot; class=&quot;headerli
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>java14-io</title>
    <link href="http://yoursite.com/2017/02/25/14-javaio/"/>
    <id>http://yoursite.com/2017/02/25/14-javaio/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-27T03:19:47.479Z</updated>
    
    <content type="html"><![CDATA[<h4 id="io-版本"><a href="#io-版本" class="headerlink" title="io 版本"></a>io 版本</h4><p>Java库的IO分为输入/输出两部分。</p>
<p>早期的Java 1.0版本的输入系统是InputStream及其子类，输出系统是OutputStream及其子类。</p>
<p>后来的Java 1.1版本对IO系统进行了重新设计。输入系统是Reader及其子类，输出系统是Writer及其子类。</p>
<p>Java1.1之所以要重新设计，主要是为了添加国际化支持(即添加了对16位Unicode码的支持)。具体表现为Java 1.0的IO系统是字节流，而Java 1.1的IO系统是字符流。</p>
<p>字节流，就是数据流中最小的数据单元是8位的字节。</p>
<p>字符流，就是数据流中最小的数据单元是16位的字符。</p>
<p>字节流在操作的时候，不会用到缓冲；而字符流会用到缓冲。所以，字符流的效率会更高一些。</p>
<p>至于为什么用到缓冲会效率更高一些呢？那是因为，缓冲本质上是一段内存区域；而文件大多是存储在硬盘或者Nand Flash上面。读写内存的速度比读写硬盘或Nand Flash上文件的速度快很多！</p>
<p>目前，文件大多以字节的方式存储的。所以在开发中，字节流使用较为广泛。</p>
<p><img src="http://i.imgur.com/o7l2qSW.jpg" alt=""></p>
<h4 id="字节流-io"><a href="#字节流-io" class="headerlink" title="字节流 io"></a>字节流 io</h4><p>InputStream是字节输入流的所有类的超类，它主要包括以下几个常用的子类。</p>
<p>(01)ByteArrayInputStream</p>
<p>将Byte数组作为字节数组输入流使用。</p>
<p>(02)StringBufferInputStream</p>
<p>将字符串作为字符串输入流使用。已过时，不建议使用。</p>
<p>(03)FileInputStream</p>
<p>将文件或FileDescriptor作为文件输入流使用。创建该输入流时，传递的参数可以是“文件名”(String类型)、“File对象”或“FileDescriptor对象”(即可以是标准输入流、输出流、错误流的句柄)。</p>
<p>(04)PipedInputString</p>
<p>提供要写入管道输出流的所有数据字节。创建该输入流的时候，可以指定对应的管道输出轮流；这样做的话，意味着将对应的管道输入流连接到了管道输出流。</p>
<p>(05)FilterInputStream</p>
<p>它直接继承与InputStream，主要用于实现Decorator模式(这在后面进行说明)。</p>
<p>FilterInputStream主要有两个派生类“DataInputStream”和“BufferedInputStream”。DataInputStream提供了读取byte、char、int等基本类型和String的各种接口；BufferedInputStream提供了缓冲功能。</p>
<p>构造方法:</p>
<ul>
<li>InputStream() 创建一个输入的stream流<br>方法：</li>
<li>available():返回stream中的可读字节数，inputstream类中的这个方法始终返回的是0，这个方法需要子类去实现。</li>
<li>close():关闭stream方法，这个是每次在用完流之后必须调用的方法。</li>
<li>read():方法是读取一个byte字节,但是返回的是int。</li>
<li>read(byte[]):一次性读取内容到缓冲字节数组</li>
<li>read(byte[],int,int):从数据流中的哪个位置offset开始读长度为len的内容到缓冲字节数组</li>
<li>skip(long):从stream中跳过long类型参数个位置</li>
</ul>
<p>以上的方法都是很简单理解的，这里就不写代码介绍了。<br>下面还有三个方法：</p>
<ul>
<li>mark(int):用于标记stream的作用</li>
<li>markSupported()：返回的是boolean类型，因为不是所有的stream都可以调用mark方法的，这个方法就是用来判断stream是否可以调用mark方法和reset方法</li>
<li>reset()：这个方法和mark方法一起使用的，让stream回到mark的位置。</li>
</ul>
<p>OutputStream是字节输出流的所有类的超类，它主要包括以下几个常用的子类。</p>
<p>基类OutputStream<br>constructor—</p>
<ul>
<li>OutputStream()</li>
</ul>
<p>method—</p>
<ul>
<li>write(int):写入一个字节到stream中</li>
<li>write(byte[])写入一个byte数组到stream中</li>
<li>write(byte[],int,int)：把byte数组中从offset开始处写入长度为len的数据</li>
<li>close()：关闭流，这个是在操作完stream之后必须要调用的方法</li>
<li>flush():这个方法是用来刷新stream中的数据，让缓冲区中的数据强制的输出</li>
</ul>
<p>(01)ByteArrayOutputStream</p>
<p>字节数组输出流，其中的数据被写入一个 byte 数组。缓冲区会随着数据的不断写入而自动增长。可使用 toByteArray() 和 toString() 获取数据。</p>
<p>(02)FileOutputStream</p>
<p>文件输出流是用于将数据写入 File 或 FileDescriptor 的输出流。</p>
<p>  文件是否可用或能否可以被创建取决于基础平台。特别是某些平台一次只允许一个 FileOutputStream（或其他文件写入对象）打开文件进行写入。在这种情况下，如果所涉及的文件已经打开，则此类中的构造方法将失败。</p>
<p>(03)PipedOutputString</p>
<p>可以将管道输出流连接到管道输入流来创建通信管道。管道输出流是管道的发送端。通常，数据由某个线程写入 PipedOutputStream 对象，并由其他线程从连接的 PipedInputStream读取。</p>
<p>  不建议对这两个对象尝试使用单个线程，因为这样可能会造成该线程死锁。如果某个线程正从连接的管道输入流中读取数据字节，但该线程不再处于活动状态，则该管道被视为处于 毁坏 状态。</p>
<p>(04)FilterOutputStream</p>
<p>它直接继承与OutputStream，主要用于实现Decorator模式(这在后面进行说明)。</p>
<p>FilterOutputStream主要有两个派生类“DataOutputStream”和“BufferedOutputStream”。DataOutputStream提供了写入byte、char、int等基本类型和String的各种接口；BufferedOutputStream提供了缓冲功能。</p>
<h4 id="decorator模式"><a href="#decorator模式" class="headerlink" title="decorator模式"></a>decorator模式</h4><p>Decorator，装饰模式，又称为Wrapper。它的主要功能在于动态扩展一个类的功能。</p>
<p>JavaIO系统包括“文件流”、“字符串流”、“字节流”、“缓冲流”等。假如，我们同时需要多种数据流的功能，如输入流和缓冲流。若采用继承的方式，数量太可观了。为了解决这一问题，Decorator模式实现了动态扩展，即在运行的时候动态的给一个类“装饰”上某些功能。比如：</p>
<p>InputStream input = newBufferedInputStream(new FileInputStream(“test.txt”));</p>
<p>这就是将FileInputStream装饰成了BufferedInputStream，使它具有了缓冲功能。</p>
<p>参考：<a href="http://blog.csdn.net/jiangwei0910410003/article/details/22376895" target="_blank" rel="external">http://blog.csdn.net/jiangwei0910410003/article/details/22376895</a></p>
<p><a href="http://blog.csdn.net/hijiankang/article/details/51027565" target="_blank" rel="external">http://blog.csdn.net/hijiankang/article/details/51027565</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;io-版本&quot;&gt;&lt;a href=&quot;#io-版本&quot; class=&quot;headerlink&quot; title=&quot;io 版本&quot;&gt;&lt;/a&gt;io 版本&lt;/h4&gt;&lt;p&gt;Java库的IO分为输入/输出两部分。&lt;/p&gt;
&lt;p&gt;早期的Java 1.0版本的输入系统是InputStream及
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍0</title>
    <link href="http://yoursite.com/2017/02/25/0-Introduction/"/>
    <id>http://yoursite.com/2017/02/25/0-Introduction/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T06:28:11.977Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="http://www.cnblogs.com/CarpenterLee/" target="_blank" rel="external">http://www.cnblogs.com/CarpenterLee/</a></p>
<h1 id="Java-Collections-Framework-Internals"><a href="#Java-Collections-Framework-Internals" class="headerlink" title="Java Collections Framework Internals"></a>Java Collections Framework Internals</h1><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>关于<em>C++标准模板库(Standard Template Library, STL)</em>的书籍和资料有很多，关于<em>Java集合框架(Java Collections Framework, JCF)</em>的资料却很少，甚至很难找到一本专门介绍它的书籍，这给Java学习者们带来不小的麻烦。我深深的不解其中的原因。<strong>虽然JCF设计参考了STL，但其定位不是Java版的STL，而是要实现一个精简紧凑的容器框架</strong>，对STL的介绍自然不能替代对JCF的介绍。</p>
<p>本系列文章主要从<strong>数据结构和算法</strong>层面分析JCF中List, Set, Map, Stack, Queue等典型容器，<strong>结合生动图解和源代码，帮助读者对Java集合框架建立清晰而深入的理解</strong>。本文并不特意介绍Java的语言特性，但会在需要的时候做出简洁的解释。</p>
<h1 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h1><p>具体内容安排如下：</p>
<ol>
<li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/1-Overview.md" target="_blank" rel="external">Overview</a> 对Java Collections Framework，以及Java语言特性做出基本介绍。</li>
<li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md" target="_blank" rel="external">ArrayList</a> 结合源码对<em>ArrayList</em>进行讲解。</li>
<li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/3-LinkedList.md" target="_blank" rel="external">LinkedList</a> 结合源码对<em>LinkedList</em>进行讲解。</li>
<li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/4-Stack%20and%20Queue.md" target="_blank" rel="external">Stack and Queue</a> 以<em>AarryDeque</em>为例讲解<em>Stack</em>和<em>Queue</em>。</li>
<li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/5-TreeSet%20and%20TreeMap.md" target="_blank" rel="external">TreeSet and TreeMap</a> 结合源码对<em>TreeSet</em>和<em>TreeMap</em>进行讲解。</li>
<li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md" target="_blank" rel="external">HashSet and HashMap</a> 结合源码对<em>HashSet</em>和<em>HashMap</em>进行讲解。</li>
<li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/7-LinkedHashSet%20and%20LinkedHashMap.md" target="_blank" rel="external">LinkedHashSet and LinkedHashMap</a> 结合源码对<em>LinkedHashSet</em>和<em>LinkedHashMap</em>进行讲解。</li>
<li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md" target="_blank" rel="external">PriorityQueue</a> 结合源码对<em>PriorityQueue</em>进行讲解。</li>
<li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/9-WeakHashMap.md" target="_blank" rel="external">WeakHashMap</a> 对<em>WeakHashMap</em>做出基本介绍。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;http://www.cnblogs.com/CarpenterLee/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/CarpenterLee/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Ja
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍13-reference</title>
    <link href="http://yoursite.com/2017/02/25/13-%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2017/02/25/13-引用/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T07:38:47.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>Java从1.2版本开始引入了4种引用，这4种引用的级别由高到低依次为：</p>
<p>   强引用  &gt;  软引用  &gt;  弱引用  &gt;  虚引用</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>⑴强引用（StrongReference）</p>
<pre><code>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。
</code></pre><p>⑵软引用（SoftReference）</p>
<pre><code>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。
</code></pre><p>⑶弱引用（WeakReference）</p>
<pre><code>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。

弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。
</code></pre><p>⑷虚引用（PhantomReference）</p>
<pre><code>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。
</code></pre><p>转载：<a href="http://www.cnblogs.com/skywang12345/p/3154474.html" target="_blank" rel="external">http://www.cnblogs.com/skywang12345/p/3154474.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;reference&quot;&gt;&lt;a href=&quot;#reference&quot; class=&quot;headerlink&quot; title=&quot;reference&quot;&gt;&lt;/a&gt;reference&lt;/h1&gt;&lt;p&gt;Java从1.2版本开始引入了4种引用，这4种引用的级别由高到低依次为：&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍10-fail-fast</title>
    <link href="http://yoursite.com/2017/02/25/10-failfast/"/>
    <id>http://yoursite.com/2017/02/25/10-failfast/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T06:48:31.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h1><h4 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h4><p>fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。<br>例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p>
<p>在详细介绍fail-fast机制的原理之前，先通过一个示例来认识fail-fast。</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.*;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * @desc java集合中Fast-Fail的测试程序。</div><div class="line"> *</div><div class="line"> *   fast-fail事件产生的条件：当多个线程对Collection进行操作时，若其中某一个线程通过iterator去遍历集合时，该集合的内容被其他线程所改变；则会抛出ConcurrentModificationException异常。</div><div class="line"> *   fast-fail解决办法：通过util.concurrent集合包下的相应类去处理，则不会产生fast-fail事件。</div><div class="line"> *</div><div class="line"> *   本例中，分别测试ArrayList和CopyOnWriteArrayList这两种情况。ArrayList会产生fast-fail事件，而CopyOnWriteArrayList不会产生fast-fail事件。</div><div class="line"> *   (01) 使用ArrayList时，会产生fast-fail事件，抛出ConcurrentModificationException异常；定义如下：</div><div class="line"> *            private static List&lt;String&gt; list = new ArrayList&lt;String&gt;();</div><div class="line"> *   (02) 使用时CopyOnWriteArrayList，不会产生fast-fail事件；定义如下：</div><div class="line"> *            private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;();</div><div class="line"> *</div><div class="line"> * @author skywang</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastFailTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">    <span class="comment">//private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;();</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    </div><div class="line">        <span class="comment">// 同时启动两个线程对list进行操作！</span></div><div class="line">        <span class="keyword">new</span> ThreadOne().start();</div><div class="line">        <span class="keyword">new</span> ThreadTwo().start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">""</span>);</div><div class="line"></div><div class="line">        String value = <span class="keyword">null</span>;</div><div class="line">        Iterator iter = list.iterator();</div><div class="line">        <span class="keyword">while</span>(iter.hasNext()) &#123;</div><div class="line">            value = (String)iter.next();</div><div class="line">            System.out.print(value+<span class="string">", "</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 向list中依次添加0,1,2,3,4,5，每添加一个数之后，就通过printAll()遍历整个list</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadOne</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span> (i&lt;<span class="number">6</span>) &#123;</div><div class="line">                list.add(String.valueOf(i));</div><div class="line">                printAll();</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 向list中依次添加10,11,12,13,14,15，每添加一个数之后，就通过printAll()遍历整个list</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTwo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">10</span>;</div><div class="line">            <span class="keyword">while</span> (i&lt;<span class="number">16</span>) &#123;</div><div class="line">                list.add(String.valueOf(i));</div><div class="line">                printAll();</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>运行该代码，抛出异常java.util.ConcurrentModificationException！即，产生fail-fast事件！</p>
<p>结果说明：</p>
<ul>
<li>(01) FastFailTest中通过 new ThreadOne().start() 和 new ThreadTwo().start() 同时启动两个线程去操作list。<br>  ThreadOne线程：向list中依次添加0,1,2,3,4,5。每添加一个数之后，就通过printAll()遍历整个list。<br>  ThreadTwo线程：向list中依次添加10,11,12,13,14,15。每添加一个数之后，就通过printAll()遍历整个list。</li>
<li>(02) 当某一个线程遍历list的过程中，list的内容被另外一个线程所改变了；就会抛出ConcurrentModificationException异常，产生fail-fast事件。</li>
</ul>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>fail-fast机制，是一种错误检测机制。它只能被用来检测错误，因为JDK并不保证fail-fast机制一定会发生。若在多线程环境下使用fail-fast机制的集合，建议使用“java.util.concurrent包下的类”去取代“java.util包下的类”。<br>所以，本例中只需要将ArrayList替换成java.util.concurrent包下对应的类即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;String&gt;();</div></pre></td></tr></table></figure>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>产生fail-fast事件，是通过抛出ConcurrentModificationException异常来触发的。<br>那么，ArrayList是如何抛出ConcurrentModificationException异常的呢?</p>
<p>我们知道，ConcurrentModificationException是在操作Iterator时抛出的异常。我们先看看Iterator的源码。ArrayList的Iterator是在父类AbstractList.java中实现的。代码如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.util;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// AbstractList中唯一的属性</span></div><div class="line">    <span class="comment">// 用来记录List修改的次数：每修改一次(添加/删除等操作)，将modCount+1</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 返回List对应迭代器。实际上，是返回Itr对象。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Itr是Iterator(迭代器)的实现类</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">int</span> cursor = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 修改数的记录值。</span></div><div class="line">        <span class="comment">// 每次新建Itr()对象时，都会保存新建该对象时对应的modCount；</span></div><div class="line">        <span class="comment">// 以后每次遍历List中的元素的时候，都会比较expectedModCount和modCount是否相等；</span></div><div class="line">        <span class="comment">// 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。</span></div><div class="line">        <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> cursor != size();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// 获取下一个元素之前，都会判断“新建Itr对象时保存的modCount”和“当前的modCount”是否相等；</span></div><div class="line">            <span class="comment">// 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。</span></div><div class="line">            checkForComodification();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                E next = get(cursor);</div><div class="line">                lastRet = cursor++;</div><div class="line">                <span class="keyword">return</span> next;</div><div class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</div><div class="line">                checkForComodification();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (lastRet == -<span class="number">1</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">            checkForComodification();</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                AbstractList.<span class="keyword">this</span>.remove(lastRet);</div><div class="line">                <span class="keyword">if</span> (lastRet &lt; cursor)</div><div class="line">                    cursor--;</div><div class="line">                lastRet = -<span class="number">1</span>;</div><div class="line">                expectedModCount = modCount;</div><div class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从中，我们可以发现在调用 next() 和 remove()时，都会执行 checkForComodification()。若 “modCount 不等于 expectedModCount”，则抛出ConcurrentModificationException异常，产生fail-fast事件。</p>
<p>要搞明白 fail-fast机制，我们就要需要理解什么时候“modCount 不等于 expectedModCount”！<br>从Itr类中，我们知道 expectedModCount 在创建Itr对象时，被赋值为 modCount。通过Itr，我们知道：expectedModCount不可能被修改为不等于 modCount。所以，需要考证的就是modCount何时会被修改。</p>
<p>接下来，我们查看ArrayList的源码，来看看modCount是如何被修改的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.util;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// list中容量变化时，对应的同步函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">        <span class="keyword">if</span> (minCapacity &gt; oldCapacity) &#123;</div><div class="line">            Object oldData[] = elementData;</div><div class="line">            <span class="keyword">int</span> newCapacity = (oldCapacity * <span class="number">3</span>)/<span class="number">2</span> + <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (newCapacity &lt; minCapacity)</div><div class="line">                newCapacity = minCapacity;</div><div class="line">            <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">            elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// 添加元素到队列最后</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        <span class="comment">// 修改modCount</span></div><div class="line">        ensureCapacity(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        elementData[size++] = e;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// 添加元素到指定的位置</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(</div><div class="line">            <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size);</div><div class="line"></div><div class="line">        <span class="comment">// 修改modCount</span></div><div class="line">        ensureCapacity(size+<span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</div><div class="line">             size - index);</div><div class="line">        elementData[index] = element;</div><div class="line">        size++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 添加集合</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">        Object[] a = c.toArray();</div><div class="line">        <span class="keyword">int</span> numNew = a.length;</div><div class="line">        <span class="comment">// 修改modCount</span></div><div class="line">        ensureCapacity(size + numNew);  <span class="comment">// Increments modCount</span></div><div class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</div><div class="line">        size += numNew;</div><div class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line"></div><div class="line">    <span class="comment">// 删除指定位置的元素 </span></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        RangeCheck(index);</div><div class="line"></div><div class="line">        <span class="comment">// 修改modCount</span></div><div class="line">        modCount++;</div><div class="line">        E oldValue = (E) elementData[index];</div><div class="line"></div><div class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</div><div class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// 快速删除指定位置的元素 </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 修改modCount</span></div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                             numMoved);</div><div class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 清空集合</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 修改modCount</span></div><div class="line">        modCount++;</div><div class="line"></div><div class="line">        <span class="comment">// Let gc do its work</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">            elementData[i] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        size = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从中，我们发现：无论是add()、remove()，还是clear()，只要涉及到修改集合中的元素个数时，都会改变modCount的值。</p>
<p>接下来，我们再系统的梳理一下fail-fast是怎么产生的。步骤如下：</p>
<p>(01) 新建了一个ArrayList，名称为arrayList。<br>(02) 向arrayList中添加内容。<br>(03) 新建一个“线程a”，并在“线程a”中通过Iterator反复的读取arrayList的值。<br>(04) 新建一个“线程b”，在“线程b”中删除arrayList中的一个“节点A”。<br>(05) 这时，就会产生有趣的事件了。<br>       在某一时刻，“线程a”创建了arrayList的Iterator。此时“节点A”仍然存在于arrayList中，创建arrayList时，expectedModCount = modCount(假设它们此时的值为N)。<br>       在“线程a”在遍历arrayList过程中的某一时刻，“线程b”执行了，并且“线程b”删除了arrayList中的“节点A”。“线程b”执行remove()进行删除操作时，在remove()中执行了“modCount++”，此时modCount变成了N+1！</p>
<p>“线程a”接着遍历，当它执行到next()函数时，调用checkForComodification()比较“expectedModCount”和“modCount”的大小；而“expectedModCount=N”，“modCount=N+1”,这样，便抛出ConcurrentModificationException异常，产生fail-fast事件。</p>
<p>至此，我们就完全了解了fail-fast是如何产生的！<br>即，当多个线程对同一个集合进行操作的时候，某线程访问集合的过程中，该集合的内容被其他线程所改变(即其它线程通过add、remove、clear等方法，改变了modCount的值)；这时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p>
<h4 id="解决fail-fast失败的原理"><a href="#解决fail-fast失败的原理" class="headerlink" title="解决fail-fast失败的原理"></a>解决fail-fast失败的原理</h4><p>上面，说明了“解决fail-fast机制的办法”，也知道了“fail-fast产生的根本原因”。接下来，我们再进一步谈谈java.util.concurrent包中是如何解决fail-fast事件的。<br>还是以和ArrayList对应的CopyOnWriteArrayList进行说明。我们先看看CopyOnWriteArrayList的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.util.concurrent;</div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</div><div class="line"><span class="keyword">import</span> sun.misc.Unsafe;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// 返回集合对应的迭代器</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">   </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cursor;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</div><div class="line">            cursor = initialCursor;</div><div class="line">            <span class="comment">// 新建COWIterator时，将集合中的元素保存到一个新的拷贝数组中。</span></div><div class="line">            <span class="comment">// 这样，当原始集合的数据改变，拷贝数据中的值也不会变化。</span></div><div class="line">            snapshot = elements;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> cursor &lt; snapshot.length;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> cursor &gt; <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (! hasNext())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">            <span class="keyword">return</span> (E) snapshot[cursor++];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (! hasPrevious())</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">            <span class="keyword">return</span> (E) snapshot[--cursor];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> cursor;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> cursor-<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从中，我们可以看出:</p>
<p>(01) 和ArrayList继承于AbstractList不同，CopyOnWriteArrayList没有继承于AbstractList，它仅仅只是实现了List接口。<br>(02) ArrayList的iterator()函数返回的Iterator是在AbstractList中实现的；而CopyOnWriteArrayList是自己实现Iterator。<br>(03) ArrayList的Iterator实现类中调用next()时，会“调用checkForComodification()比较‘expectedModCount’和‘modCount’的大小”；但是，CopyOnWriteArrayList的Iterator实现类中，没有所谓的checkForComodification()，更不会抛出ConcurrentModificationException异常！ </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;fail-fast&quot;&gt;&lt;a href=&quot;#fail-fast&quot; class=&quot;headerlink&quot; title=&quot;fail-fast&quot;&gt;&lt;/a&gt;fail-fast&lt;/h1&gt;&lt;h4 id=&quot;总体介绍&quot;&gt;&lt;a href=&quot;#总体介绍&quot; class=&quot;headerli
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍3-linkedlist</title>
    <link href="http://yoursite.com/2017/02/25/3-LinkedList/"/>
    <id>http://yoursite.com/2017/02/25/3-LinkedList/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T06:24:24.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p><em>LinkedList</em>同时实现了<em>List</em>接口和<em>Deque</em>接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（<em>Queue</em>），同时又可以看作一个栈（<em>Stack</em>）。这样看来，<em>LinkedList</em>简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用<em>LinkedList</em>，一方面是因为Java官方已经声明不建议使用<em>Stack</em>类，更遗憾的是，Java里根本没有一个叫做<em>Queue</em>的类（它是个接口名字）。关于栈或队列，现在的首选是<em>ArrayDeque</em>，它有着比<em>LinkedList</em>（当作栈或队列使用时）有着更好的性能。</p>
<p><img src="../PNGFigures/LinkedList_base.png" alt="LinkedList_base"></p>
<p><em>LinkedList</em>底层<strong>通过双向链表实现</strong>，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟<em>List</em>接口相关的函数，而将<em>Queue</em>和<em>Stack</em>以及<em>Deque</em>相关的知识放在下一节讲。双向链表的每个节点用内部类<em>Node</em>表示。<em>LinkedList</em>通过<code>first</code>和<code>last</code>引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候<code>first</code>和<code>last</code>都指向<code>null</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Node内部类</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    E item;</div><div class="line">    Node&lt;E&gt; next;</div><div class="line">    Node&lt;E&gt; prev;</div><div class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</div><div class="line">        <span class="keyword">this</span>.item = element;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">        <span class="keyword">this</span>.prev = prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>LinkedList</em>的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率<em>LinkedList</em>没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用<code>Collections.synchronizedList()</code>方法对其进行包装。</p>
<h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h2><p><em>add()</em>方法有两个版本，一个是<code>add(E e)</code>，该方法在<em>LinkedList</em>的末尾插入元素，因为有<code>last</code>指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是<code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</p>
<p><img src="../PNGFigures/LinkedList_add.png" alt="LinkedList_add"></p>
<p>结合上图，可以看出<code>add(E e)</code>的逻辑非常简单。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//add(E e)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</div><div class="line">    last = newNode;</div><div class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</div><div class="line">        first = newNode;<span class="comment">//原来链表为空，这是插入的第一个元素</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        l.next = newNode;</div><div class="line">    size++;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>add(int index, E element)</code>的逻辑稍显复杂，可以分成两部，1.先根据index找到要插入的位置；2.修改引用，完成插入操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//add(int index, E element)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">	checkPositionIndex(index);<span class="comment">//index &gt;= 0 &amp;&amp; index &lt;= size;</span></div><div class="line">	<span class="keyword">if</span> (index == size)<span class="comment">//插入位置是末尾，包括列表为空的情况</span></div><div class="line">        add(element);</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">    	Node&lt;E&gt; succ = node(index);<span class="comment">//1.先根据index找到要插入的位置</span></div><div class="line">        <span class="comment">//2.修改引用，完成插入操作。</span></div><div class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</div><div class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</div><div class="line">        succ.prev = newNode;</div><div class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)<span class="comment">//插入位置为0</span></div><div class="line">            first = newNode;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            pred.next = newNode;</div><div class="line">        size++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中的<code>node(int index)</code>函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件<code>index &lt; (size &gt;&gt; 1)</code>，也即是index是靠近前端还是后端。</p>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><p><code>remove()</code>方法也有两个版本，一个是删除跟指定元素相等的第一个元素<code>remove(Object o)</code>，另一个是删除指定下标处的元素<code>remove(int index)</code>。</p>
<p><img src="../PNGFigures/LinkedList_remove.png" alt="LinkedList_remove.png"></p>
<p>两个删除操作都要1.先找到要删除元素的引用，2.修改相关引用，完成删除操作。在寻找被删元素引用的时候<code>remove(Object o)</code>调用的是元素的<code>equals</code>方法，而<code>remove(int index)</code>使用的是下标计数，两种方式都是线性时间复杂度。在步骤2中，两个<code>revome()</code>方法都是通过<code>unlink(Node&lt;E&gt; x)</code>方法完成的。这里需要考虑删除元素是第一个或者最后一个时的边界情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//unlink(Node&lt;E&gt; x)，删除一个Node</span></div><div class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> E element = x.item;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</div><div class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;<span class="comment">//删除的是第一个元素</span></div><div class="line">        first = next;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        prev.next = next;</div><div class="line">        x.prev = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;<span class="comment">//删除的是最后一个元素</span></div><div class="line">        last = prev;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        next.prev = prev;</div><div class="line">        x.next = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    x.item = <span class="keyword">null</span>;<span class="comment">//let GC work</span></div><div class="line">    size--;</div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h1><p><code>get(int index)</code>得到指定下标处元素的引用，通过调用上文中提到的<code>node(int index)</code>方法实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    checkElementIndex(index);<span class="comment">//index &gt;= 0 &amp;&amp; index &lt; size;</span></div><div class="line">    <span class="keyword">return</span> node(index).item;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h1><p><code>set(int index, E element)</code>方法将指定下标处的元素修改成指定值，也是先通过<code>node(int index)</code>找到对应下表元素的引用，然后修改<code>Node</code>中<code>item</code>的值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    checkElementIndex(index);</div><div class="line">    Node&lt;E&gt; x = node(index);</div><div class="line">    E oldVal = x.item;</div><div class="line">    x.item = element;<span class="comment">//替换新值</span></div><div class="line">    <span class="keyword">return</span> oldVal;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LinkedList&quot;&gt;&lt;a href=&quot;#LinkedList&quot; class=&quot;headerlink&quot; title=&quot;LinkedList&quot;&gt;&lt;/a&gt;LinkedList&lt;/h1&gt;&lt;h1 id=&quot;总体介绍&quot;&gt;&lt;a href=&quot;#总体介绍&quot; class=&quot;head
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍11-hashtable</title>
    <link href="http://yoursite.com/2017/02/25/11-hashtable/"/>
    <id>http://yoursite.com/2017/02/25/11-hashtable/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T07:01:27.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h1><p>转载:<a href="http://www.cnblogs.com/skywang12345/p/3310887.html" target="_blank" rel="external">http://www.cnblogs.com/skywang12345/p/3310887.html</a></p>
<h4 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h4><p>和HashMap一样，Hashtable 也是一个散列表，它存储的内容是键值对(key-value)映射。<br>Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。<br>Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。此外，Hashtable中的映射不是有序的。</p>
<p>Hashtable 的实例有两个参数影响其性能：初始容量 和 加载因子。容量 是哈希表中桶 的数量，初始容量 就是哈希表创建时的容量。注意，哈希表的状态为 open：在发生“哈希冲突”的情况下，单个桶会存储多个条目，这些条目必须按顺序搜索。加载因子 是对哈希表在其容量自动增加之前可以达到多满的一个尺度。初始容量和加载因子这两个参数只是对该实现的提示。关于何时以及是否调用 rehash 方法的具体细节则依赖于该实现。<br>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查找某个条目的时间（在大多数 Hashtable 操作中，包括 get 和 put 操作，都反映了这一点）。</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div><div class="line">573</div><div class="line">574</div><div class="line">575</div><div class="line">576</div><div class="line">577</div><div class="line">578</div><div class="line">579</div><div class="line">580</div><div class="line">581</div><div class="line">582</div><div class="line">583</div><div class="line">584</div><div class="line">585</div><div class="line">586</div><div class="line">587</div><div class="line">588</div><div class="line">589</div><div class="line">590</div><div class="line">591</div><div class="line">592</div><div class="line">593</div><div class="line">594</div><div class="line">595</div><div class="line">596</div><div class="line">597</div><div class="line">598</div><div class="line">599</div><div class="line">600</div><div class="line">601</div><div class="line">602</div><div class="line">603</div><div class="line">604</div><div class="line">605</div><div class="line">606</div><div class="line">607</div><div class="line">608</div><div class="line">609</div><div class="line">610</div><div class="line">611</div><div class="line">612</div><div class="line">613</div><div class="line">614</div><div class="line">615</div><div class="line">616</div><div class="line">617</div><div class="line">618</div><div class="line">619</div><div class="line">620</div><div class="line">621</div><div class="line">622</div><div class="line">623</div><div class="line">624</div><div class="line">625</div><div class="line">626</div><div class="line">627</div><div class="line">628</div><div class="line">629</div><div class="line">630</div><div class="line">631</div><div class="line">632</div><div class="line">633</div><div class="line">634</div><div class="line">635</div><div class="line">636</div><div class="line">637</div><div class="line">638</div><div class="line">639</div><div class="line">640</div><div class="line">641</div><div class="line">642</div><div class="line">643</div><div class="line">644</div><div class="line">645</div><div class="line">646</div><div class="line">647</div><div class="line">648</div><div class="line">649</div><div class="line">650</div><div class="line">651</div><div class="line">652</div><div class="line">653</div><div class="line">654</div><div class="line">655</div><div class="line">656</div><div class="line">657</div><div class="line">658</div><div class="line">659</div><div class="line">660</div><div class="line">661</div><div class="line">662</div><div class="line">663</div><div class="line">664</div><div class="line">665</div><div class="line">666</div><div class="line">667</div><div class="line">668</div><div class="line">669</div><div class="line">670</div><div class="line">671</div><div class="line">672</div><div class="line">673</div><div class="line">674</div><div class="line">675</div><div class="line">676</div><div class="line">677</div><div class="line">678</div><div class="line">679</div><div class="line">680</div><div class="line">681</div><div class="line">682</div><div class="line">683</div><div class="line">684</div><div class="line">685</div><div class="line">686</div><div class="line">687</div><div class="line">688</div><div class="line">689</div><div class="line">690</div><div class="line">691</div><div class="line">692</div><div class="line">693</div><div class="line">694</div><div class="line">695</div><div class="line">696</div><div class="line">697</div><div class="line">698</div><div class="line">699</div><div class="line">700</div><div class="line">701</div><div class="line">702</div><div class="line">703</div><div class="line">704</div><div class="line">705</div><div class="line">706</div><div class="line">707</div><div class="line">708</div><div class="line">709</div><div class="line">710</div><div class="line">711</div><div class="line">712</div><div class="line">713</div><div class="line">714</div><div class="line">715</div><div class="line">716</div><div class="line">717</div><div class="line">718</div><div class="line">719</div><div class="line">720</div><div class="line">721</div><div class="line">722</div><div class="line">723</div><div class="line">724</div><div class="line">725</div><div class="line">726</div><div class="line">727</div><div class="line">728</div><div class="line">729</div><div class="line">730</div><div class="line">731</div><div class="line">732</div><div class="line">733</div><div class="line">734</div><div class="line">735</div><div class="line">736</div><div class="line">737</div><div class="line">738</div><div class="line">739</div><div class="line">740</div><div class="line">741</div><div class="line">742</div><div class="line">743</div><div class="line">744</div><div class="line">745</div><div class="line">746</div><div class="line">747</div><div class="line">748</div><div class="line">749</div><div class="line">750</div><div class="line">751</div><div class="line">752</div><div class="line">753</div><div class="line">754</div><div class="line">755</div><div class="line">756</div><div class="line">757</div><div class="line">758</div><div class="line">759</div><div class="line">760</div><div class="line">761</div><div class="line">762</div><div class="line">763</div><div class="line">764</div><div class="line">765</div><div class="line">766</div><div class="line">767</div><div class="line">768</div><div class="line">769</div><div class="line">770</div><div class="line">771</div><div class="line">772</div><div class="line">773</div><div class="line">774</div><div class="line">775</div><div class="line">776</div><div class="line">777</div><div class="line">778</div><div class="line">779</div><div class="line">780</div><div class="line">781</div><div class="line">782</div><div class="line">783</div><div class="line">784</div><div class="line">785</div><div class="line">786</div><div class="line">787</div><div class="line">788</div><div class="line">789</div><div class="line">790</div><div class="line">791</div><div class="line">792</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.util;</div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</div><div class="line">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</div><div class="line"></div><div class="line">    <span class="comment">// Hashtable保存key-value的数组。</span></div><div class="line">    <span class="comment">// Hashtable是采用拉链法实现的，每一个Entry本质上是一个单向链表</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry[] table;</div><div class="line"></div><div class="line">    <span class="comment">// Hashtable中元素的实际数量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="comment">// 阈值，用于判断是否需要调整Hashtable的容量（threshold = 容量*加载因子）</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threshold;</div><div class="line"></div><div class="line">    <span class="comment">// 加载因子</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</div><div class="line"></div><div class="line">    <span class="comment">// Hashtable被改变的次数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 序列版本号</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1421746759512286392L</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</div><div class="line">                                               initialCapacity);</div><div class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load: "</span>+loadFactor);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</div><div class="line">            initialCapacity = <span class="number">1</span>;</div><div class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">        table = <span class="keyword">new</span> Entry[initialCapacity];</div><div class="line">        threshold = (<span class="keyword">int</span>)(initialCapacity * loadFactor);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 指定“容量大小”的构造函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 默认构造函数。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 默认构造函数，指定的容量大小是11；加载因子是0.75</span></div><div class="line">        <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 包含“子Map”的构造函数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</div><div class="line">        <span class="comment">// 将“子Map”的全部元素都添加到Hashtable中</span></div><div class="line">        putAll(t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 返回“所有key”的枚举对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;K&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.&lt;K&gt;getEnumeration(KEYS);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 返回“所有value”的枚举对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;V&gt; <span class="title">elements</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.&lt;V&gt;getEnumeration(VALUES);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 判断Hashtable是否包含“值(value)”</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line">        <span class="comment">// Hashtable中“键值对”的value不能是null，</span></div><div class="line">        <span class="comment">// 若是null的话，抛出异常!</span></div><div class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 从后向前遍历table数组中的元素(Entry)</span></div><div class="line">        <span class="comment">// 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value</span></div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tab.length ; i-- &gt; <span class="number">0</span> ;) &#123;</div><div class="line">            <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">                <span class="keyword">if</span> (e.value.equals(value)) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> contains(value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 判断Hashtable是否包含key</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">        <span class="comment">// 计算索引值，</span></div><div class="line">        <span class="comment">// % tab.length 的目的是防止数据越界</span></div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="comment">// 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素</span></div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 返回key对应的value，没有的话返回null</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">        <span class="comment">// 计算索引值，</span></div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="comment">// 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素</span></div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                <span class="keyword">return</span> e.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 调整Hashtable的长度，将长度变成原来的(2倍+1)</span></div><div class="line">    <span class="comment">// (01) 将“旧的Entry数组”赋值给一个临时变量。</span></div><div class="line">    <span class="comment">// (02) 创建一个“新的Entry数组”，并赋值给“旧的Entry数组”</span></div><div class="line">    <span class="comment">// (03) 将“Hashtable”中的全部元素依次添加到“新的Entry数组”中</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> oldCapacity = table.length;</div><div class="line">        Entry[] oldMap = table;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> newCapacity = oldCapacity * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line">        Entry[] newMap = <span class="keyword">new</span> Entry[newCapacity];</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</div><div class="line">        table = newMap;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</div><div class="line">            <span class="keyword">for</span> (Entry&lt;K,V&gt; old = oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</div><div class="line">                Entry&lt;K,V&gt; e = old;</div><div class="line">                old = old.next;</div><div class="line"></div><div class="line">                <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</div><div class="line">                e.next = newMap[index];</div><div class="line">                newMap[index] = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将“key-value”添加到Hashtable中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">        <span class="comment">// Hashtable中不能插入value为null的元素！！！</span></div><div class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 若“Hashtable中已存在键为key的键值对”，</span></div><div class="line">        <span class="comment">// 则用“新的value”替换“旧的value”</span></div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                V old = e.value;</div><div class="line">                e.value = value;</div><div class="line">                <span class="keyword">return</span> old;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 若“Hashtable中不存在键为key的键值对”，</span></div><div class="line">        <span class="comment">// (01) 将“修改统计数”+1</span></div><div class="line">        modCount++;</div><div class="line">        <span class="comment">// (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子)</span></div><div class="line">        <span class="comment">//  则调整Hashtable的大小</span></div><div class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;</div><div class="line">            <span class="comment">// Rehash the table if the threshold is exceeded</span></div><div class="line">            rehash();</div><div class="line"></div><div class="line">            tab = table;</div><div class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// (03) 将“Hashtable中index”位置的Entry(链表)保存到e中</span></div><div class="line">        Entry&lt;K,V&gt; e = tab[index];</div><div class="line">        <span class="comment">// (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。        </span></div><div class="line">        tab[index] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</div><div class="line">        <span class="comment">// (05) 将“Hashtable的实际容量”+1</span></div><div class="line">        count++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 删除Hashtable中键为key的元素</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry tab[] = table;</div><div class="line">        <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="comment">// 找到“key对应的Entry(链表)”</span></div><div class="line">        <span class="comment">// 然后在链表中找出要删除的节点，并删除该节点。</span></div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index], prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                modCount++;</div><div class="line">                <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</div><div class="line">                    prev.next = e.next;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    tab[index] = e.next;</div><div class="line">                &#125;</div><div class="line">                count--;</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将“Map(t)”的中全部元素逐一添加到Hashtable中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet())</div><div class="line">            put(e.getKey(), e.getValue());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 清空Hashtable</span></div><div class="line">    <span class="comment">// 将Hashtable的table数组的值全部设为null</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        Entry tab[] = table;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = tab.length; --index &gt;= <span class="number">0</span>; )</div><div class="line">            tab[index] = <span class="keyword">null</span>;</div><div class="line">        count = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 克隆一个Hashtable，并以Object的形式返回。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Hashtable&lt;K,V&gt; t = (Hashtable&lt;K,V&gt;) <span class="keyword">super</span>.clone();</div><div class="line">            t.table = <span class="keyword">new</span> Entry[table.length];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = table.length ; i-- &gt; <span class="number">0</span> ; ) &#123;</div><div class="line">                t.table[i] = (table[i] != <span class="keyword">null</span>)</div><div class="line">                ? (Entry&lt;K,V&gt;) table[i].clone() : <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            t.keySet = <span class="keyword">null</span>;</div><div class="line">            t.entrySet = <span class="keyword">null</span>;</div><div class="line">            t.values = <span class="keyword">null</span>;</div><div class="line">            t.modCount = <span class="number">0</span>;</div><div class="line">            <span class="keyword">return</span> t;</div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">            <span class="comment">// this shouldn't happen, since we are Cloneable</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> max = size() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (max == -<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="string">"&#123;&#125;"</span>;</div><div class="line"></div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = entrySet().iterator();</div><div class="line"></div><div class="line">        sb.append(<span class="string">'&#123;'</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</div><div class="line">            Map.Entry&lt;K,V&gt; e = it.next();</div><div class="line">            K key = e.getKey();</div><div class="line">            V value = e.getValue();</div><div class="line">            sb.append(key   == <span class="keyword">this</span> ? <span class="string">"(this Map)"</span> : key.toString());</div><div class="line">            sb.append(<span class="string">'='</span>);</div><div class="line">            sb.append(value == <span class="keyword">this</span> ? <span class="string">"(this Map)"</span> : value.toString());</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (i == max)</div><div class="line">                <span class="keyword">return</span> sb.append(<span class="string">'&#125;'</span>).toString();</div><div class="line">            sb.append(<span class="string">", "</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 获取Hashtable的枚举类对象</span></div><div class="line">    <span class="comment">// 若Hashtable的实际大小为0,则返回“空枚举类”对象；</span></div><div class="line">    <span class="comment">// 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口)</span></div><div class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">Enumeration&lt;T&gt; <span class="title">getEnumeration</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> (Enumeration&lt;T&gt;)emptyEnumerator;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Enumerator&lt;T&gt;(type, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 获取Hashtable的迭代器</span></div><div class="line">    <span class="comment">// 若Hashtable的实际大小为0,则返回“空迭代器”对象；</span></div><div class="line">    <span class="comment">// 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口)</span></div><div class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">Iterator&lt;T&gt; <span class="title">getIterator</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> (Iterator&lt;T&gt;) emptyIterator;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Enumerator&lt;T&gt;(type, <span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Hashtable的“key的集合”。它是一个Set，意味着没有重复元素</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Set&lt;K&gt; keySet = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// Hashtable的“key-value的集合”。它是一个Set，意味着没有重复元素</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// Hashtable的“key-value的集合”。它是一个Collection，意味着可以有重复元素</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Collection&lt;V&gt; values = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 返回一个被synchronizedSet封装后的KeySet对象</span></div><div class="line">    <span class="comment">// synchronizedSet封装的目的是对KeySet的所有方法都添加synchronized，实现多线程同步</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (keySet == <span class="keyword">null</span>)</div><div class="line">            keySet = Collections.synchronizedSet(<span class="keyword">new</span> KeySet(), <span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> keySet;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Hashtable的Key的Set集合。</span></div><div class="line">    <span class="comment">// KeySet继承于AbstractSet，所以，KeySet中的元素没有重复的。</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> getIterator(KEYS);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> count;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> containsKey(o);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Hashtable.<span class="keyword">this</span>.remove(o) != <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">            Hashtable.<span class="keyword">this</span>.clear();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 返回一个被synchronizedSet封装后的EntrySet对象</span></div><div class="line">    <span class="comment">// synchronizedSet封装的目的是对EntrySet的所有方法都添加synchronized，实现多线程同步</span></div><div class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</div><div class="line">        <span class="keyword">if</span> (entrySet==<span class="keyword">null</span>)</div><div class="line">            entrySet = Collections.synchronizedSet(<span class="keyword">new</span> EntrySet(), <span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> entrySet;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Hashtable的Entry的Set集合。</span></div><div class="line">    <span class="comment">// EntrySet继承于AbstractSet，所以，EntrySet中的元素没有重复的。</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</div><div class="line">        <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</div><div class="line">            <span class="keyword">return</span> getIterator(ENTRIES);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Map.Entry&lt;K,V&gt; o)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.add(o);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 查找EntrySet中是否包含Object(0)</span></div><div class="line">        <span class="comment">// 首先，在table中找到o对应的Entry(Entry是一个单向链表)</span></div><div class="line">        <span class="comment">// 然后，查找Entry链表中是否存在Object</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            Map.Entry entry = (Map.Entry)o;</div><div class="line">            Object key = entry.getKey();</div><div class="line">            Entry[] tab = table;</div><div class="line">            <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">            <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (Entry e = tab[index]; e != <span class="keyword">null</span>; e = e.next)</div><div class="line">                <span class="keyword">if</span> (e.hash==hash &amp;&amp; e.equals(entry))</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 删除元素Object(0)</span></div><div class="line">        <span class="comment">// 首先，在table中找到o对应的Entry(Entry是一个单向链表)</span></div><div class="line">        <span class="comment">// 然后，删除链表中的元素Object</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;</div><div class="line">            K key = entry.getKey();</div><div class="line">            Entry[] tab = table;</div><div class="line">            <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">            <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index], prev = <span class="keyword">null</span>; e != <span class="keyword">null</span>;</div><div class="line">                 prev = e, e = e.next) &#123;</div><div class="line">                <span class="keyword">if</span> (e.hash==hash &amp;&amp; e.equals(entry)) &#123;</div><div class="line">                    modCount++;</div><div class="line">                    <span class="keyword">if</span> (prev != <span class="keyword">null</span>)</div><div class="line">                        prev.next = e.next;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        tab[index] = e.next;</div><div class="line"></div><div class="line">                    count--;</div><div class="line">                    e.value = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> count;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">            Hashtable.<span class="keyword">this</span>.clear();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 返回一个被synchronizedCollection封装后的ValueCollection对象</span></div><div class="line">    <span class="comment">// synchronizedCollection封装的目的是对ValueCollection的所有方法都添加synchronized，实现多线程同步</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (values==<span class="keyword">null</span>)</div><div class="line">        values = Collections.synchronizedCollection(<span class="keyword">new</span> ValueCollection(),</div><div class="line">                                                        <span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> values;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Hashtable的value的Collection集合。</span></div><div class="line">    <span class="comment">// ValueCollection继承于AbstractCollection，所以，ValueCollection中的元素可以重复的。</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueCollection</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> getIterator(VALUES);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> count;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> containsValue(o);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">            Hashtable.<span class="keyword">this</span>.clear();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 重新equals()函数</span></div><div class="line">    <span class="comment">// 若两个Hashtable的所有key-value键值对都相等，则判断它们两个相等</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Map&lt;K,V&gt; t = (Map&lt;K,V&gt;) o;</div><div class="line">        <span class="keyword">if</span> (t.size() != size())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 通过迭代器依次取出当前Hashtable的key-value键值对</span></div><div class="line">            <span class="comment">// 并判断该键值对，存在于Hashtable(o)中。</span></div><div class="line">            <span class="comment">// 若不存在，则立即返回false；否则，遍历完“当前Hashtable”并返回true。</span></div><div class="line">            Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</div><div class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</div><div class="line">                Map.Entry&lt;K,V&gt; e = i.next();</div><div class="line">                K key = e.getKey();</div><div class="line">                V value = e.getValue();</div><div class="line">                <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (!(t.get(key)==<span class="keyword">null</span> &amp;&amp; t.containsKey(key)))</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (!value.equals(t.get(key)))</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassCastException unused)   &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 计算Hashtable的哈希值</span></div><div class="line">    <span class="comment">// 若 Hashtable的实际大小为0 或者 加载因子&lt;0，则返回0。</span></div><div class="line">    <span class="comment">// 否则，返回“Hashtable中的每个Entry的key和value的异或值 的总和”。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (count == <span class="number">0</span> || loadFactor &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> h;  <span class="comment">// Returns zero</span></div><div class="line"></div><div class="line">        loadFactor = -loadFactor;  <span class="comment">// Mark hashCode computation in progress</span></div><div class="line">        Entry[] tab = table;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i++)</div><div class="line">            <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</div><div class="line">                h += e.key.hashCode() ^ e.value.hashCode();</div><div class="line">        loadFactor = -loadFactor;  <span class="comment">// Mark hashCode computation complete</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> h;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// java.io.Serializable的写入函数</span></div><div class="line">    <span class="comment">// 将Hashtable的“总的容量，实际容量，所有的Entry”都写入到输出流中</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></div><div class="line">        <span class="keyword">throws</span> IOException</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// Write out the length, threshold, loadfactor</span></div><div class="line">        s.defaultWriteObject();</div><div class="line"></div><div class="line">        <span class="comment">// Write out length, count of elements and then the key/value objects</span></div><div class="line">        s.writeInt(table.length);</div><div class="line">        s.writeInt(count);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = table.length-<span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</div><div class="line">            Entry entry = table[index];</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (entry != <span class="keyword">null</span>) &#123;</div><div class="line">            s.writeObject(entry.key);</div><div class="line">            s.writeObject(entry.value);</div><div class="line">            entry = entry.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// java.io.Serializable的读取函数：根据写入方式读出</span></div><div class="line">    <span class="comment">// 将Hashtable的“总的容量，实际容量，所有的Entry”依次读出</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></div><div class="line">         <span class="keyword">throws</span> IOException, ClassNotFoundException</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// Read in the length, threshold, and loadfactor</span></div><div class="line">        s.defaultReadObject();</div><div class="line"></div><div class="line">        <span class="comment">// Read the original length of the array and number of elements</span></div><div class="line">        <span class="keyword">int</span> origlength = s.readInt();</div><div class="line">        <span class="keyword">int</span> elements = s.readInt();</div><div class="line"></div><div class="line">        <span class="comment">// Compute new size with a bit of room 5% to grow but</span></div><div class="line">        <span class="comment">// no larger than the original size.  Make the length</span></div><div class="line">        <span class="comment">// odd if it's large enough, this helps distribute the entries.</span></div><div class="line">        <span class="comment">// Guard against the length ending up zero, that's not valid.</span></div><div class="line">        <span class="keyword">int</span> length = (<span class="keyword">int</span>)(elements * loadFactor) + (elements / <span class="number">20</span>) + <span class="number">3</span>;</div><div class="line">        <span class="keyword">if</span> (length &gt; elements &amp;&amp; (length &amp; <span class="number">1</span>) == <span class="number">0</span>)</div><div class="line">            length--;</div><div class="line">        <span class="keyword">if</span> (origlength &gt; <span class="number">0</span> &amp;&amp; length &gt; origlength)</div><div class="line">            length = origlength;</div><div class="line"></div><div class="line">        Entry[] table = <span class="keyword">new</span> Entry[length];</div><div class="line">        count = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Read the number of elements and then all the key/value objects</span></div><div class="line">        <span class="keyword">for</span> (; elements &gt; <span class="number">0</span>; elements--) &#123;</div><div class="line">            K key = (K)s.readObject();</div><div class="line">            V value = (V)s.readObject();</div><div class="line">                <span class="comment">// synch could be eliminated for performance</span></div><div class="line">                reconstitutionPut(table, key, value);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.table = table;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reconstitutionPut</span><span class="params">(Entry[] tab, K key, V value)</span></span></div><div class="line">        <span class="keyword">throws</span> StreamCorruptedException</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></div><div class="line">        <span class="comment">// This should not happen in deserialized version.</span></div><div class="line">        <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> java.io.StreamCorruptedException();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Creates the new entry.</span></div><div class="line">        Entry&lt;K,V&gt; e = tab[index];</div><div class="line">        tab[index] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Hashtable的Entry节点，它本质上是一个单向链表。</span></div><div class="line">    <span class="comment">// 也因此，我们才能推断出Hashtable是由拉链法实现的散列表</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="comment">// 哈希值</span></div><div class="line">        <span class="keyword">int</span> hash;</div><div class="line">        K key;</div><div class="line">        V value;</div><div class="line">        <span class="comment">// 指向的下一个Entry，即链表的下一个节点</span></div><div class="line">        Entry&lt;K,V&gt; next;</div><div class="line"></div><div class="line">        <span class="comment">// 构造函数</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Entry&lt;K,V&gt; next)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.hash = hash;</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.value = value;</div><div class="line">            <span class="keyword">this</span>.next = next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value,</div><div class="line">                  (next==<span class="keyword">null</span> ? <span class="keyword">null</span> : (Entry&lt;K,V&gt;) next.clone()));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> key;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> value;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 设置value。若value是null，则抛出异常。</span></div><div class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line"></div><div class="line">            V oldValue = <span class="keyword">this</span>.value;</div><div class="line">            <span class="keyword">this</span>.value = value;</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 覆盖equals()方法，判断两个Entry是否相等。</span></div><div class="line">        <span class="comment">// 若两个Entry的key和value都相等，则认为它们相等。</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            Map.Entry e = (Map.Entry)o;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> (key==<span class="keyword">null</span> ? e.getKey()==<span class="keyword">null</span> : key.equals(e.getKey())) &amp;&amp;</div><div class="line">               (value==<span class="keyword">null</span> ? e.getValue()==<span class="keyword">null</span> : value.equals(e.getValue()));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> hash ^ (value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> key.toString()+<span class="string">"="</span>+value.toString();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEYS = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALUES = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENTRIES = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Enumerator的作用是提供了“通过elements()遍历Hashtable的接口” 和 “通过entrySet()遍历Hashtable的接口”。因为，它同时实现了 “Enumerator接口”和“Iterator接口”。</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Enumerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Enumeration</span>&lt;<span class="title">T</span>&gt;, <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">        <span class="comment">// 指向Hashtable的table</span></div><div class="line">        Entry[] table = Hashtable.<span class="keyword">this</span>.table;</div><div class="line">        <span class="comment">// Hashtable的总的大小</span></div><div class="line">        <span class="keyword">int</span> index = table.length;</div><div class="line">        Entry&lt;K,V&gt; entry = <span class="keyword">null</span>;</div><div class="line">        Entry&lt;K,V&gt; lastReturned = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">int</span> type;</div><div class="line"></div><div class="line">        <span class="comment">// Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志</span></div><div class="line">        <span class="comment">// iterator为true，表示它是迭代器；否则，是枚举类。</span></div><div class="line">        <span class="keyword">boolean</span> iterator;</div><div class="line"></div><div class="line">        <span class="comment">// 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。</span></div><div class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line"></div><div class="line">        Enumerator(<span class="keyword">int</span> type, <span class="keyword">boolean</span> iterator) &#123;</div><div class="line">            <span class="keyword">this</span>.type = type;</div><div class="line">            <span class="keyword">this</span>.iterator = iterator;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</div><div class="line">            Entry&lt;K,V&gt; e = entry;</div><div class="line">            <span class="keyword">int</span> i = index;</div><div class="line">            Entry[] t = table;</div><div class="line">            <span class="comment">/* Use locals for faster loop iteration */</span></div><div class="line">            <span class="keyword">while</span> (e == <span class="keyword">null</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;</div><div class="line">                e = t[--i];</div><div class="line">            &#125;</div><div class="line">            entry = e;</div><div class="line">            index = i;</div><div class="line">            <span class="keyword">return</span> e != <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 获取下一个元素</span></div><div class="line">        <span class="comment">// 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式”</span></div><div class="line">        <span class="comment">// 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。</span></div><div class="line">        <span class="comment">// 然后，依次向后遍历单向链表Entry。</span></div><div class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</div><div class="line">            Entry&lt;K,V&gt; et = entry;</div><div class="line">            <span class="keyword">int</span> i = index;</div><div class="line">            Entry[] t = table;</div><div class="line">            <span class="comment">/* Use locals for faster loop iteration */</span></div><div class="line">            <span class="keyword">while</span> (et == <span class="keyword">null</span> &amp;&amp; i &gt; <span class="number">0</span>) &#123;</div><div class="line">                et = t[--i];</div><div class="line">            &#125;</div><div class="line">            entry = et;</div><div class="line">            index = i;</div><div class="line">            <span class="keyword">if</span> (et != <span class="keyword">null</span>) &#123;</div><div class="line">                Entry&lt;K,V&gt; e = lastReturned = entry;</div><div class="line">                entry = e.next;</div><div class="line">                <span class="keyword">return</span> type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Hashtable Enumerator"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 迭代器Iterator的判断是否存在下一个元素</span></div><div class="line">        <span class="comment">// 实际上，它是调用的hasMoreElements()</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> hasMoreElements();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 迭代器获取下一个元素</span></div><div class="line">        <span class="comment">// 实际上，它是调用的nextElement()</span></div><div class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">            <span class="keyword">return</span> nextElement();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 迭代器的remove()接口。</span></div><div class="line">        <span class="comment">// 首先，它在table数组中找出要删除元素所在的Entry，</span></div><div class="line">        <span class="comment">// 然后，删除单向链表Entry中的元素。</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (!iterator)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">            <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Hashtable Enumerator"</span>);</div><div class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line"></div><div class="line">            <span class="keyword">synchronized</span>(Hashtable.<span class="keyword">this</span>) &#123;</div><div class="line">                Entry[] tab = Hashtable.<span class="keyword">this</span>.table;</div><div class="line">                <span class="keyword">int</span> index = (lastReturned.hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (Entry&lt;K,V&gt; e = tab[index], prev = <span class="keyword">null</span>; e != <span class="keyword">null</span>;</div><div class="line">                     prev = e, e = e.next) &#123;</div><div class="line">                    <span class="keyword">if</span> (e == lastReturned) &#123;</div><div class="line">                        modCount++;</div><div class="line">                        expectedModCount++;</div><div class="line">                        <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</div><div class="line">                            tab[index] = e.next;</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            prev.next = e.next;</div><div class="line">                        count--;</div><div class="line">                        lastReturned = <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Enumeration emptyEnumerator = <span class="keyword">new</span> EmptyEnumerator();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Iterator emptyIterator = <span class="keyword">new</span> EmptyIterator();</div><div class="line"></div><div class="line">    <span class="comment">// 空枚举类</span></div><div class="line">    <span class="comment">// 当Hashtable的实际大小为0；此时，又要通过Enumeration遍历Hashtable时，返回的是“空枚举类”的对象。</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyEnumerator</span> <span class="keyword">implements</span> <span class="title">Enumeration</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">        EmptyEnumerator() &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 空枚举类的hasMoreElements() 始终返回false</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 空枚举类的nextElement() 抛出异常</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Hashtable Enumerator"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// 空迭代器</span></div><div class="line">    <span class="comment">// 当Hashtable的实际大小为0；此时，又要通过迭代器遍历Hashtable时，返回的是“空迭代器”的对象。</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">        EmptyIterator() &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"Hashtable Iterator"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Hashtable Iterator"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;hashtable&quot;&gt;&lt;a href=&quot;#hashtable&quot; class=&quot;headerlink&quot; title=&quot;hashtable&quot;&gt;&lt;/a&gt;hashtable&lt;/h1&gt;&lt;p&gt;转载:&lt;a href=&quot;http://www.cnblogs.com/skywang
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍5-treeset&amp;treemap</title>
    <link href="http://yoursite.com/2017/02/25/5-TreeSet%20and%20TreeMap/"/>
    <id>http://yoursite.com/2017/02/25/5-TreeSet and TreeMap/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T06:25:20.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TreeSet-and-TreeMap"><a href="#TreeSet-and-TreeMap" class="headerlink" title="TreeSet and TreeMap"></a>TreeSet and TreeMap</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>之所以把<em>TreeSet</em>和<em>TreeMap</em>放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<strong><em>TreeSet</em>里面有一个<em>TreeMap</em>（适配器模式）</strong>。因此本文将重点分析<em>TreeMap</em>。</p>
<p>Java <em>TreeMap</em>实现了<em>SortedMap</em>接口，也就是说会按照<code>key</code>的大小顺序对<em>Map</em>中的元素进行排序，<code>key</code>大小的评判可以通过其本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator）。</p>
<p><strong><em>TreeMap</em>底层通过红黑树（Red-Black tree）实现</strong>，也就意味着<code>containsKey()</code>, <code>get()</code>, <code>put()</code>, <code>remove()</code>都有着<code>log(n)</code>的时间复杂度。其具体算法实现参照了《算法导论》。</p>
<p><img src="../PNGFigures/TreeMap_base.png" alt="TreeMap_base.png"></p>
<p>出于性能原因，<em>TreeMap</em>是非同步的（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将<em>TreeMap</em>包装成（wrapped）同步的：</p>
<p><code>SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));</code></p>
<p><strong>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一陪</strong>。具体来说，红黑树是满足如下条件的二叉查找树（binary search tree）：</p>
<ol>
<li>每个节点要么是红色，要么是黑色。</li>
<li>根节点必须是黑色</li>
<li>红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。</li>
<li>对于每个节点，从该点至<code>null</code>（树尾端）的任何路径，都含有相同个数的黑色节点。</li>
</ol>
<p>在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的约束条件。</p>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>前文说到当查找树的结构发生改变时，红黑树的约束条件可能被破坏，需要通过调整使得查找树重新满足红黑树的约束条件。调整可以分为两类：一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作：<strong>左旋（Rotate Left），右旋（RotateRight）</strong>。</p>
<h2 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h2><p>左旋的过程是将<code>x</code>的右子树绕<code>x</code>逆时针旋转，使得<code>x</code>的右子树成为<code>x</code>的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p>
<p><img src="../PNGFigures/TreeMap_rotateLeft.png" alt="TreeMap_rotateLeft.png"></p>
<p><em>TreeMap</em>中左旋代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Rotate Left</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">        Entry&lt;K,V&gt; r = p.right;</div><div class="line">        p.right = r.left;</div><div class="line">        <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</div><div class="line">            r.left.parent = p;</div><div class="line">        r.parent = p.parent;</div><div class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</div><div class="line">            root = r;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</div><div class="line">            p.parent.left = r;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            p.parent.right = r;</div><div class="line">        r.left = p;</div><div class="line">        p.parent = r;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h2><p>右旋的过程是将<code>x</code>的左子树绕<code>x</code>顺时针旋转，使得<code>x</code>的左子树成为<code>x</code>的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p>
<p><img src="../PNGFigures/TreeMap_rotateRight.png" alt="TreeMap_rotateRight.png"></p>
<p><em>TreeMap</em>中右旋代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Rotate Right</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">        Entry&lt;K,V&gt; l = p.left;</div><div class="line">        p.left = l.right;</div><div class="line">        <span class="keyword">if</span> (l.right != <span class="keyword">null</span>) l.right.parent = p;</div><div class="line">        l.parent = p.parent;</div><div class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</div><div class="line">            root = l;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.right == p)</div><div class="line">            p.parent.right = l;</div><div class="line">        <span class="keyword">else</span> p.parent.left = l;</div><div class="line">        l.right = p;</div><div class="line">        p.parent = l;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="寻找节点后继"><a href="#寻找节点后继" class="headerlink" title="寻找节点后继"></a>寻找节点后继</h2><p>对于一棵二叉查找树，给定节点t，其后继（树种比大于t的最小的那个元素）可以通过如下方式找到：</p>
<blockquote>
<ol>
<li>t的右子树不空，则t的后继是其右子树中最小的那个元素。</li>
<li>t的右孩子为空，则t的后继是其第一个向左走的祖先。</li>
</ol>
</blockquote>
<p>后继节点在红黑树的删除操作中将会用到。</p>
<p><img src="../PNGFigures/TreeMap_successor.png" alt="TreeMap_successor.png"></p>
<p><em>TreeMap</em>中寻找节点后继的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 寻找节点后继函数successor()</span></div><div class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;<span class="comment">// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素</span></div><div class="line">        Entry&lt;K,V&gt; p = t.right;</div><div class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</div><div class="line">            p = p.left;</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先</span></div><div class="line">        Entry&lt;K,V&gt; p = t.parent;</div><div class="line">        Entry&lt;K,V&gt; ch = t;</div><div class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</div><div class="line">            ch = p;</div><div class="line">            p = p.parent;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.value</code>。因此<code>getEntry()</code>是算法的核心。算法思想是根据<code>key</code>的自然顺序（或者比较器顺序）对二叉查找树进行查找，直到找到满足<code>k.compareTo(p.key) == 0</code>的<code>entry</code>。</p>
<p><img src="../PNGFigures/TreeMap_getEntry.png" alt="TreeMap_getEntry.png"></p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//getEntry()方法</span></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)<span class="comment">//不允许key值为null</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;<span class="comment">//使用元素的自然顺序</span></div><div class="line">    Entry&lt;K,V&gt; p = root;</div><div class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</div><div class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)<span class="comment">//向左找</span></div><div class="line">            p = p.left;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)<span class="comment">//向右找</span></div><div class="line">            p = p.right;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h2><p><code>put(K key, V value)</code>方法是将指定的<code>key</code>, <code>value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到则会在红黑树中插入新的<code>entry</code>，如果插入之后破坏了红黑树的约束条件，还需要进行调整（旋转，改变某些节点的颜色）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">	......</div><div class="line">    <span class="keyword">int</span> cmp;</div><div class="line">    Entry&lt;K,V&gt; parent;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;<span class="comment">//使用元素的自然顺序</span></div><div class="line">    do &#123;</div><div class="line">        parent = t;</div><div class="line">        cmp = k.compareTo(t.key);</div><div class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) t = t.left;<span class="comment">//向左找</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) t = t.right;<span class="comment">//向右找</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> t.setValue(value);</div><div class="line">    &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</div><div class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);<span class="comment">//创建并插入新的entry</span></div><div class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) parent.left = e;</div><div class="line">    <span class="keyword">else</span> parent.right = e;</div><div class="line">    fixAfterInsertion(e);<span class="comment">//调整</span></div><div class="line">    size++;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码的插入部分并不难理解：首先在红黑树上找到合适的位置，然后创建新的<code>entry</code>并插入（当然，新插入的节点一定是树的叶子）。难点是调整函数<code>fixAfterInsertion()</code>，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。</p>
<p><img src="../PNGFigures/TreeMap_put.png" alt="TreeMap_put.png"></p>
<p>调整函数<code>fixAfterInsertion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//红黑树调整函数fixAfterInsertion()</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</div><div class="line">    x.color = RED;</div><div class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</div><div class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</div><div class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</div><div class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</div><div class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况1</span></div><div class="line">                setColor(y, BLACK);                        <span class="comment">// 情况1</span></div><div class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况1</span></div><div class="line">                x = parentOf(parentOf(x));                 <span class="comment">// 情况1</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</div><div class="line">                    x = parentOf(x);                       <span class="comment">// 情况2</span></div><div class="line">                    rotateLeft(x);                         <span class="comment">// 情况2</span></div><div class="line">                &#125;</div><div class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况3</span></div><div class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况3</span></div><div class="line">                rotateRight(parentOf(parentOf(x)));        <span class="comment">// 情况3</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</div><div class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</div><div class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况4</span></div><div class="line">                setColor(y, BLACK);                        <span class="comment">// 情况4</span></div><div class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况4</span></div><div class="line">                x = parentOf(parentOf(x));                 <span class="comment">// 情况4</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</div><div class="line">                    x = parentOf(x);                       <span class="comment">// 情况5</span></div><div class="line">                    rotateRight(x);                        <span class="comment">// 情况5</span></div><div class="line">                &#125;</div><div class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况6</span></div><div class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况6</span></div><div class="line">                rotateLeft(parentOf(parentOf(x)));         <span class="comment">// 情况6</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    root.color = BLACK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法首先通过上文中提到的<code>getEntry(Object key)</code>方法找到<code>key</code>值对应的<code>entry</code>，然后调用<code>deleteEntry(Entry&lt;K,V&gt; entry)</code>删除对应的<code>entry</code>。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。</p>
<p><code>getEntry()</code>函数前面已经讲解过，这里重点放<code>deleteEntry()</code>上，该函数删除指定的<code>entry</code>并在红黑树的约束被破坏时进行调用<code>fixAfterDeletion(Entry&lt;K,V&gt; x)</code>进行调整。</p>
<p><strong>由于红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整</strong>。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况：</p>
<blockquote>
<ol>
<li>删除点p的左右子树都为空，或者只有一棵子树非空。</li>
<li>删除点p的左右子树都非空。</li>
</ol>
</blockquote>
<p>对于上述情况1，处理起来比较简单，直接将p删除（左右子树都为空时），或者用非空子树替代p（只有一棵子树非空时）；对于情况2，可以用p的后继s（树中大于x的最小的那个元素）代替p，然后使用情况1删除s（此时s一定满足情况1.可以画画看）。</p>
<p>基于以上逻辑，红黑树的节点删除函数<code>deleteEntry()</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 红黑树entry删除函数deleteEntry()</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    size--;</div><div class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;<span class="comment">// 2. 删除点p的左右子树都非空。</span></div><div class="line">        Entry&lt;K,V&gt; s = successor(p);<span class="comment">// 后继</span></div><div class="line">        p.key = s.key;</div><div class="line">        p.value = s.value;</div><div class="line">        p = s;</div><div class="line">    &#125;</div><div class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</div><div class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;<span class="comment">// 1. 删除点p只有一棵子树非空。</span></div><div class="line">        replacement.parent = p.parent;</div><div class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</div><div class="line">            root = replacement;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</div><div class="line">            p.parent.left  = replacement;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            p.parent.right = replacement;</div><div class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (p.color == BLACK)</div><div class="line">            fixAfterDeletion(replacement);<span class="comment">// 调整</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123;</div><div class="line">        root = <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 1. 删除点p的左右子树都为空</span></div><div class="line">        <span class="keyword">if</span> (p.color == BLACK)</div><div class="line">            fixAfterDeletion(p);<span class="comment">// 调整</span></div><div class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (p == p.parent.left)</div><div class="line">                p.parent.left = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</div><div class="line">                p.parent.right = <span class="keyword">null</span>;</div><div class="line">            p.parent = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数<code>fixAfterDeletion()</code>。首先请思考一下，删除了哪些点才会导致调整？<strong>只有删除点是BLACK的时候，才会触发调整函数</strong>，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。</p>
<p>跟上文中讲过的<code>fixAfterInsertion()</code>函数一样，这里也要分成若干种情况。记住，<strong>无论有多少情况，具体的调整操作只有两种：1.改变某些节点的颜色，2.对某些节点进行旋转。</strong></p>
<p><img src="../PNGFigures/TreeMap_fixAfterDeletion.png" alt="TreeMap_fixAfterDeletion.png"></p>
<p>上述图解的总体思想是：将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则：a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环（因为x为红色）；b).一旦进入情况3和情况4，一定会退出循环（因为x为root）。</p>
<p>删除后调整函数<code>fixAfterDeletion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</div><div class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</div><div class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</div><div class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</div><div class="line">                setColor(sib, BLACK);                   <span class="comment">// 情况1</span></div><div class="line">                setColor(parentOf(x), RED);             <span class="comment">// 情况1</span></div><div class="line">                rotateLeft(parentOf(x));                <span class="comment">// 情况1</span></div><div class="line">                sib = rightOf(parentOf(x));             <span class="comment">// 情况1</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</div><div class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</div><div class="line">                setColor(sib, RED);                     <span class="comment">// 情况2</span></div><div class="line">                x = parentOf(x);                        <span class="comment">// 情况2</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</div><div class="line">                    setColor(leftOf(sib), BLACK);       <span class="comment">// 情况3</span></div><div class="line">                    setColor(sib, RED);                 <span class="comment">// 情况3</span></div><div class="line">                    rotateRight(sib);                   <span class="comment">// 情况3</span></div><div class="line">                    sib = rightOf(parentOf(x));         <span class="comment">// 情况3</span></div><div class="line">                &#125;</div><div class="line">                setColor(sib, colorOf(parentOf(x)));    <span class="comment">// 情况4</span></div><div class="line">                setColor(parentOf(x), BLACK);           <span class="comment">// 情况4</span></div><div class="line">                setColor(rightOf(sib), BLACK);          <span class="comment">// 情况4</span></div><div class="line">                rotateLeft(parentOf(x));                <span class="comment">// 情况4</span></div><div class="line">                x = root;                               <span class="comment">// 情况4</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 跟前四种情况对称</span></div><div class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</div><div class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</div><div class="line">                setColor(sib, BLACK);                   <span class="comment">// 情况5</span></div><div class="line">                setColor(parentOf(x), RED);             <span class="comment">// 情况5</span></div><div class="line">                rotateRight(parentOf(x));               <span class="comment">// 情况5</span></div><div class="line">                sib = leftOf(parentOf(x));              <span class="comment">// 情况5</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</div><div class="line">                colorOf(leftOf(sib)) == BLACK) &#123;</div><div class="line">                setColor(sib, RED);                     <span class="comment">// 情况6</span></div><div class="line">                x = parentOf(x);                        <span class="comment">// 情况6</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</div><div class="line">                    setColor(rightOf(sib), BLACK);      <span class="comment">// 情况7</span></div><div class="line">                    setColor(sib, RED);                 <span class="comment">// 情况7</span></div><div class="line">                    rotateLeft(sib);                    <span class="comment">// 情况7</span></div><div class="line">                    sib = leftOf(parentOf(x));          <span class="comment">// 情况7</span></div><div class="line">                &#125;</div><div class="line">                setColor(sib, colorOf(parentOf(x)));    <span class="comment">// 情况8</span></div><div class="line">                setColor(parentOf(x), BLACK);           <span class="comment">// 情况8</span></div><div class="line">                setColor(leftOf(sib), BLACK);           <span class="comment">// 情况8</span></div><div class="line">                rotateRight(parentOf(x));               <span class="comment">// 情况8</span></div><div class="line">                x = root;                               <span class="comment">// 情况8</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    setColor(x, BLACK);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><p>前面已经说过<code>TreeSet</code>是对<code>TreeMap</code>的简单包装，对<code>TreeSet</code>的函数调用都会转换成合适的<code>TreeMap</code>方法，因此<code>TreeSet</code>的实现非常简单。这里不再赘述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// TreeSet是对TreeMap的简单包装</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line">&#123;</div><div class="line">	......</div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</div><div class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.m = <span class="keyword">new</span> TreeMap&lt;E,Object&gt;();<span class="comment">// TreeSet里面有一个TreeMap</span></div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TreeSet-and-TreeMap&quot;&gt;&lt;a href=&quot;#TreeSet-and-TreeMap&quot; class=&quot;headerlink&quot; title=&quot;TreeSet and TreeMap&quot;&gt;&lt;/a&gt;TreeSet and TreeMap&lt;/h1&gt;&lt;h1 i
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf概述1</title>
    <link href="http://yoursite.com/2017/02/25/1-Overview/"/>
    <id>http://yoursite.com/2017/02/25/1-Overview/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T06:24:00.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>容器，就是可以容纳其他Java对象的对象。<em>Java Collections Framework（JCF）</em>为Java开发者提供了通用的容器，其始于JDK 1.2，优点是：</p>
<ul>
<li>降低编程难度</li>
<li>提高程序性能</li>
<li>提高API间的互操作性</li>
<li>降低学习难度</li>
<li>降低设计和实现相关API的难度</li>
<li>增加程序的重用性</li>
</ul>
<p>Java容器里只能放对象，对于基本类型（int, long, float, double等），需要将其包装成对象类型后（Integer, Long, Float, Double等）才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。</p>
<h1 id="泛型（Generics）"><a href="#泛型（Generics）" class="headerlink" title="泛型（Generics）"></a>泛型（Generics）</h1><p>Java容器能够容纳任何类型的对象，这一点表面上是通过泛型机制完成，Java泛型不是什么神奇的东西，只是编译器为我们提供的一个“语法糖”，泛型本身并不需要Java虚拟机的支持，只需要在编译阶段做一下简单的字符串替换即可。实质上Java的单继承机制才是保证这一特性的根本，因为所有的对象都是Object的子类，容器里只要能够存放Object对象就行了。<br>事实上，所有容器的内部存放的都是Object对象，泛型机制只是简化了编程，由编译器自动帮我们完成了强制类型转换而已。JDK 1.4以及之前版本不支持泛型，类型转换需要程序员显式完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JDK 1.4 or before</span></div><div class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</div><div class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Monday"</span>));</div><div class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Tuesday"</span>));</div><div class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Wensday"</span>));</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</div><div class="line">    String weekday = (String)list.get(i);<span class="comment">//显式类型转换</span></div><div class="line">    System.out.println(weekday.toUpperCase());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JDK 1.5 or latter</span></div><div class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//参数化类型</span></div><div class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Monday"</span>));</div><div class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Tuesday"</span>));</div><div class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Wensday"</span>));</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</div><div class="line">    String weekday = list.get(i);<span class="comment">//隐式类型转换，编译器自动完成</span></div><div class="line">    System.out.println(weekday.toUpperCase());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>跟C++复杂的内存管理机制不同，Java GC自动包揽了一切，Java程序并不需要处理令人头疼的内存问题，因此JCF并不像C++ STL那样需要专门的空间适配器（alloctor）。<br>另外，由于Java里对象都在堆上，且对象只能通过引用（reference，跟C++中的引用不是同一个概念，可以理解成经过包装后的指针）访问，容器里放的其实是对象的引用而不是对象本身，也就不存在C++容器的复制拷贝问题。</p>
<h1 id="接口和实现（Interfaces-and-Implementations）"><a href="#接口和实现（Interfaces-and-Implementations）" class="headerlink" title="接口和实现（Interfaces and Implementations）"></a>接口和实现（Interfaces and Implementations）</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>为了规范容器的行为，统一设计，JCF定义了14种容器接口（collection interfaces），它们的关系如下图所示：<br><img src="../PNGFigures/JCF_Collection_Interfaces.png" alt="pic"><br><em>Map</em>接口没有继承自<em>Collection</em>接口，因为<em>Map</em>表示的是关联式容器而不是集合。但Java为我们提供了从<em>Map</em>转换到<em>Collection</em>的方法，可以方便的将<em>Map</em>切换到集合视图。<br>上图中提供了<em>Queue</em>接口，却没有<em>Stack</em>，这是因为<em>Stack</em>的功能已被JDK 1.6引入的<em>Deque</em>取代。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>上述接口的通用实现见下表：</p>
<table align="center"><tr><td colspan="2" rowspan="2" align="center" border="0"></td><th colspan="5" align="center">Implementations</th></tr><tr><th>Hash Table</th><th>Resizable Array</th><th>Balanced Tree</th><th>Linked List</th><th>Hash Table + Linked List</th></tr><tr><th rowspan="4">Interfaces</th><th>Set</th><td><tt>HashSet</tt></td><td></td><td><tt>TreeSet</tt></td><td></td><td><tt>LinkedHashSet</tt></td></tr><tr><th>List</th><td></td><td><tt>ArrayList</tt></td><td></td><td><tt>LinkedList</tt></td><td></td></tr><tr><th>Deque</th><td></td><td><tt>ArrayDeque</tt></td><td></td><td><tt>LinkedList</tt></td><td></td></tr><tr><th>Map</th><td><tt>HashMap</tt></td><td></td><td><tt>TreeMap</tt></td><td></td><td><tt>LinkedHashMap</tt></td></tr></table>

<p>接下来的篇幅，会逐个介绍上表中容器的数据结构以及用到的算法。</p>
<h1 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（Iterator）</h1><p>跟C++ STL一样，JCF的迭代器（Iterator）为我们提供了遍历容器中元素的方法。只有容器本身清楚容器里元素的组织方式，因此迭代器只能通过容器本身得到。每个容器都会通过内部类的形式实现自己的迭代器。相比STL的迭代器，JCF的迭代器更容易使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//visit a list with iterator</span></div><div class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Monday"</span>));</div><div class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Tuesday"</span>));</div><div class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Wensday"</span>));</div><div class="line">Iterator&lt;String&gt; it = list.iterator();<span class="comment">//得到迭代器</span></div><div class="line"><span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">    String weekday = it.next();<span class="comment">//访问元素</span></div><div class="line">    System.out.println(weekday.toUpperCase());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JDK 1.5 引入了增强的for循环，简化了迭代容器时的写法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用增强for迭代</span></div><div class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Monday"</span>));</div><div class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Tuesday"</span>));</div><div class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Wensday"</span>));</div><div class="line"><span class="keyword">for</span>(String weekday : list)&#123;<span class="comment">//enhanced for statement</span></div><div class="line">	System.out.println(weekday.toUpperCase());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p>JDK安装目录下的src.zip包含了Java core API的源代码，本文采用的是JDK 1.7u79的源码，<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html" target="_blank" rel="external">下载地址</a>。<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/source/src.zip" target="_blank" rel="external">这里复制了一份</a>。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/collections/overview.html" target="_blank" rel="external">Collections Framework Overview</a></li>
<li><a href="http://docs.oracle.com/javase/1.5.0/docs/guide/language/foreach.html" target="_blank" rel="external">The For-Each Loop</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;p&gt;容器，就是可以容纳其他Java对象的对象。&lt;em&gt;Java Collections Framework（JCF）&lt;/em&gt;为Java开发者提
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍6-hashset&amp;hashmap</title>
    <link href="http://yoursite.com/2017/02/25/6-HashSet%20and%20HashMap/"/>
    <id>http://yoursite.com/2017/02/25/6-HashSet and HashMap/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T06:25:52.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashSet-and-HashMap"><a href="#HashSet-and-HashMap" class="headerlink" title="HashSet and HashMap"></a>HashSet and HashMap</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>之所以把<em>HashSet</em>和<em>HashMap</em>放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<strong><em>HashSet</em>里面有一个<em>HashMap</em>（适配器模式）</strong>。因此本文将重点分析<em>HashMap</em>。</p>
<p><em>HashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素；除该类未实现同步外，其余跟<code>Hashtable</code>大致相同；跟<em>TreeMap</em>不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个<em>HashMap</em>的顺序可能会不同。<br>根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式（Open addressing），另一种是冲突链表方式（Separate chaining with linked lists）。<strong>Java <em>HashMap</em>采用的是冲突链表方式</strong>。<br><img src="../PNGFigures/HashMap_base.png" alt="HashMap_base"></p>
<p>从上图容易看出，如果选择合适的哈希函数，<code>put()</code>和<code>get()</code>方法可以在常数时间内完成。但在对<em>HashMap</em>进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将<em>HashMap</em>的初始大小设的过大。</p>
<p>有两个参数可以影响<em>HashMap</em>的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p>
<p>将对象放入到<em>HashMap</em>或<em>HashSet</em>中时，有两个方法需要特别关心：<code>hashCode()</code>和<code>equals()</code>。<strong><code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”</strong>。所以，如果要将自定义的对象放入到<code>HashMap</code>或<code>HashSet</code>中，需要<em>@Override</em><code>hashCode()</code>和<code>equals()</code>方法。</p>
<h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.getValue()</code>。因此<code>getEntry()</code>是算法的核心。<br>算法思想是首先通过<code>hash()</code>函数得到对应<code>bucket</code>的下标，然后依次遍历冲突链表，通过<code>key.equals(k)</code>方法来判断是否是要找的那个<code>entry</code>。<br><img src="../PNGFigures/HashMap_getEntry.png" alt="HashMap_getEntry"><br>上图中<code>hash(k)&amp;(table.length-1)</code>等价于<code>hash(k)%table.length</code>，原因是<em>HashMap</em>要求<code>table.length</code>必须是2的指数，因此<code>table.length-1</code>就是二进制低位全是1，跟<code>hash(k)</code>相与会将哈希值的高位全抹掉，剩下的就是余数了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//getEntry()方法</span></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">	......</div><div class="line">	<span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-<span class="number">1</span>)];<span class="comment">//得到冲突链表</span></div><div class="line">         e != <span class="keyword">null</span>; e = e.next) &#123;<span class="comment">//依次遍历冲突链表中的每个entry</span></div><div class="line">        Object k;</div><div class="line">        <span class="comment">//依据equals()方法判断是否相等</span></div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h2><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>，插入方式为<strong>头插法</strong>。<br><img src="../PNGFigures/HashMap_addEntry.png" alt="HashMap_addEntry"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//addEntry()</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</div><div class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">//自动扩容，并重新哈希</span></div><div class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</div><div class="line">        bucketIndex = hash &amp; (table.length-<span class="number">1</span>);<span class="comment">//hash%table.length</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//在冲突链表头部插入新的entry</span></div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到<code>key</code>值对应的<code>entry</code>，然后删除该<code>entry</code>（修改链表的相应引用）。查找过程跟<code>getEntry()</code>过程类似。<br><img src="../PNGFigures/HashMap_removeEntryForKey.png" alt="HashMap_removeEntryForKey"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//removeEntryForKey()</span></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">	......</div><div class="line">	<span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//hash&amp;(table.length-1)</span></div><div class="line">    Entry&lt;K,V&gt; prev = table[i];<span class="comment">//得到冲突链表</span></div><div class="line">    Entry&lt;K,V&gt; e = prev;</div><div class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">//遍历冲突链表</span></div><div class="line">        Entry&lt;K,V&gt; next = e.next;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<span class="comment">//找到要删除的entry</span></div><div class="line">            modCount++; size--;</div><div class="line">            <span class="keyword">if</span> (prev == e) table[i] = next;<span class="comment">//删除的是冲突链表的第一个entry</span></div><div class="line">            <span class="keyword">else</span> prev.next = next;</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">        &#125;</div><div class="line">        prev = e; e = next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p>前面已经说过<em>HashSet</em>是对<em>HashMap</em>的简单包装，对<em>HashSet</em>的函数调用都会转换成合适的<em>HashMap</em>方法，因此<em>HashSet</em>的实现非常简单，只有不到300行代码。这里不再赘述。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//HashSet是对HashMap的简单包装</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">&#123;</div><div class="line">	......</div><div class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;<span class="comment">//HashSet里面有一个HashMap</span></div><div class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//简单的方法转换</span></div><div class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HashSet-and-HashMap&quot;&gt;&lt;a href=&quot;#HashSet-and-HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashSet and HashMap&quot;&gt;&lt;/a&gt;HashSet and HashMap&lt;/h1&gt;&lt;h1 i
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍7-linkedhashset &amp; linkedhashmap</title>
    <link href="http://yoursite.com/2017/02/25/7-LinkedHashSet%20and%20LinkedHashMap/"/>
    <id>http://yoursite.com/2017/02/25/7-LinkedHashSet and LinkedHashMap/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T06:26:21.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LinkedHashSet-and-LinkedHashMap"><a href="#LinkedHashSet-and-LinkedHashMap" class="headerlink" title="LinkedHashSet and LinkedHashMap"></a>LinkedHashSet and LinkedHashMap</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>如果你已看过前面关于<em>HashSet</em>和<em>HashMap</em>，以及<em>TreeSet</em>和<em>TreeMap</em>的讲解，一定能够想到本文将要讲解的<em>LinkedHashSet</em>和<em>LinkedHashMap</em>其实也是一回事。<em>LinkedHashSet</em>和<em>LinkedHashMap</em>在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<strong><em>LinkedHashSet</em>里面有一个<em>LinkedHashMap</em>（适配器模式）</strong>。因此本文将重点分析<em>LinkedHashMap</em>。</p>
<p><em>LinkedHashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素。从名字上可以看出该容器是<em>linked list</em>和<em>HashMap</em>的混合体，也就是说它同时满足<em>HashMap</em>和<em>linked list</em>的某些特性。<strong>可将<em>LinkedHashMap</em>看作采用<em>linked list</em>增强的<em>HashMap</em>。</strong></p>
<p><img src="../PNGFigures/LinkedHashMap_base.png" alt="LinkedHashMap_base.png"></p>
<p>事实上<em>LinkedHashMap</em>是<em>HashMap</em>的直接子类，<strong>二者唯一的区别是<em>LinkedHashMap</em>在<em>HashMap</em>的基础上，采用双向链表（doubly-linked list）的形式将所有<code>entry</code>连接起来，这样是为保证元素的迭代顺序跟插入顺序相同</strong>。上图给出了<em>LinkedHashMap</em>的结构图，主体部分跟<em>HashMap</em>完全一样，多了<code>header</code>指向双向链表的头部（是一个哑元），<strong>该双向链表的迭代顺序就是<code>entry</code>的插入顺序</strong>。</p>
<p>除了可以保迭代历顺序，这种结构还有一个好处：<strong>迭代<em>LinkedHashMap</em>时不需要像<em>HashMap</em>那样遍历整个<code>table</code>，而只需要直接遍历<code>header</code>指向的双向链表即可</strong>，也就是说<em>LinkedHashMap</em>的迭代时间就只跟<code>entry</code>的个数相关，而跟<code>table</code>的大小无关。</p>
<p>有两个参数可以影响<em>LinkedHashMap</em>的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p>
<p>将对象放入到<em>LinkedHashMap</em>或<em>LinkedHashSet</em>中时，有两个方法需要特别关心：<code>hashCode()</code>和<code>equals()</code>。<strong><code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”</strong>。所以，如果要将自定义的对象放入到<code>LinkedHashMap</code>或<code>LinkedHashSet</code>中，需要<em>@Override</em><code>hashCode()</code>和<code>equals()</code>方法。</p>
<p>通过如下方式可以得到一个跟源<em>Map</em> <strong>迭代顺序</strong>一样的<em>LinkedHashMap</em>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Map m)</span> </span>&#123;</div><div class="line">    Map copy = <span class="keyword">new</span> LinkedHashMap(m);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>出于性能原因，<em>LinkedHashMap</em>是非同步的（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将<em>LinkedHashMap</em>包装成（wrapped）同步的：</p>
<p><code>Map m = Collections.synchronizedMap(new LinkedHashMap(...));</code></p>
<h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>。该方法跟<code>HashMap.get()</code>方法的流程几乎完全一样，读者可自行<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md#get" target="_blank" rel="external">参考前文</a>，这里不再赘述。</p>
<h2 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h2><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>get()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>。</p>
<p>注意，这里的<strong>插入有两重含义</strong>：</p>
<blockquote>
<ol>
<li>从<code>table</code>的角度看，新的<code>entry</code>需要插入到对应的<code>bucket</code>里，当有哈希冲突时，采用头插法将新的<code>entry</code>插入到冲突链表的头部。</li>
<li>从<code>header</code>的角度看，新的<code>entry</code>需要插入到双向链表的尾部。</li>
</ol>
</blockquote>
<p><img src="../PNGFigures/LinkedHashMap_addEntry.png" alt="LinkedHashMap_addEntry.png"></p>
<p><code>addEntry()</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LinkedHashMap.addEntry()</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</div><div class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">// 自动扩容，并重新哈希</span></div><div class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</div><div class="line">        bucketIndex = hash &amp; (table.length-<span class="number">1</span>);<span class="comment">// hash%table.length</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 1.在冲突链表头部插入新的entry</span></div><div class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</div><div class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, old);</div><div class="line">    table[bucketIndex] = e;</div><div class="line">    <span class="comment">// 2.在双向链表的尾部插入新的entry</span></div><div class="line">    e.addBefore(header);</div><div class="line">    size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中用到了<code>addBefore()</code>方法将新<code>entry e</code>插入到双向链表头引用<code>header</code>的前面，这样<code>e</code>就成为双向链表中的最后一个元素。<code>addBefore()</code>的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LinkedHashMap.Entry.addBefor()，将this插入到existingEntry的前面</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</div><div class="line">    after  = existingEntry;</div><div class="line">    before = existingEntry.before;</div><div class="line">    before.after = <span class="keyword">this</span>;</div><div class="line">    after.before = <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码只是简单修改相关<code>entry</code>的引用而已。</p>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到<code>key</code>值对应的<code>entry</code>，然后删除该<code>entry</code>（修改链表的相应引用）。查找过程跟<code>get()</code>方法类似。</p>
<p>注意，这里的<strong>删除也有两重含义</strong>：</p>
<blockquote>
<ol>
<li>从<code>table</code>的角度看，需要将该<code>entry</code>从对应的<code>bucket</code>里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。</li>
<li>从<code>header</code>的角度来看，需要将该<code>entry</code>从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。</li>
</ol>
</blockquote>
<p><img src="../PNGFigures/LinkedHashMap_removeEntryForKey.png" alt="LinkedHashMap_removeEntryForKey.png"></p>
<p><code>removeEntryForKey()</code>对应的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LinkedHashMap.removeEntryForKey()，删除key值对应的entry</span></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">	......</div><div class="line">	<span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">// hash&amp;(table.length-1)</span></div><div class="line">    Entry&lt;K,V&gt; prev = table[i];<span class="comment">// 得到冲突链表</span></div><div class="line">    Entry&lt;K,V&gt; e = prev;</div><div class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">// 遍历冲突链表</span></div><div class="line">        Entry&lt;K,V&gt; next = e.next;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<span class="comment">// 找到要删除的entry</span></div><div class="line">            modCount++; size--;</div><div class="line">            <span class="comment">// 1. 将e从对应bucket的冲突链表中删除</span></div><div class="line">            <span class="keyword">if</span> (prev == e) table[i] = next;</div><div class="line">            <span class="keyword">else</span> prev.next = next;</div><div class="line">            <span class="comment">// 2. 将e从双向链表中删除</span></div><div class="line">            e.before.after = e.after;</div><div class="line">            e.after.before = e.before;</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">        &#125;</div><div class="line">        prev = e; e = next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h1><p>前面已经说过<em>LinkedHashSet</em>是对<em>LinkedHashMap</em>的简单包装，对<em>LinkedHashSet</em>的函数调用都会转换成合适的<em>LinkedHashMap</em>方法，因此<em>LinkedHashSet</em>的实现非常简单，这里不再赘述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</div><div class="line">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</div><div class="line">    ......</div><div class="line">    <span class="comment">// LinkedHashSet里面有一个LinkedHashMap</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</div><div class="line">    &#125;</div><div class="line">	......</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//简单的方法转换</span></div><div class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LinkedHashSet-and-LinkedHashMap&quot;&gt;&lt;a href=&quot;#LinkedHashSet-and-LinkedHashMap&quot; class=&quot;headerlink&quot; title=&quot;LinkedHashSet and LinkedHashMa
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍9-WeakHashMap</title>
    <link href="http://yoursite.com/2017/02/25/9-WeakHashMap/"/>
    <id>http://yoursite.com/2017/02/25/9-WeakHashMap/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T06:27:03.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>在Java集合框架系列文章的最后，笔者打算介绍一个特殊的成员：<em>WeakHashMap</em>，从名字可以看出它是某种 <em>Map</em>。它的特殊之处在于 <em>WeakHashMap</em> 里的<code>entry</code>可能会被GC自动删除，即使程序员没有调用<code>remove()</code>或者<code>clear()</code>方法。</p>
<p>更直观的说，当使用 <em>WeakHashMap</em> 时，即使没有显示的添加或删除任何元素，也可能发生如下情况：</p>
<blockquote>
<ul>
<li>调用两次<code>size()</code>方法返回不同的值；</li>
<li>两次调用<code>isEmpty()</code>方法，第一次返回<code>false</code>，第二次返回<code>true</code>；</li>
<li>两次调用<code>containsKey()</code>方法，第一次返回<code>true</code>，第二次返回<code>false</code>，尽管两次使用的是同一个<code>key</code>；</li>
<li>两次调用<code>get()</code>方法，第一次返回一个<code>value</code>，第二次返回<code>null</code>，尽管两次使用的是同一个对象。</li>
</ul>
</blockquote>
<p>遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉？其实不然，<strong><em>WeekHashMap</em> 的这个特点特别适用于需要缓存的场景</strong>。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。</p>
<p>要明白 <em>WeekHashMap</em> 的工作原理，还需要引入一个概念：<strong>弱引用（WeakReference）</strong>。我们都知道Java中内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，<strong>是否有有效的引用指向该对象</strong>。如果没有有效引用指向该对象（基本意味着不存在访问该对象的方式），那么该对象就是可回收的。这里的<strong>“有效引用”</strong>并不包括<strong>弱引用</strong>。也就是说，<strong>虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收</strong>。</p>
<p><em>WeakHashMap</em> 内部是通过弱引用来管理<code>entry</code>的，弱引用的特性对应到 <em>WeakHashMap</em> 上意味着什么呢？<strong>将一对<code>key, value</code>放入到 <em>WeakHashMap</em> 里并不能避免该<code>key</code>值被GC回收，除非在 <em>WeakHashMap</em> 之外还有对该<code>key</code>的强引用</strong>。</p>
<p>关于强引用，弱引用等概念以后再具体讲解，这里只需要知道Java中引用也是分种类的，并且不同种类的引用对GC的影响不同就够了。</p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>WeakHashMap的存储结构类似于HashMap，读者可自行<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md" target="_blank" rel="external">参考前文</a>，这里不再赘述。</p>
<p>关于强弱引用的管理方式，博主将会另开专题单独讲解。</p>
<h1 id="Weak-HashSet"><a href="#Weak-HashSet" class="headerlink" title="Weak HashSet?"></a>Weak HashSet?</h1><p>如果你看过前几篇关于 <em>Map</em> 和 <em>Set</em> 的讲解，一定会问：既然有 <em>WeekHashMap</em>，是否有 <em>WeekHashSet</em> 呢？答案是没有:( 。不过Java <em>Collections</em>工具类给出了解决方案，<code>Collections.newSetFromMap(Map&lt;E,Boolean&gt; map)</code>方法可以将任何 <em>Map</em>包装成一个<em>Set</em>。通过如下方式可以快速得到一个 <em>Weak HashSet</em>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将WeakHashMap包装成一个Set</span></div><div class="line">Set&lt;Object&gt; weakHashSet = Collections.newSetFromMap(</div><div class="line">        <span class="keyword">new</span> WeakHashMap&lt;Object, Boolean&gt;());</div></pre></td></tr></table></figure>
<p>不出你所料，<code>newSetFromMap()</code>方法只是对传入的 <em>Map</em>做了简单包装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Collections.newSetFromMap()用于将任何Map包装成一个Set</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">newSetFromMap</span><span class="params">(Map&lt;E, Boolean&gt; map)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SetFromMap&lt;&gt;(map);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SetFromMap</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;E, Boolean&gt; m;  <span class="comment">// The backing map</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;E&gt; s;       <span class="comment">// Its keySet</span></div><div class="line">    SetFromMap(Map&lt;E, Boolean&gt; map) &#123;</div><div class="line">        <span class="keyword">if</span> (!map.isEmpty())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Map is non-empty"</span>);</div><div class="line">        m = map;</div><div class="line">        s = map.keySet();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123;        m.clear(); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> m.size(); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> m.isEmpty(); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> m.containsKey(o); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span>   </span>&#123; <span class="keyword">return</span> m.remove(o) != <span class="keyword">null</span>; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123; <span class="keyword">return</span> m.put(e, Boolean.TRUE) == <span class="keyword">null</span>; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> s.iterator(); &#125;</div><div class="line">    <span class="keyword">public</span> Object[] toArray()         &#123; <span class="keyword">return</span> s.toArray(); &#125;</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a)     &#123; <span class="keyword">return</span> s.toArray(a); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> s.toString(); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>             </span>&#123; <span class="keyword">return</span> s.hashCode(); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span>   </span>&#123; <span class="keyword">return</span> o == <span class="keyword">this</span> || s.equals(o); &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;<span class="keyword">return</span> s.containsAll(c);&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>   </span>&#123;<span class="keyword">return</span> s.removeAll(c);&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>   </span>&#123;<span class="keyword">return</span> s.retainAll(c);&#125;</div><div class="line">    <span class="comment">// addAll is the only inherited implementation</span></div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>至此<em>Java Collections Framework Internals</em>系列已经全部讲解完毕，希望这几篇简短的博文能够帮助各位读者对Java容器框架建立基本的理解。通过这里可以返回<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/0-Introduction.md" target="_blank" rel="external">本系列文章目录</a></p>
<p>如果对各位有哪怕些微的帮助，博主将感到非常高兴！如果博文中有任何的纰漏和谬误，欢迎各位博友指正。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;WeakHashMap&quot;&gt;&lt;a href=&quot;#WeakHashMap&quot; class=&quot;headerlink&quot; title=&quot;WeakHashMap&quot;&gt;&lt;/a&gt;WeakHashMap&lt;/h1&gt;&lt;h1 id=&quot;总体介绍&quot;&gt;&lt;a href=&quot;#总体介绍&quot; class=&quot;
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍4-stack&amp;queue</title>
    <link href="http://yoursite.com/2017/02/25/4-Stack%20and%20Queue/"/>
    <id>http://yoursite.com/2017/02/25/4-Stack and Queue/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T06:24:51.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stack-and-Queue"><a href="#Stack-and-Queue" class="headerlink" title="Stack and Queue"></a>Stack and Queue</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java里有一个叫做<em>Stack</em>的类，却没有叫做<em>Queue</em>的类（它是个接口名字）。当需要使用栈时，Java已不推荐使用<em>Stack</em>，而是推荐使用更高效的<em>ArrayDeque</em>；既然<em>Queue</em>只是一个接口，当需要使用队列时也就首选<em>ArrayDeque</em>了（次选是<em>LinkedList</em>）。</p>
<h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>要讲栈和队列，首先要讲<em>Deque</em>接口。<em>Deque</em>的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了<em>Deque</em>与<em>Queue</em>相对应的接口：</p>
<table>
<thead>
<tr>
<th>Queue Method</th>
<th>Equivalent Deque Method</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add(e)</code></td>
<td><code>addLast(e)</code></td>
<td>向队尾插入元素，失败则抛出异常</td>
</tr>
<tr>
<td><code>offer(e)</code></td>
<td><code>offerLast(e)</code></td>
<td>向队尾插入元素，失败则返回<code>false</code></td>
</tr>
<tr>
<td><code>remove()</code></td>
<td><code>removeFirst()</code></td>
<td>获取并删除队首元素，失败则抛出异常</td>
</tr>
<tr>
<td><code>poll()</code></td>
<td><code>pollFirst()</code></td>
<td>获取并删除队首元素，失败则返回<code>null</code></td>
</tr>
<tr>
<td><code>element()</code></td>
<td><code>getFirst()</code></td>
<td>获取但不删除队首元素，失败则抛出异常</td>
</tr>
<tr>
<td><code>peek()</code></td>
<td><code>peekFirst()</code></td>
<td>获取但不删除队首元素，失败则返回<code>null</code></td>
</tr>
</tbody>
</table>
<p>下表列出了<em>Deque</em>与<em>Stack</em>对应的接口：</p>
<table>
<thead>
<tr>
<th>Stack Method</th>
<th>Equivalent Deque Method</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>push(e)</code></td>
<td><code>addFirst(e)</code></td>
<td>向栈顶插入元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td><code>offerFirst(e)</code></td>
<td>向栈顶插入元素，失败则返回<code>false</code></td>
</tr>
<tr>
<td><code>pop()</code></td>
<td><code>removeFirst()</code></td>
<td>获取并删除栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td><code>pollFirst()</code></td>
<td>获取并删除栈顶元素，失败则返回<code>null</code></td>
</tr>
<tr>
<td><code>peek()</code></td>
<td><code>peekFirst()</code></td>
<td>获取但不删除栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td><code>peekFirst()</code></td>
<td>获取但不删除栈顶元素，失败则返回<code>null</code></td>
</tr>
</tbody>
</table>
<p>上面两个表共定义了<em>Deque</em>的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。<strong>一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值（<code>false</code>或<code>null</code>）</strong>。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。<strong>虽然<em>Deque</em>的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看</strong>。明白了这一点讲解起来就会非常简单。</p>
<p><em>ArrayDeque</em>和<em>LinkedList</em>是<em>Deque</em>的两个通用实现，由于官方更推荐使用<em>AarryDeque</em>用作栈和队列，加之上一篇已经讲解过<em>LinkedList</em>，本文将着重讲解<em>ArrayDeque</em>的具体实现。</p>
<p>从名字可以看出<em>ArrayDeque</em>底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即<strong>循环数组（circular array）</strong>，也就是说数组的任何一点都可能被看作起点或者终点。<em>ArrayDeque</em>是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入<code>null</code>元素。</p>
<p><img src="../PNGFigures/ArrayDeque_base.png" alt="ArrayDeque_base.png"></p>
<p>上图中我们看到，<strong><code>head</code>指向首端第一个有效元素，<code>tail</code>指向尾端第一个可以插入元素的空位</strong>。因为是循环数组，所以<code>head</code>不一定总等于0，<code>tail</code>也不一定总是比<code>head</code>大。</p>
<h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst()"></a>addFirst()</h2><p><code>addFirst(E e)</code>的作用是在<em>Deque</em>的首端插入元素，也就是在<code>head</code>的前面插入元素，在空间足够且下标没有越界的情况下，只需要将<code>elements[--head] = e</code>即可。</p>
<p><img src="../PNGFigures/ArrayDeque_addFirst.png" alt="ArrayDeque_addFirst.png"></p>
<p>实际需要考虑：1.空间是否够用，以及2.下标是否越界的问题。上图中，如果<code>head</code>为<code>0</code>之后接着调用<code>addFirst()</code>，虽然空余空间还够用，但<code>head</code>为<code>-1</code>，下标越界了。下列代码很好的解决了这两个问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//addFirst(E e)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//不允许放入null</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;<span class="comment">//2.下标是否越界</span></div><div class="line">    <span class="keyword">if</span> (head == tail)<span class="comment">//1.空间是否够用</span></div><div class="line">        doubleCapacity();<span class="comment">//扩容</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码我们看到，<strong>空间问题是在插入之后解决的</strong>，因为<code>tail</code>总是指向下一个可插入的空位，也就意味着<code>elements</code>数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p>
<p>下标越界的处理解决起来非常简单，<code>head = (head - 1) &amp; (elements.length - 1)</code>就可以了，<strong>这段代码相当于取余，同时解决了<code>head</code>为负值的情况</strong>。因为<code>elements.length</code>必需是<code>2</code>的指数倍，<code>elements - 1</code>就是二进制低位全<code>1</code>，跟<code>head - 1</code>相与之后就起到了取模的作用，如果<code>head - 1</code>为负数（其实只可能是-1），则相当于对其取相对于<code>elements.length</code>的补码。</p>
<p>下面再说说扩容函数<code>doubleCapacity()</code>，其逻辑是申请一个更大的数组（原数组的两倍），然后将原数组复制过去。过程如下图所示：</p>
<p><img src="../PNGFigures/ArrayDeque_doubleCapacity.png" alt="ArrayDeque_doubleCapacity.png"></p>
<p>图中我们看到，复制分两次进行，第一次复制<code>head</code>右边的元素，第二次复制<code>head</code>左边的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//doubleCapacity()</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doubleCapacity</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> head == tail;</div><div class="line">    <span class="keyword">int</span> p = head;</div><div class="line">    <span class="keyword">int</span> n = elements.length;</div><div class="line">    <span class="keyword">int</span> r = n - p; <span class="comment">// head右边元素的个数</span></div><div class="line">    <span class="keyword">int</span> newCapacity = n &lt;&lt; <span class="number">1</span>;<span class="comment">//原空间的2倍</span></div><div class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Sorry, deque too big"</span>);</div><div class="line">    Object[] a = <span class="keyword">new</span> Object[newCapacity];</div><div class="line">    System.arraycopy(elements, p, a, <span class="number">0</span>, r);<span class="comment">//复制右半部分，对应上图中绿色部分</span></div><div class="line">    System.arraycopy(elements, <span class="number">0</span>, a, r, p);<span class="comment">//复制左半部分，对应上图中灰色部分</span></div><div class="line">    elements = (E[])a;</div><div class="line">    head = <span class="number">0</span>;</div><div class="line">    tail = n;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="addLast"><a href="#addLast" class="headerlink" title="addLast()"></a>addLast()</h2><p><code>addLast(E e)</code>的作用是在<em>Deque</em>的尾端插入元素，也就是在<code>tail</code>的位置插入元素，由于<code>tail</code>总是指向下一个可以插入的空位，因此只需要<code>elements[tail] = e;</code>即可。插入完成后再检查空间，如果空间已经用光，则调用<code>doubleCapacity()</code>进行扩容。</p>
<p><img src="../PNGFigures/ArrayDeque_addLast.png" alt="ArrayDeque_addLast.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//不允许放入null</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    elements[tail] = e;<span class="comment">//赋值</span></div><div class="line">    <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)<span class="comment">//下标越界处理</span></div><div class="line">        doubleCapacity();<span class="comment">//扩容</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下标越界处理方式<code>addFirt()</code>中已经讲过，不再赘述。</p>
<h2 id="pollFirst"><a href="#pollFirst" class="headerlink" title="pollFirst()"></a>pollFirst()</h2><p><code>pollFirst()</code>的作用是删除并返回<em>Deque</em>首端元素，也即是<code>head</code>位置处的元素。如果容器不空，只需要直接返回<code>elements[head]</code>即可，当然还需要处理下标的问题。由于<code>ArrayDeque</code>中不允许放入<code>null</code>，当<code>elements[head] == null</code>时，意味着容器为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">    E result = elements[head];</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)<span class="comment">//null值意味着deque为空</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    elements[h] = <span class="keyword">null</span>;<span class="comment">//let GC work</span></div><div class="line">    head = (head + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);<span class="comment">//下标越界处理</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="pollLast"><a href="#pollLast" class="headerlink" title="pollLast()"></a>pollLast()</h2><p><code>pollLast()</code>的作用是删除并返回<em>Deque</em>尾端元素，也即是<code>tail</code>位置前面的那个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> t = (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);<span class="comment">//tail的上一个位置是最后一个元素</span></div><div class="line">    E result = elements[t];</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)<span class="comment">//null值意味着deque为空</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    elements[t] = <span class="keyword">null</span>;<span class="comment">//let GC work</span></div><div class="line">    tail = t;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="peekFirst"><a href="#peekFirst" class="headerlink" title="peekFirst()"></a>peekFirst()</h2><p><code>peekFirst()</code>的作用是返回但不删除<em>Deque</em>首端元素，也即是<code>head</code>位置处的元素，直接返回<code>elements[head]</code>即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> elements[head]; <span class="comment">// elements[head] is null if deque empty</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="peekLast"><a href="#peekLast" class="headerlink" title="peekLast()"></a>peekLast()</h2><p><code>peekLast()</code>的作用是返回但不删除<em>Deque</em>尾端元素，也即是<code>tail</code>位置前面的那个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> elements[(tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Stack-and-Queue&quot;&gt;&lt;a href=&quot;#Stack-and-Queue&quot; class=&quot;headerlink&quot; title=&quot;Stack and Queue&quot;&gt;&lt;/a&gt;Stack and Queue&lt;/h1&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍8-PriorityQueue</title>
    <link href="http://yoursite.com/2017/02/25/8-PriorityQueue/"/>
    <id>http://yoursite.com/2017/02/25/8-PriorityQueue/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T06:26:41.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h1><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>前面以Java <em>ArrayDeque</em>为例讲解了<em>Stack</em>和<em>Queue</em>，其实还有一种特殊的队列叫做<em>PriorityQueue</em>，即优先队列。<strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，<strong>元素大小的评判可以通过元素本身的自然顺序（<em>natural ordering</em>），也可以通过构造时传入的比较器</strong>（<em>Comparator</em>，类似于C++的仿函数）。</p>
<p>Java中<em>PriorityQueue</em>实现了<em>Queue</em>接口，不允许放入<code>null</code>元素；其通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为<em>PriorityQueue</em>的底层实现。</p>
<p><img src="../PNGFigures/PriorityQueue_base.png" alt="PriorityQueue_base.png"></p>
<p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：</p>
<p><code>leftNo = parentNo*2+1</code></p>
<p><code>rightNo = parentNo*2+2</code></p>
<p><code>parentNo = (nodeNo-1)/2</code></p>
<p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p>
<p><em>PriorityQueue</em>的<code>peek()</code>和<code>element</code>操作是常数时间，<code>add()</code>, <code>offer()</code>, 无参数的<code>remove()</code>以及<code>poll()</code>方法的时间复杂度都是<em>log(N)</em>。</p>
<h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="add-和offer"><a href="#add-和offer" class="headerlink" title="add()和offer()"></a>add()和offer()</h2><p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是<code>Queue</code>接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回<code>false</code>。对于<em>PriorityQueue</em>这两个方法其实没什么差别。</p>
<p><img src="../PNGFigures/PriorityQueue_offer.png" alt="PriorityQueue_offer.png"></p>
<p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//offer(E e)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//不允许放入null元素</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">int</span> i = size;</div><div class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</div><div class="line">        grow(i + <span class="number">1</span>);<span class="comment">//自动扩容</span></div><div class="line">    size = i + <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)<span class="comment">//队列原来为空，这是插入的第一个元素</span></div><div class="line">        queue[<span class="number">0</span>] = e;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        siftUp(i, e);<span class="comment">//调整</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中，扩容函数<code>grow()</code>类似于<code>ArrayList</code>里的<code>grow()</code>函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是<code>siftUp(int k, E x)</code>方法，该方法用于插入元素<code>x</code>并维持堆的特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//siftUp()</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">//parentNo = (nodeNo-1)/2</span></div><div class="line">        Object e = queue[parent];</div><div class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)<span class="comment">//调用比较器的比较方法</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        queue[k] = e;</div><div class="line">        k = parent;</div><div class="line">    &#125;</div><div class="line">    queue[k] = x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>新加入的元素<code>x</code>可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层与当前点的<code>parent</code>进行比较并交换，直到满足<code>x &gt;= queue[parent]</code>为止</strong>。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p>
<h2 id="element-和peek"><a href="#element-和peek" class="headerlink" title="element()和peek()"></a>element()和peek()</h2><p><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回<code>null</code>。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，<code>0</code>下标处的那个元素既是堆顶元素。所以<strong>直接返回数组<code>0</code>下标处的那个元素即可</strong>。</p>
<p><img src="../PNGFigures/PriorityQueue_peek.png" alt="PriorityQueue_peek.png"></p>
<p>代码也就非常简洁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//peek()</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">return</span> (E) queue[<span class="number">0</span>];<span class="comment">//0下标处的那个元素就是最小的那个</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="remove-和poll"><a href="#remove-和poll" class="headerlink" title="remove()和poll()"></a>remove()和poll()</h2><p><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p>
<p><img src="../PNGFigures/PriorityQueue_poll.png" alt="PriorityQueue_poll.png"><br>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> s = --size;</div><div class="line">    modCount++;</div><div class="line">    E result = (E) queue[<span class="number">0</span>];<span class="comment">//0下标处的那个元素就是最小的那个</span></div><div class="line">    E x = (E) queue[s];</div><div class="line">    queue[s] = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</div><div class="line">        siftDown(<span class="number">0</span>, x);<span class="comment">//调整</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码首先记录<code>0</code>下标处的元素，并用最后一个元素替换<code>0</code>下标位置的元素，之后调用<code>siftDown()</code>方法对堆进行调整，最后返回原来<code>0</code>下标处的那个元素（也就是最小的那个元素）。重点是<code>siftDown(int k, E x)</code>方法，该方法的作用是<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层向下与当前点的左右孩子中较小的那个交换，直到<code>x</code>小于或等于左右孩子中的任何一个为止</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//siftDown()</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</div><div class="line">    	<span class="comment">//首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span></div><div class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;<span class="comment">//leftNo = parentNo*2+1</span></div><div class="line">        Object c = queue[child];</div><div class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</div><div class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</div><div class="line">            c = queue[child = right];</div><div class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        queue[k] = c;<span class="comment">//然后用c取代原来的值</span></div><div class="line">        k = child;</div><div class="line">    &#125;</div><div class="line">    queue[k] = x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h2><p><code>remove(Object o)</code>方法用于删除队列中跟<code>o</code>相等的某一个元素（如果有多个相等，只删除一个），该方法不是<em>Queue</em>接口内的方法，而是<em>Collection</em>接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次<code>siftDown()</code>即可。此处不再赘述。</p>
<p><img src="../PNGFigures/PriorityQueue_remove2.png" alt="PriorityQueue_remove2.png"></p>
<p>具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//remove(Object o)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">	<span class="comment">//通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span></div><div class="line">    <span class="keyword">int</span> i = indexOf(o);</div><div class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span> s = --size;</div><div class="line">    <span class="keyword">if</span> (s == i) <span class="comment">//情况1</span></div><div class="line">        queue[i] = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        E moved = (E) queue[s];</div><div class="line">        queue[s] = <span class="keyword">null</span>;</div><div class="line">        siftDown(i, moved);<span class="comment">//情况2</span></div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PriorityQueue&quot;&gt;&lt;a href=&quot;#PriorityQueue&quot; class=&quot;headerlink&quot; title=&quot;PriorityQueue&quot;&gt;&lt;/a&gt;PriorityQueue&lt;/h1&gt;&lt;h1 id=&quot;总体介绍&quot;&gt;&lt;a href=&quot;#总体介绍&quot;
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
  <entry>
    <title>jcf介绍12-iterator</title>
    <link href="http://yoursite.com/2017/02/25/12-iterator/"/>
    <id>http://yoursite.com/2017/02/25/12-iterator/</id>
    <published>2017-02-25T12:52:12.000Z</published>
    <updated>2017-02-25T07:18:10.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h1><p>转载:<a href="http://www.cnblogs.com/skywang12345/p/3310887.html" target="_blank" rel="external">http://www.cnblogs.com/skywang12345/p/3310887.html</a></p>
<h4 id="Iterator和Enumeration区别"><a href="#Iterator和Enumeration区别" class="headerlink" title="Iterator和Enumeration区别"></a>Iterator和Enumeration区别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.util;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Enumeration</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">nextElement</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">package</span> java.util;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(01) 函数接口不同</p>
<pre><code>Enumeration只有2个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。
Iterator只有3个函数接口。Iterator除了能读取集合的数据之外，也能数据进行删除操作。
</code></pre><p>(02) Iterator支持fail-fast机制，而Enumeration不支持。</p>
<pre><code>Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK 1.0中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步。
而Iterator 是JDK 1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iterator&quot;&gt;&lt;a href=&quot;#iterator&quot; class=&quot;headerlink&quot; title=&quot;iterator&quot;&gt;&lt;/a&gt;iterator&lt;/h1&gt;&lt;p&gt;转载:&lt;a href=&quot;http://www.cnblogs.com/skywang1234
    
    </summary>
    
      <category term="jcf" scheme="http://yoursite.com/categories/jcf/"/>
    
    
      <category term="jcf" scheme="http://yoursite.com/tags/jcf/"/>
    
  </entry>
  
</feed>
