<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="lyp's blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.jpg?v=5.0.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="lyp's blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="lyp's blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lyp's blog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '3188510942',
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/2/"/>


  <title> lyp's blog </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">lyp's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            Kategorien
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/10/effective-java-1/" itemprop="url">
                  effective-java-1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-11-10T09:51:23+08:00" content="2016-11-10">
              2016-11-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第0-0条：java-unit"><a href="#第0-0条：java-unit" class="headerlink" title="第0.0条：java unit"></a>第0.0条：java unit</h3><p>javac hello.java<br>java hello</p>
<p>A unit test tests the methods in<br>a single class</p>
<p> A test case tests (insofar as<br>possible) a single method</p>
<p> You can have multiple test<br>cases for a single method</p>
<p> A test suite combines unit tests</p>
<p> The test fixture provides<br>software support for all this</p>
<p> The test runner runs unit tests<br>or an entire test suite</p>
<p> Integration testing (testing that<br>it all works together) is not well<br>supported by JUnit</p>
<p>static void assertFalse(boolean test)<br>static void assertFalse(String message, boolean test)</p>
<p>assertEquals(expected, actual)<br>assertEquals(String message, expected, actual)</p>
<p>assertSame(Object expected, Object actual)<br>assertSame(String message, Object expected, Object actual)</p>
<p>assertNotSame(Object expected, Object actual)<br>assertNotSame(String message, Object expected, Object actual)</p>
<p>assertNull(Object object)<br>assertNull(String message, Object object)</p>
<p>fail()<br>fail(String message)</p>
<p>@BeforeClass</p>
<p>@AfterClass</p>
<p>@Test (timeout=10)</p>
<p>@Test (expected=IllegalArgumentException.class)</p>
<p>创建一个 TestSuite.java，打包运行多个 JUnit 测试类</p>
<pre><code>@RunWith(Suite.class)
@SuiteClasses({XXTest.class, XXTest.class})
public class TestSuite{
}
</code></pre><p>junit实验手册：</p>
<p>1.测试驱动开发。<br>2.hamcrest(hamcrest可以用来增强junit中assert功能)<br>3.cobertura 单元测试覆盖率<br>mvn compile/test/cobertura:cobertura</p>
<h3 id="第0-1条：maven"><a href="#第0-1条：maven" class="headerlink" title="第0.1条：maven"></a>第0.1条：maven</h3><p>maven compile</p>
<p>maven test</p>
<p>mvn clean</p>
<p>mvn package</p>
<p>mvn install</p>
<h3 id="第0-2条：svn"><a href="#第0-2条：svn" class="headerlink" title="第0.2条：svn"></a>第0.2条：svn</h3><p>repository:<br>project code is stored in a server in a data store referred to as a “repository”;</p>
<p>check out:<br>Developers “check out” copies of the project code into<br>their local environments. These copies are referred to<br>as “working copies.”</p>
<p>commits:<br>After making changes to a working copy, the<br>developer “commits” changes to the repository.</p>
<p>updating:<br>Other developers get these changes by “updating”<br>their working copies.</p>
<h3 id="第0-3条：git"><a href="#第0-3条：git" class="headerlink" title="第0.3条：git"></a>第0.3条：git</h3><ul>
<li>git config –global user.name “ss”</li>
<li>git config –global user.mail “ss@mail.com”</li>
<li>git clone</li>
<li>git init  //创建版本库</li>
<li>git add file.java //文件添加到版本库</li>
<li>git commit -m “initial project version” //提交到本地</li>
<li>git status (-s) //查看仓库当前状态</li>
<li>git diff a.txt //比较文件修改变化</li>
<li>git help</li>
<li>git pull</li>
<li>git push</li>
<li>git log //查看历史修改记录</li>
<li>git log –oneline</li>
<li>git log -5</li>
<li>git pull origin master</li>
<li>git push origin master</li>
<li>git branch experimental//创建分支</li>
<li>git branch //查看当前分支</li>
<li>git checkout -b experimental //创建并切换分支，-b标识创建并且换</li>
<li>git checkout master //切换到某个分支</li>
<li>git merge experimental //合并分支到master</li>
<li>git branch -d dev //删除分支</li>
<li>git log –graph</li>
<li>git reset –hard HEAD^ //回退到上一个版本</li>
<li>git reset –hard HEAD^^ //回退到上两个版本</li>
<li>git reset –hard 3628164 //回退到指定版本</li>
<li>git rm a.txt //删除</li>
<li>git tag v1.0</li>
<li>git tag</li>
<li>git tag v0.9 6224937</li>
<li>git show v0.9</li>
</ul>
<p>svn：<br>中央存储库方法，主仓库是真正的source，只有主仓库有完成的文件历史。<br>用户检出当前版本的本地副本。</p>
<p>git：<br>分布式存储库方法：每次检出的存储库都是一个完成的存储库，有完整的历史。更多的荣誉和速度，分支和合并库更频繁使用。</p>
<p>主要区别：<br>1.git是分布式的，svn不是。<br>2.git把内容按照元数据方式存储，svn是按照文件。<br>3.git没有全局版本号，svn有<br>4.git的内容完整性优于svn，git的内容存储用的是sha-1哈希算法，这能确保代码内容的完整性。<br>5.git离线可以看所有的log，svn不可以。</p>
<h3 id="第0-4条：logging-vs-debugging"><a href="#第0-4条：logging-vs-debugging" class="headerlink" title="第0.4条：logging vs debugging"></a>第0.4条：logging vs debugging</h3><p>Logging is faster than using a debugger<br>• Logging can be used to diagnose problems<br>in the production stage as well as during<br>development<br>• Logging is easier than debugging in a<br>distributed computing environment<br>• To use logging as debugging tool we need<br>to record lots of events</p>
<p>log4j:reliability, speed and flexibility.</p>
<p>优先级：DEBUG, INFO, WARN, ERROR, FATAL</p>
<pre><code>import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.SimpleLayout;
import org.apache.log4j.FileAppender;
public class simpandfile {
   static Logger logger = Logger.getLogger(simpandfile.class);
   public static void main(String args[]) {
      SimpleLayout layout = new SimpleLayout();

      FileAppender appender = null;
      try {
         appender = new FileAppender(layout,&quot;output1.txt&quot;,false);
      } catch(Exception e) {}

      logger.addAppender(appender);
      logger.setLevel((Level) Level.DEBUG);

      logger.debug(&quot;Here is some DEBUG&quot;);
      logger.info(&quot;Here is some INFO&quot;);
      logger.warn(&quot;Here is some WARN&quot;);
      logger.error(&quot;Here is some ERROR&quot;);
      logger.fatal(&quot;Here is some FATAL&quot;);
   }
}
</code></pre><h3 id="第0-5条：wildcards"><a href="#第0-5条：wildcards" class="headerlink" title="第0.5条：wildcards"></a>第0.5条：wildcards</h3><pre><code>public &lt;T extends Animal&gt; void takeThing(ArrayList&lt;T&gt; list)

public void takeThing(ArrayList&lt;? extends Animal&gt; list)
</code></pre><hr>
<h3 id="第9条：覆盖equals总要覆盖hashcode"><a href="#第9条：覆盖equals总要覆盖hashcode" class="headerlink" title="第9条：覆盖equals总要覆盖hashcode"></a>第9条：覆盖equals总要覆盖hashcode</h3><p>object规范：</p>
<ul>
<li><p>在应用程序执行期间，只要对象的equals方法的比较操作所用到的 信息没有被修改，那么对于着同一个对象调用多次，hashcode必须始终如意的返回同一个证书。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。</p>
</li>
<li><p>如果两个对象根据equals（object）方法比较是相等的，那么调用这两个对象任意一个对象的hashcode都必须能产生相同的整数结果。</p>
</li>
<li><p>度过两个对象根据equals（object）比较不相等，那么hashcode不一定不相等。</p>
</li>
</ul>
<h3 id="第10条：始终要覆盖tostring"><a href="#第10条：始终要覆盖tostring" class="headerlink" title="第10条：始终要覆盖tostring"></a>第10条：始终要覆盖tostring</h3><p>默认实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> getClass().getName()+<span class="string">'@'</span>+Integer.toHexString(hashCode))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="第11条：谨慎的覆盖clone"><a href="#第11条：谨慎的覆盖clone" class="headerlink" title="第11条：谨慎的覆盖clone"></a>第11条：谨慎的覆盖clone</h3><p>约定（弱的）</p>
<ul>
<li>Create a copy such that x.clone() != x</li>
<li>x.clone().getClass() == x.getClass()</li>
<li>Should have x.clone().equals(x)</li>
<li>No constructors are called</li>
</ul>
<p>拷贝构造器</p>
<p>拷贝工厂</p>
<h3 id="第12条：考虑实现Comparable接口"><a href="#第12条：考虑实现Comparable接口" class="headerlink" title="第12条：考虑实现Comparable接口"></a>第12条：考虑实现Comparable接口</h3><p>约定：</p>
<ul>
<li>1) Returns negative, zero, or positive depending on order<br>of this and specified object</li>
<li>2) sgn(x.compareTo(y) == -sgn(y.compareTo(x))</li>
<li>3) compareTo() must be transitive（可传递的）</li>
<li>4) If x.compareTo(y) == 0, x and y must consistently<br>compare to all values z.<br>(ps:x.compareTo(y)==0暗示着所有z都满足sgn(x,compareTo(z))=sgn(y.compareTo(z)))</li>
<li>5) Recommended that x.compareTo(y) == 0 iff<br>x.equals(y)</li>
<li>6) Note that compareTo() can throw<br>ClassCastExceptions</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//This is horrible!</span></div><div class="line">Object x = <span class="keyword">new</span> BigDecimal(“<span class="number">1.0</span>”);</div><div class="line">Object y = <span class="keyword">new</span> BigDecimal(“<span class="number">1.00</span>”);</div><div class="line"><span class="comment">// !x.equals(y), but x.compareTo(y) == 0</span></div><div class="line">Set s = <span class="keyword">new</span> HashSet();</div><div class="line">Set t = <span class="keyword">new</span> TreeSet();</div><div class="line">s.add(x); s.add(y);</div><div class="line"><span class="comment">// HashSet uses equals, so s has 2 elements</span></div><div class="line">t.add(x); t.add(y);</div><div class="line"><span class="comment">// TreeSet uses compareTo, so t has 1 element</span></div></pre></td></tr></table></figure>
<h3 id="第13条：使类和成员的可访问性最小化"><a href="#第13条：使类和成员的可访问性最小化" class="headerlink" title="第13条：使类和成员的可访问性最小化"></a>第13条：使类和成员的可访问性最小化</h3><p>Standard list of accessibility levels</p>
<ul>
<li> private</li>
<li> package-private (aka package friendly)</li>
<li> protected</li>
<li> public</li>
</ul>
<p>Huge difference between 2nd and 3rd</p>
<ul>
<li> package-private: part of implementation</li>
<li> protected: part of public AP</li>
</ul>
<h3 id="第14条：在共有类中使用访问方法而非公有域"><a href="#第14条：在共有类中使用访问方法而非公有域" class="headerlink" title="第14条：在共有类中使用访问方法而非公有域"></a>第14条：在共有类中使用访问方法而非公有域</h3><p>1.公有类永远不应该暴露可变的域</p>
<p>2.让公有类暴露不可变的域危害较小</p>
<blockquote>
<p>  危害：</p>
<pre><code>Wrong – Potential Security Hole:
public static final Type[] VALUES = {…};
 Problem:
 VALUES is final; entries in VALUES are not!
</code></pre><p>  解决方案：</p>
<pre><code>private static final Type[] PRIVATE_VALUES = {…};
public static final List VALUES =
Collections.unmodifiableList(Arrays.asList
(PRIVATE_VALUES));
 Also Correct:
private static final Type[] PRIVATE_VALUES = {…};
public static final Type[] values() {
return (Type[]) PRIVATE_VALUES.clone();
}
</code></pre></blockquote>
<h3 id="第15条：使可变性最小化"><a href="#第15条：使可变性最小化" class="headerlink" title="第15条：使可变性最小化"></a>第15条：使可变性最小化</h3><p>不可变类：一个对象被考虑是不可变的，如果他的状态不能改变在他被创建以后。</p>
<blockquote>
<p>An object is considered immutable if its state<br>cannot change after it is constructed.</p>
<p> e.g String, Integer, BigInteger, BigDecimal</p>
</blockquote>
<p>使一个类成为不可变类的原因：</p>
<ol>
<li>Thread safe inherently</li>
<li>Can be shared freely</li>
<li>No need to make defensive copy</li>
<li>Its internals can also be shared</li>
<li><p>Great building blocks for other object</p>
<p>  Great to be map keys and set elements</p>
</li>
</ol>
<p>定义不可变类的策略</p>
<ul>
<li>1) Don’t provide any mutators（增变因子） (“setter” methods)</li>
<li>2) Make all fields final and private</li>
<li>3) Don’t allow subclasses to override methods.</li>
<li>4) If the instance fields include references to<br>mutable objects, don’t allow those objects to<br>be changed:<ul>
<li> Don’t provide methods that modify the mutable<br>objects.</li>
<li> Don’t share references to the mutable objects. </li>
</ul>
</li>
</ul>
<p>性能问题：</p>
<p>Example in Java Library:</p>
<ul>
<li> String (Immutable)</li>
<li> StringBuilder (Companion Mutable Class)</li>
<li> StringBuffer (Deprecated Companion Mutable Class)</li>
</ul>
<h3 id="第16条：复合优先于集成"><a href="#第16条：复合优先于集成" class="headerlink" title="第16条：复合优先于集成"></a>第16条：复合优先于集成</h3><p>hashset内部中addall方法是基于他的add方法实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentedSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;E&gt; s;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> addCount = <span class="number">0</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InstrumentedSet</span> <span class="params">(Set&lt;E&gt; s)</span> </span>&#123; <span class="keyword">this</span>.s = s&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E o)</span> </span>&#123;</div><div class="line">		addCount++; <span class="keyword">return</span> s.add(o); &#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span> <span class="params">(Collection&lt;? extends E&gt; c)</span></span>&#123;</div><div class="line">		addCount += c.size();</div><div class="line">		<span class="keyword">return</span> s.addAll(c);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// forwarded methods from Set interface</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="第17条：要么为集成而设计，并提供文档说明，要么就禁止继承"><a href="#第17条：要么为集成而设计，并提供文档说明，要么就禁止继承" class="headerlink" title="第17条：要么为集成而设计，并提供文档说明，要么就禁止继承"></a>第17条：要么为集成而设计，并提供文档说明，要么就禁止继承</h3><ul>
<li>对于为了继承而设计的类，唯一的测试方法就是编写子类。</li>
<li>构造器决不能调用可被覆盖的方法。</li>
</ul>
<h3 id="第18条：接口优于抽象类"><a href="#第18条：接口优于抽象类" class="headerlink" title="第18条：接口优于抽象类"></a>第18条：接口优于抽象类</h3><p>区别：<br>1.抽象类包含某些方法的实现。接口不允许<br>2.java单继承，所以抽象类收到了极大的限制，</p>
<p>接口优点：</p>
<ul>
<li>现有的类可以很容易被更新，以实现新的接口。</li>
<li>接口是定义mixin（混合类型）的理想选择。</li>
<li>接口允许我们构建非层次结构的类型框架。</li>
</ul>
<p>接口缺点：</p>
<ul>
<li>Sometimes too tedious to use</li>
<li>You have to implement a dozen methods before you can create an object </li>
</ul>
<p>抽象类优点：</p>
<ul>
<li>It is far easier to evolve an abstract<br>class than an interface<ul>
<li> It is relatively easy to add a new method<br>to an abstract class</li>
<li> But almost impossible to add a method to<br>a public interface</li>
<li> Should be very carefully to design public<br>interfaces</li>
</ul>
</li>
</ul>
<h3 id="第19条：接口只用于定义类型"><a href="#第19条：接口只用于定义类型" class="headerlink" title="第19条：接口只用于定义类型"></a>第19条：接口只用于定义类型</h3><p>使用枚举类型 工具类，不要使用常量接口</p>
<h3 id="第20条：类层次优于标签类"><a href="#第20条：类层次优于标签类" class="headerlink" title="第20条：类层次优于标签类"></a>第20条：类层次优于标签类</h3><p>对于标签类，好的方法是使用继承</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Class hierarchy replacement for a tagged class</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Figure</span> </span>&#123; <span class="comment">// Note: NOT instantiable!</span></div><div class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Figure</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> <span class="keyword">double</span> radius;</div><div class="line">Circle(<span class="keyword">double</span> rad) &#123; radius = rad; &#125;</div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> Math.PI * (radius * radius);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Figure</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> <span class="keyword">double</span> length; <span class="keyword">final</span> <span class="keyword">double</span> width;</div><div class="line">Rectangle (<span class="keyword">double</span> len; <span class="keyword">double</span> wid)</div><div class="line">&#123; length = len; width = wid; &#125;</div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> length * width;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="第21条：用函数对象表示策略"><a href="#第21条：用函数对象表示策略" class="headerlink" title="第21条：用函数对象表示策略"></a>第21条：用函数对象表示策略</h3><h3 id="第22条：优先考虑静态成员类"><a href="#第22条：优先考虑静态成员类" class="headerlink" title="第22条：优先考虑静态成员类"></a>第22条：优先考虑静态成员类</h3><p>四种嵌套类（nested class）：</p>
<ul>
<li>静态成员类 （不是内部类，其余三个是）</li>
<li>非静态成员类</li>
<li>匿名类 anonymous class</li>
<li>局部类</li>
</ul>
<p>匿名类的常见用法：</p>
<ul>
<li>动态的创建函数对象。</li>
<li>创建过程对象： runnable thread timertask等</li>
</ul>
<h3 id="第30条：用enum代替int常量"><a href="#第30条：用enum代替int常量" class="headerlink" title="第30条：用enum代替int常量"></a>第30条：用enum代替int常量</h3><p>java枚举本质是int值。==！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Planet &#123;</div><div class="line"> <span class="comment">// Enum type with data and behavior</span></div><div class="line">	MERCURY (<span class="number">3.302e+23</span>, <span class="number">2.439e6</span>);</div><div class="line">	VENUS (<span class="number">4.869e+24</span>, <span class="number">6.052e6</span>);</div><div class="line">	EARTH (<span class="number">5.975e+24</span>, <span class="number">6.378e6</span>); <span class="comment">// plus MARS, JUPITER,etc.</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> mass;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> radius;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> surfaceGravity;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> G = <span class="number">6.67300e-11</span>; </div><div class="line"><span class="comment">//Universal G</span></div><div class="line">Planet (<span class="keyword">double</span> mass, <span class="keyword">double</span> radius) &#123; <span class="comment">// Constructor</span></div><div class="line">	<span class="keyword">this</span>.mass = mass; <span class="keyword">this</span>.radius = radius;</div><div class="line">	surfaceGravity = G* mass / (radius * radius);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">mass</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mass; &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">radious</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> radius; &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">surfaceGravity</span><span class="params">()</span> </span>&#123; </div><div class="line">	<span class="keyword">return</span> 	surfaceGravity; &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">surfaceWeight</span> <span class="params">(<span class="keyword">double</span> mass)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> mass * surfaceGravity; &#125; <span class="comment">// F = ma</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>test</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightTable</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">double</span> earthWeight = Double.parseDouble (args[<span class="number">0</span>]);</div><div class="line"><span class="keyword">double</span> mass = earthWeight / Planet.EARTH.surfaceGravity();</div><div class="line"><span class="comment">// All Enums have a static values() method</span></div><div class="line"><span class="comment">// All Enums have a sensible (and Overridable) toString()</span></div><div class="line"><span class="keyword">for</span> (Planet p : Planet.values())</div><div class="line">System.out.printf (“Weight on %s is %f%n”,</div><div class="line">p, p.surfaceWeight(mass));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Output:</span></div><div class="line">Weight on MERCURY is <span class="number">66.133672</span></div><div class="line">Weight on VENUS is <span class="number">158.383926</span></div><div class="line">Weight on EARTH is <span class="number">175.000000</span></div></pre></td></tr></table></figure>
<pre><code>// Enum type with constant-specific class bodies and data
public enum Operation {
PLUS(“+”) {
double apply (double x, double y) { return x + y; } };
MINUS(“-”) {
double apply (double x, double y) { return x - y; } };
TIMES(“*”) {
double apply (double x, double y) { return x * y; } };
DIVIDE(“/”) {
double apply (double x, double y) { return x / y; } };
private final String symbol;
Operation (String symbol) { this.symbol = symbol; }
@Override public String toString() { return symbol; }
// abstract apply() ensures each constant provide definition
abstract double apply(double x, double y);
}
</code></pre><p>方法：</p>
<ul>
<li>static E valueOf(s): converts a string into an enum value</li>
<li>static E[] values() :an array of all values of your enumeration</li>
</ul>
<h3 id="第31条：用实例域代替序数"><a href="#第31条：用实例域代替序数" class="headerlink" title="第31条：用实例域代替序数"></a>第31条：用实例域代替序数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Abuse of ordinal to derive an associated value – DON’T DO THIS</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Ensemble &#123;</div><div class="line">SOLO, DUET, TRIO, QUARTET, QUINTET,</div><div class="line">SEXTET, SEPTET, OCTET, NONET, DECTET;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMusicians</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ordinal() + <span class="number">1</span>; &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// What if: you add a DOUBLE_QUARTET? You rearrange the constants?</span></div><div class="line"><span class="comment">// Good Solution: Use instance fields instead</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Ensemble &#123;</div><div class="line">SOLO(<span class="number">1</span>), DUET(<span class="number">2</span>), TRIO(<span class="number">3</span>), QUARTET(<span class="number">4</span>), QUINTET(<span class="number">5</span>), SEXTET(<span class="number">6</span>),</div><div class="line">SEPTET(<span class="number">7</span>), OCTET(<span class="number">8</span>), DOUBLE_QUARTET(<span class="number">8</span>), TRIPLE_QUARTET(<span class="number">12</span>);</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> numberOfMusicians;</div><div class="line">Ensemble(<span class="keyword">int</span> size) &#123; <span class="keyword">this</span>.numberOfMusicians = size; &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMusicians</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> numberOfMusisians; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="第32条：用EnumSet代替位域"><a href="#第32条：用EnumSet代替位域" class="headerlink" title="第32条：用EnumSet代替位域"></a>第32条：用EnumSet代替位域</h3><h3 id="第33条：用EnumMap代替序数索引"><a href="#第33条：用EnumMap代替序数索引" class="headerlink" title="第33条：用EnumMap代替序数索引"></a>第33条：用EnumMap代替序数索引</h3><h3 id="第33条：用EnumMap代替序数索引-1"><a href="#第33条：用EnumMap代替序数索引-1" class="headerlink" title="第33条：用EnumMap代替序数索引"></a>第33条：用EnumMap代替序数索引</h3><h3 id="第35条：注解优先于命名模式"><a href="#第35条：注解优先于命名模式" class="headerlink" title="第35条：注解优先于命名模式"></a>第35条：注解优先于命名模式</h3><p>注解annotations</p>
<p>Common uses for annotations:</p>
<ul>
<li> To detect problems or errors in code</li>
<li> To suppress compiler warnings</li>
<li> For unit tests, e.g. JUnit</li>
</ul>
<p>An annotation can be placed on:</p>
<ul>
<li> a class</li>
<li> a method</li>
<li> a field</li>
<li> a local variable, …</li>
</ul>
<h3 id="第36条：坚持使用override注解"><a href="#第36条：坚持使用override注解" class="headerlink" title="第36条：坚持使用override注解"></a>第36条：坚持使用override注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bigram</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> first;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> second;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bigram</span><span class="params">(<span class="keyword">char</span> first, <span class="keyword">char</span> second)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.first = first;</div><div class="line">		<span class="keyword">this</span>.second = second;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Bigram b)</span> </span>&#123;</div><div class="line">	 <span class="keyword">return</span> b.first == first &amp;&amp; b.second == second;</div><div class="line">	 &#125;</div><div class="line"></div><div class="line">	 <span class="meta">@Override</span></div><div class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">	 Bigram b = (Bigram)o;</div><div class="line">	 <span class="keyword">return</span> b.first == first &amp;&amp; b.second == second;</div><div class="line">	 &#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">31</span> * first + second;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">//		System.out.println(new Bigram('a', 'z') == new Bigram('a', 'z'));</span></div><div class="line"><span class="comment">//		</span></div><div class="line"><span class="comment">//		</span></div><div class="line"><span class="comment">//		Object obj = new Bigram('a', 'z');</span></div><div class="line"><span class="comment">//		System.out.println(obj.equals(new Bigram('a', 'z')));</span></div><div class="line"><span class="comment">//		</span></div><div class="line"><span class="comment">//		System.out.println(new Bigram('a', 'z').equals(obj));</span></div><div class="line"></div><div class="line">		Set&lt;Bigram&gt; s = <span class="keyword">new</span> HashSet&lt;Bigram&gt;();</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ch++)</div><div class="line">				s.add(<span class="keyword">new</span> Bigram(ch, ch));</div><div class="line"></div><div class="line">		System.out.println(s.size());</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果是260.<br>解释：bigram类的创建者想要覆盖equals方法，同事还覆盖了hashcode。但是结果是没有覆盖，将他重载了。为了覆盖object.equals方法，必须定义一个参数为object类型的equals方法。</p>
<p>幸运的是当你加上@override注解时，编译器会报错告诉你哪里错了。</p>
<h3 id="第38条：检查参数的有效性"><a href="#第38条：检查参数的有效性" class="headerlink" title="第38条：检查参数的有效性"></a>第38条：检查参数的有效性</h3><h3 id="第39条：必要时进行保护性拷贝"><a href="#第39条：必要时进行保护性拷贝" class="headerlink" title="第39条：必要时进行保护性拷贝"></a>第39条：必要时进行保护性拷贝</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Broken “immutable” time period class</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Period</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Date start;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Date end;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Period</span> <span class="params">(Date start, Date end)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (start.compareTo(end) &gt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IAE(…);</div><div class="line"><span class="keyword">this</span>.start = start; <span class="keyword">this</span>.end = end; <span class="comment">//oops – should make defensive copies</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">start</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start;&#125; <span class="comment">// oops again!</span></div><div class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> end;&#125; <span class="comment">// oops yet again!</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// Attack code</span></div><div class="line">Date start = <span class="keyword">new</span> Date();</div><div class="line">Date end = <span class="keyword">new</span> Date();</div><div class="line">Period p = <span class="keyword">new</span> Period(start, end);</div><div class="line">end.setYear(<span class="number">78</span>); <span class="comment">// Attack 1: Modify internals of p via passed reference</span></div><div class="line">p.end().setYear(<span class="number">78</span>); <span class="comment">// Attack 2: Modify internals of p via returned state</span></div></pre></td></tr></table></figure>
<pre><code>// Repaired constructor and getters – now Period really is immutable
public Period (Date start, Date end) {
// Note: clone() *not* used to make defensive copy
// Reason: Date class not final; hence return type may not be java.util.Date
this.start = new Date(start.getTime()); // Defensive copy
this.end = new Date(end.getTime()); // Defensive copy
// Defensive copies made *before* exception check to avoid TOCTOU attack
if (this.start.compareTo(end) &gt; 0) throw new IAE(…);
}
// clone also safe here, but constructors or static factories better (Item 11)
public Date start() { return new Date(start.getTime()); }
public Date end() { return new Date(end.getTime());}
}
</code></pre><h3 id="第40条：谨慎设计方法签名"><a href="#第40条：谨慎设计方法签名" class="headerlink" title="第40条：谨慎设计方法签名"></a>第40条：谨慎设计方法签名</h3><h3 id="第41条：慎用重载"><a href="#第41条：慎用重载" class="headerlink" title="第41条：慎用重载"></a>第41条：慎用重载</h3><p>Overriding</p>
<ul>
<li> Normal OO Pattern</li>
<li> Dynamically determined by runtime system</li>
</ul>
<p>Overloading</p>
<ul>
<li> Exceptional OO Pattern</li>
<li> Statically determined by compiler</li>
</ul>
<p>Set.java ：boolean remove(Object o);<br>List.java：E remove(int index);boolean remove(Object o);</p>
<h3 id="第42条：慎用可变参数"><a href="#第42条：慎用可变参数" class="headerlink" title="第42条：慎用可变参数"></a>第42条：慎用可变参数</h3><h3 id="第43条：返回零长度的数据或者集合，而不是null"><a href="#第43条：返回零长度的数据或者集合，而不是null" class="headerlink" title="第43条：返回零长度的数据或者集合，而不是null"></a>第43条：返回零长度的数据或者集合，而不是null</h3><h3 id="第44条：为所有导出的api元素编写文档注释"><a href="#第44条：为所有导出的api元素编写文档注释" class="headerlink" title="第44条：为所有导出的api元素编写文档注释"></a>第44条：为所有导出的api元素编写文档注释</h3><h3 id="第45条：将局部变量的作用于最小化"><a href="#第45条：将局部变量的作用于最小化" class="headerlink" title="第45条：将局部变量的作用于最小化"></a>第45条：将局部变量的作用于最小化</h3><p>要使局部变量的作用于最小化，最有力的方法就是在第一次使用它的地方声明，</p>
<p>几乎每个局部变量的声明都应该包含一个初始化表达式，</p>
<h3 id="第46条：foreach循环优先于传统for循环"><a href="#第46条：foreach循环优先于传统for循环" class="headerlink" title="第46条：foreach循环优先于传统for循环"></a>第46条：foreach循环优先于传统for循环</h3><h3 id="第47条：了解和实用类库"><a href="#第47条：了解和实用类库" class="headerlink" title="第47条：了解和实用类库"></a>第47条：了解和实用类库</h3><h3 id="第48条：如果需要准确的答案，请避免实用float和double"><a href="#第48条：如果需要准确的答案，请避免实用float和double" class="headerlink" title="第48条：如果需要准确的答案，请避免实用float和double"></a>第48条：如果需要准确的答案，请避免实用float和double</h3><p>BigDecimal</p>
<h3 id="第49条：自动拆箱和装箱"><a href="#第49条：自动拆箱和装箱" class="headerlink" title="第49条：自动拆箱和装箱"></a>第49条：自动拆箱和装箱</h3><pre><code>// Broken comparator – can you spot the flaw?
Comparator &lt; Integer&gt; naturalOrder =
new Comparator&lt;Integer&gt;() { // Anonymous type
public int compare (Integer first, Integer second) {
return first &lt; second ? -1 ://自动拆箱
(first == second//没有自动拆箱
? 0 : 1);
}
};
 Sample uses:
 naturalOrder.compare(new Integer(41), new Integer(42));
 naturalOrder.compare(new Integer(42), new Integer(42));
 naturalOrder.compare(new Integer(43), new Integer(42));
</code></pre><h3 id="第50条：如果其他类型更适合，则尽量避免实用string"><a href="#第50条：如果其他类型更适合，则尽量避免实用string" class="headerlink" title="第50条：如果其他类型更适合，则尽量避免实用string"></a>第50条：如果其他类型更适合，则尽量避免实用string</h3><h3 id="第51条：当心字符串连接的性能"><a href="#第51条：当心字符串连接的性能" class="headerlink" title="第51条：当心字符串连接的性能"></a>第51条：当心字符串连接的性能</h3><h3 id="第52条：通过接口引用对象"><a href="#第52条：通过接口引用对象" class="headerlink" title="第52条：通过接口引用对象"></a>第52条：通过接口引用对象</h3><h3 id="第53条：接口优先于反射机制"><a href="#第53条：接口优先于反射机制" class="headerlink" title="第53条：接口优先于反射机制"></a>第53条：接口优先于反射机制</h3><h3 id="第54条：谨慎的使用本地方法"><a href="#第54条：谨慎的使用本地方法" class="headerlink" title="第54条：谨慎的使用本地方法"></a>第54条：谨慎的使用本地方法</h3><h3 id="第55条：谨慎的进行优化"><a href="#第55条：谨慎的进行优化" class="headerlink" title="第55条：谨慎的进行优化"></a>第55条：谨慎的进行优化</h3><h3 id="第57条：只针对异常的情况实用异常"><a href="#第57条：只针对异常的情况实用异常" class="headerlink" title="第57条：只针对异常的情况实用异常"></a>第57条：只针对异常的情况实用异常</h3><h3 id="第61条：抛出与抽象相对应的异常"><a href="#第61条：抛出与抽象相对应的异常" class="headerlink" title="第61条：抛出与抽象相对应的异常"></a>第61条：抛出与抽象相对应的异常</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/03/spring/" itemprop="url">
                  spring
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-11-03T13:46:38+08:00" content="2016-11-03">
              2016-11-03
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spring-AOP-源码分析"><a href="#Spring-AOP-源码分析" class="headerlink" title="Spring AOP 源码分析"></a>Spring AOP 源码分析</h1><h2 id="零-Spring-aop的使用"><a href="#零-Spring-aop的使用" class="headerlink" title="零.Spring aop的使用"></a>零.Spring aop的使用</h2><p>想要分析aop源码。总要先知道spring aop怎么使用吧。要不然，分析个orz…</p>
<p>使用Spring AOP可以基于两种方式，一种是比较方便和强大的注解方式，另一种则是中规中矩的xml配置方式。</p>
<h3 id="0-1-基于注解的使用"><a href="#0-1-基于注解的使用" class="headerlink" title="0.1 基于注解的使用"></a>0.1 基于注解的使用</h3><p>第一步xml配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd</span></div><div class="line">    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;</div><div class="line">    </div><div class="line">    <span class="comment">&lt;!-- 激活组件扫描功能,在包cn.ysh.studio.spring.aop及其子包下面自动扫描通过注解配置的组件 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.ysh.studio.spring.aop"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 激活自动代理功能 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line">    </div><div class="line">    <span class="comment">&lt;!-- 用户服务对象 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"cn.ysh.studio.spring.aop.service.UserService"</span> /&gt;</span></div><div class="line">    </div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>第二步是为Aspect切面类添加注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="comment">//声明这是一个切面Bean</span></div><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAspect</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Log log = LogFactory.getLog(ServiceAspect.class);</div><div class="line">    </div><div class="line">    <span class="comment">//配置切入点,该方法无方法体,主要为方便同类中其他方法使用此处配置的切入点</span></div><div class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* cn.ysh.studio.spring.aop.service..*(..))"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspect</span><span class="params">()</span></span>&#123;    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 配置前置通知,使用在方法aspect()上注册的切入点</div><div class="line">     * 同时接受JoinPoint切入点对象,可以没有该参数</div><div class="line">     */</div><div class="line">    <span class="meta">@Before</span>(<span class="string">"aspect()"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(log.isInfoEnabled())&#123;</div><div class="line">            log.info(<span class="string">"before "</span> + joinPoint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//配置后置通知,使用在方法aspect()上注册的切入点</span></div><div class="line">    <span class="meta">@After</span>(<span class="string">"aspect()"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(log.isInfoEnabled())&#123;</div><div class="line">            log.info(<span class="string">"after "</span> + joinPoint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//配置环绕通知,使用在方法aspect()上注册的切入点</span></div><div class="line">    <span class="meta">@Around</span>(<span class="string">"aspect()"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ((ProceedingJoinPoint) joinPoint).proceed();</div><div class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">            <span class="keyword">if</span>(log.isInfoEnabled())&#123;</div><div class="line">                log.info(<span class="string">"around "</span> + joinPoint + <span class="string">"\tUse time : "</span> + (end - start) + <span class="string">" ms!"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">            <span class="keyword">if</span>(log.isInfoEnabled())&#123;</div><div class="line">                log.info(<span class="string">"around "</span> + joinPoint + <span class="string">"\tUse time : "</span> + (end - start) + <span class="string">" ms with exception : "</span> + e.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//配置后置返回通知,使用在方法aspect()上注册的切入点</span></div><div class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"aspect()"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturn</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(log.isInfoEnabled())&#123;</div><div class="line">            log.info(<span class="string">"afterReturn "</span> + joinPoint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//配置抛出异常后通知,使用在方法aspect()上注册的切入点</span></div><div class="line">    <span class="meta">@AfterThrowing</span>(pointcut=<span class="string">"aspect()"</span>, throwing=<span class="string">"ex"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrow</span><span class="params">(JoinPoint joinPoint, Exception ex)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(log.isInfoEnabled())&#123;</div><div class="line">            log.info(<span class="string">"afterThrow "</span> + joinPoint + <span class="string">"\t"</span> + ex.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第三步测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Log log = LogFactory.getLog(Tester.class);</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//启动Spring容器</span></div><div class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</div><div class="line">        <span class="comment">//获取service组件</span></div><div class="line">        UserService service = (UserService) context.getBean(<span class="string">"userService"</span>);</div><div class="line">        <span class="comment">//以普通的方式调用UserService对象的三个方法</span></div><div class="line">        User user = service.get(<span class="number">1L</span>);</div><div class="line">        service.save(user);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            service.delete(<span class="number">1L</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">if</span>(log.isWarnEnabled())&#123;</div><div class="line">                log.warn(<span class="string">"Delete user : "</span> + e.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="0-2-xml配置"><a href="#0-2-xml配置" class="headerlink" title="0.2 xml配置"></a>0.2 xml配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd</span></div><div class="line">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 系统服务组件的切面Bean --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceAspect"</span> <span class="attr">class</span>=<span class="string">"cn.ysh.studio.spring.aop.aspect.ServiceAspect"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!-- AOP配置 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 声明一个切面,并注入切面Bean,相当于@Aspect --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"simpleAspect"</span> <span class="attr">ref</span>=<span class="string">"serviceAspect"</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- 配置一个切入点,相当于@Pointcut --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.ysh.studio.spring.aop.service..*(..))"</span> <span class="attr">id</span>=<span class="string">"simplePointcut"</span>/&gt;</span></div><div class="line">            <span class="comment">&lt;!-- 配置通知,相当于@Before、@After、@AfterReturn、@Around、@AfterThrowing --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"simplePointcut"</span> <span class="attr">method</span>=<span class="string">"before"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">"simplePointcut"</span> <span class="attr">method</span>=<span class="string">"after"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut-ref</span>=<span class="string">"simplePointcut"</span> <span class="attr">method</span>=<span class="string">"afterReturn"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut-ref</span>=<span class="string">"simplePointcut"</span> <span class="attr">method</span>=<span class="string">"afterThrow"</span> <span class="attr">throwing</span>=<span class="string">"ex"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>AOP用起来还是很简单的。就把xml配置好就算完工了。有Advisor和aspect两种方式来完成。如果是用Advisor的话需要实现AfterReturningAdvice，MethodBeforeAdvice，ThrowsAdvice等接口。而如果用aspect的话则不用继承或者实现其他的类，一个普通的类即可。</p>
<h2 id="一．AOP介绍"><a href="#一．AOP介绍" class="headerlink" title="一．AOP介绍"></a>一．AOP介绍</h2><p>软件开发经历了从汇编语言到高级语言和从过程化编程到面向对象编程；前者是为了提高开发效率，而后者则使用了归纳法，把具有共性的东西进行归类并使之模块化，达到便于维护和扩展的目的；如果说面向对象编程可以对业务需求进行很好的分解使之模块化；那么面向切面编程AOP（Aspect-Oriented Programming）则可以对系统需求进行很好的模软件开发经历了从汇编语言到高级语言和从过程化编程到面向对象编程；前者是为了提高开发效率，而后者则使用了归纳法，把具有共性的东西进行归类并使之模块化，达到便于维护和扩展的目的；如果说面向对象编程可以对业务需求进行很好的分解使之模块化；那么面向切面编程AOP（Aspect-Oriented Programming）则可以对系统需求进行很好的模块组织，简化系统需求和实现之间的对比关系，是对OOP思想的一种补充；块组织，简化系统需求和实现之间的对比关系，是对OOP思想的一种补充。</p>
<p>举个例子来说明一下吧！现在系统中有很多的业务方法，如上传产品信息、修改产品信息、发布公司库等；现在需要对这些方法的执行做性能监控，看每个业务方法的执行时间；在不改变原业务代码的基础上，也许我们会这么做。</p>
<p>Offer接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> edu.zju.cs.lyp.Spring_aop;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IOffer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOffer</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyOffer</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Offer实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> edu.zju.cs.lyp.Spring_aop;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OfferImpl</span> <span class="keyword">implements</span> <span class="title">IOffer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOffer</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"post offer"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyOffer</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"modify offer"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>工具类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> edu.zju.cs.lyp.Spring_aop;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerformanceUtil</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> start=<span class="number">0</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> end=<span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startPerformance</span><span class="params">()</span></span>&#123;</div><div class="line">        start=System.currentTimeMillis();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">endPerformance</span><span class="params">()</span></span>&#123;</div><div class="line">        end=System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"method use:"</span>+(end-start));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Offer代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> edu.zju.cs.lyp.Spring_aop;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OfferProxy</span> <span class="keyword">implements</span> <span class="title">IOffer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> IOffer delegate;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OfferProxy</span><span class="params">(IOffer delegate)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.delegate=delegate;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOffer</span><span class="params">()</span> </span>&#123;</div><div class="line">        PerformanceUtil.startPerformance();</div><div class="line">        delegate.postOffer();</div><div class="line">        PerformanceUtil.endPerformance();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyOffer</span><span class="params">()</span> </span>&#123;</div><div class="line">        PerformanceUtil.startPerformance();</div><div class="line">        delegate.modifyOffer();</div><div class="line">        PerformanceUtil.endPerformance();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Offer测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> edu.zju.cs.lyp.Spring_aop;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        IOffer offer= <span class="keyword">new</span> OfferProxy(<span class="keyword">new</span> OfferImpl());</div><div class="line">        offer.postOffer();</div><div class="line">        offer.modifyOffer();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">post offer</div><div class="line">method use:<span class="number">1</span></div><div class="line">modify offer</div><div class="line">method use:<span class="number">0</span></div></pre></td></tr></table></figure>
<p>上面的例子中，OfferProxy实现了IOffer，而所有的业务实现均委托给其成员offer；可以想像，这应该就是最简单的AOP的实现了；但这种方式会存在一个问题：如果有非常多的这种业务对象需要性能监控，我们就需要写同样多的XyzProxy来满足需求，这也是非常巨大的工作量。</p>
<h2 id="二．-代理模式"><a href="#二．-代理模式" class="headerlink" title="二．    代理模式"></a>二．    代理模式</h2><p>代理模式中，存在一个称为ProxyObject的代理对象和RealObject的真实对象，它们都实现了相同的接口；在调用的地方持有ProxyObject的实例，当调用request()方法时，ProxyObject可以在执行RealObject.request()前后做一些特定的业务，甚至不调用RealObject.request()方法。</p>
<p>目前实现代理模式的方式有两种：基于JDK的动态代理和基于CGLIB字节码的代理。</p>
<h3 id="2-1-JDK动态代理"><a href="#2-1-JDK动态代理" class="headerlink" title="2.1 JDK动态代理"></a>2.1 JDK动态代理</h3><p>JDK动态代理，顾名思义，是基于JDK的反射(reflect)机制；在JDK中，提供了InvocationHandler这个接口。</p>
<p>注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">InvocationHandler is the <span class="class"><span class="keyword">interface</span> <span class="title">implemented</span> <span class="title">by</span> <span class="title">the</span> <span class="title">invocation</span> <span class="title">handler</span> <span class="title">of</span> <span class="title">a</span> <span class="title">proxy</span> <span class="title">instance</span>.</span></div><div class="line"><span class="title">Each</span> <span class="title">proxy</span> <span class="title">instance</span> <span class="title">has</span> <span class="title">an</span> <span class="title">associated</span> <span class="title">invocation</span> <span class="title">handler</span>. <span class="title">When</span> <span class="title">a</span> <span class="title">method</span> <span class="title">is</span> <span class="title">invoked</span> <span class="title">on</span> <span class="title">a</span> <span class="title">proxy</span> <span class="title">instance</span>, <span class="title">the</span> <span class="title">method</span> <span class="title">invocation</span> <span class="title">is</span> <span class="title">encoded</span> <span class="title">and</span> <span class="title">dispatched</span> <span class="title">to</span> <span class="title">the</span> <span class="title">invoke</span> <span class="title">method</span> <span class="title">of</span> <span class="title">its</span> <span class="title">invocation</span> <span class="title">handler</span>.</div></pre></td></tr></table></figure>
<p>意思是说：该接口由被代理对象的handler所实现；当调用代理对象的方法时，该方法调用将被编码，然后交给代理对象的invoke方法去执行。<br>因此上面的代码可以改写成如下所示：</p>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> edu.zju.cs.lyp.Spring_aop;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Object delegate;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object delegate)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.delegate= delegate;</div><div class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(delegate.getClass().getClassLoader(), </div><div class="line">                delegate.getClass().getInterfaces(), <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        PerformanceUtil.startPerformance();</div><div class="line">        Object result=<span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            result=method.invoke(delegate, args);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exceptions</span></div><div class="line">        &#125;</div><div class="line">        PerformanceUtil.endPerformance();</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> edu.zju.cs.lyp.Spring_aop;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDKProxy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        IOffer offer = (IOffer) <span class="keyword">new</span> ProxyFactory().bind(<span class="keyword">new</span> OfferImpl());</div><div class="line">        offer.postOffer();</div><div class="line">        offer.modifyOffer();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">post offer</div><div class="line">method use:<span class="number">1</span></div><div class="line">modify offer</div><div class="line">method use:<span class="number">0</span></div></pre></td></tr></table></figure>
<p>通过这种方式，你不需要为针对每一个业务写一个代理对象，就可以很轻松地完成你的需求；但也许你已经注意到了，JDK的动态代理，在创建代理对象(上面红色代码部分)时，被代理的对象需要实现接口(即面向接口编程)；</p>
<h3 id="2-2CGLIB代理方式"><a href="#2-2CGLIB代理方式" class="headerlink" title="2.2CGLIB代理方式"></a>2.2CGLIB代理方式</h3><p>如果目标对象没有实现任何接口，那怎么办呢？不用担心，你可以用CGLIB来实现代理。</p>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> edu.zju.cs.lyp.Spring_aop;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</div><div class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</div><div class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyFactory</span>  <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> Object delegate;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object delegate)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.delegate=delegate;</div><div class="line">        Enhancer enhancer= <span class="keyword">new</span> Enhancer();</div><div class="line">        enhancer.setSuperclass(delegate.getClass());</div><div class="line">        enhancer.setCallback(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> enhancer.create();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        PerformanceUtil.startPerformance();</div><div class="line">        Object o =proxy.invoke(<span class="keyword">this</span>.delegate, args);</div><div class="line">        PerformanceUtil.endPerformance();</div><div class="line">        <span class="keyword">return</span> o;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> edu.zju.cs.lyp.Spring_aop;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCglibProxy</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        DefaultOffer defaultOffer= (DefaultOffer) <span class="keyword">new</span> CglibProxyFactory().bind(<span class="keyword">new</span> DefaultOffer());</div><div class="line">        defaultOffer.postOffer();</div><div class="line">        defaultOffer.modifyOffer();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">post offer</div><div class="line">method use:<span class="number">20</span></div><div class="line">modify offer</div><div class="line">method use:<span class="number">0</span></div></pre></td></tr></table></figure>
<p>使用CGLIB创建的代理对象，其实就是继承了要代理的目标类，然后对目标类中所有非final方法进行覆盖，但在覆盖方法时会添加一些拦截代码(上面CglibProxyFactory类中的intercept方法)。</p>
<h2 id="三．-Spring-AOP-实现"><a href="#三．-Spring-AOP-实现" class="headerlink" title="三．    Spring AOP 实现"></a>三．    Spring AOP 实现</h2><h3 id="3-1-Spring-AOP-几个基本概念"><a href="#3-1-Spring-AOP-几个基本概念" class="headerlink" title="3.1 Spring AOP 几个基本概念"></a>3.1 Spring AOP 几个基本概念</h3><p>Spring AOP jar包：<strong>spring-aop-4.2.5.release.jar</strong></p>
<p>Spring AOP中的几个基本概念，每次学习AOP都被这几个概念折腾的很不爽，我们在这里再把这几个概念描述一遍，力争把这几个概念搞清，在每次review这块内容的时候可以很快上手。</p>
<ol>
<li>切面(Aspect)：切面就是一个关注点的模块化，如事务管理、日志管理、权限管理等；</li>
<li>连接点(Joinpoint)：程序执行时的某个特定的点，在Spring中就是一个方法的执行；</li>
<li>通知(Advice)：通知就是在切面的某个连接点上执行的操作，也就是事务管理、日志管理等；</li>
<li>切入点(Pointcut)：切入点就是描述某一类选定的连接点，也就是指定某一类要织入通知的方法；</li>
<li>目标对象(Target)：就是被AOP动态代理的目标对象；</li>
</ol>
<p>用一张图来形象地表达AOP的概念及其关系如下：</p>
<p><img src="http://i.imgur.com/SoF1QtC.png" alt=""></p>
<h3 id="3-2-Spring-AOP-中切入点、通知、切面的实现"><a href="#3-2-Spring-AOP-中切入点、通知、切面的实现" class="headerlink" title="3.2 Spring AOP 中切入点、通知、切面的实现"></a>3.2 Spring AOP 中切入点、通知、切面的实现</h3><p>理解了上面的几个概念后，我们分别来看看Spring AOP是如何实现这些概念的；</p>
<h4 id="3-2-1-切入点-Pointcut"><a href="#3-2-1-切入点-Pointcut" class="headerlink" title="3.2.1.切入点(Pointcut)"></a>3.2.1.切入点(Pointcut)</h4><p>它定义了哪些连接点需要被织入横切逻辑；在Java中，连接点对应哪些类(接口)的方法。因此，我们都能猜到，所谓的切入点，就是定义了匹配哪些娄的哪些方法的一些规则，可以是静态的基于类(方法)名的值匹配，也可以是基于正则表达式的模式匹配。</p>
<p>来看看Spring AOP Pointcut相关的类图：</p>
<p><img src="http://i.imgur.com/0Fpm5dB.png" alt=""></p>
<p>在Pointcut接口的定义中，也许你已经想到了，ClassFilter是类过滤器，它定义了哪些类名需要拦截；典型的两个实现类为TypePatternClassFilter和TrueClassFilter(所有类均匹配)；而MethodMatcher为方法匹配器，定义哪些方法需要拦截。</p>
<p>在上面的类图中：</p>
<ul>
<li>StaticMethodMatch与DynamicMethodMatch的区别是后者在运行时会依据方法的参数值进行匹配。</li>
<li>NameMatchMethodPointCut根据指定的mappedNames来匹配方法。</li>
<li>AbstractRegexpMethodPointCut根据正则表达式来匹配方法</li>
</ul>
<p>类图中部分代码实现：</p>
<p>MethodMatcher.class:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.aop;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodMatcher</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodMatcher TRUE = TrueMethodMatcher.INSTANCE;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method paramMethod, Class&lt;?&gt; paramClass)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method paramMethod, Class&lt;?&gt; paramClass, Object[] paramArrayOfObject)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>StaticMethodMatcher.class:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.aop.support;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> org.springframework.aop.MethodMatcher;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticMethodMatcher</span> <span class="keyword">implements</span> <span class="title">MethodMatcher</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass, Object[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Illegal MethodMatcher usage"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DynamicMethodMatcher.class:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.aop.support;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> org.springframework.aop.MethodMatcher;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicMethodMatcher</span> <span class="keyword">implements</span> <span class="title">MethodMatcher</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isRuntime</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Pointcut.class:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.aop;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pointcut</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Pointcut TRUE = TruePointcut.INSTANCE;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ClassFilter <span class="title">getClassFilter</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-2-2-通知-Advice"><a href="#3-2-2-通知-Advice" class="headerlink" title="3.2.2.通知(Advice)"></a>3.2.2.通知(Advice)</h4><p>通知定义了具体的横切逻辑。在Spring中，存在两种类型的Advice，即per-class和per-instance的Advice。</p>
<p>所谓per-class，即该类型的Advice只提供方法拦截，不会为目标对象保存任何状态或者添加新的特性，它也是我们最常见的Advice。下面是per-class的类图：</p>
<p><img src="http://i.imgur.com/tGVnfQi.png" alt=""></p>
<ul>
<li>BeforeAdvice：在连接点前执行的横切逻辑。</li>
<li>AfterReturningAdvice：在连接点执行后，再执行横切逻辑。</li>
<li>AfterAdvice：一般由程序自己实现，当抛出异常后，执行横切逻辑。</li>
<li>AroundAdvice：Spring AOP中并没有提供这个接口，而是采用了AOP Alliance的MethodInteceptor接口；通过看AfterReturningAdvice的源码我们知道，它是不能更改连接点所在方法的返回值的(更改引用)；但使用的MethodInteceptor，所有的事情，都不在话下。</li>
</ul>
<p>部分源码介绍：</p>
<p>AfterAdvice,Advice两个接口是空的</p>
<p>AfterReturningAdvice.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.aop;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">interface</span> <span class="title">AfterReturningAdvice</span> <span class="keyword">extends</span> <span class="title">AfterAdvice</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object paramObject1, Method paramMethod, Object[] paramArrayOfObject,</span></span></div><div class="line">            Object paramObject2) <span class="keyword">throws</span> Throwable;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>MethodBeforeAdvice.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title">BeforeAdvice</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method paramMethod, Object[] paramArrayOfObject, Object paramObject)</span> <span class="keyword">throws</span> Throwable</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>MethodInterceptor.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.aopalliance.intercept;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation paramMethodInvocation)</span> <span class="keyword">throws</span> Throwable</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的类图中，还有两种类没有介绍，那就是 <strong><em>AdviceAdapter 和 </em></strong>AdviceInteceptor.结构如图所示<br><img src="http://i.imgur.com/0ooNuhA.png" alt=""></p>
<p>我们以AfterReturningAdviceInterceptor为例来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.aop.framework.adapter;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"><span class="keyword">import</span> org.aopalliance.intercept.MethodInterceptor;</div><div class="line"><span class="keyword">import</span> org.aopalliance.intercept.MethodInvocation;</div><div class="line"><span class="keyword">import</span> org.springframework.aop.AfterAdvice;</div><div class="line"><span class="keyword">import</span> org.springframework.aop.AfterReturningAdvice;</div><div class="line"><span class="keyword">import</span> org.springframework.util.Assert;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterReturningAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">AfterAdvice</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AfterReturningAdvice advice;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AfterReturningAdviceInterceptor</span><span class="params">(AfterReturningAdvice advice)</span> </span>&#123;</div><div class="line">        Assert.notNull(advice, <span class="string">"Advice must not be null"</span>);</div><div class="line">        <span class="keyword">this</span>.advice = advice;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        Object retVal = mi.proceed();</div><div class="line">        <span class="keyword">this</span>.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());</div><div class="line">        <span class="keyword">return</span> retVal;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该类实现了MethodInterceptor和AfterAdvice接口，同时构造函数中还有一个AfterReturningAdvice实例的参数；这个类存在的作用是为了什么呢？Spring AOP把所有的Advice都适配成了MethodInterceptor，统一的好处是方便后面横切逻辑的执行(参看下一节)，适配的工作即由<em>*</em>AdviceAdapter完成；</p>
<p>Spring AOP所谓的AfterReturningAdvice，通过适配成MethodInterceptor后，其实就是在invoke方法中，先执行目标对象的方法，再执行的AfterReturningAdvice所定义的横切逻辑。</p>
<p>对于per-instance的Advice，目前只有一种实现，就是Introduction，使用的场景比较少。</p>
<p><img src="http://i.imgur.com/EmLqrLw.png" alt=""></p>
<h4 id="3-2-3-切面-Aspect"><a href="#3-2-3-切面-Aspect" class="headerlink" title="3.2.3.切面(Aspect)"></a>3.2.3.切面(Aspect)</h4><p>在Spring中，Advisor就是切面；但与通常的Aspect不同的是，Advisor通常只有一个Pointcut和一个Advice，而Aspect则可以包含多个Pointcut和多个Advice，因此Advisor是一种特殊的Aspect。</p>
<p>接下来看下per-class Advisor的类图：</p>
<p><img src="http://i.imgur.com/rELgifs.png" alt=""></p>
<p>继承关系如下：</p>
<p><img src="http://i.imgur.com/oSYJlw4.png" alt=""></p>
<p>Advisor包含一个Pointcut和一个Advisor；在AbstractGenericPointcutAdvisor中，持有一个Advice的引用；下面的几个实现，均是针对前面提到的几种不同的Pointcut的实现。</p>
<h3 id="3-3-Spring-AOP实现基本线索"><a href="#3-3-Spring-AOP实现基本线索" class="headerlink" title="3.3 Spring AOP实现基本线索"></a>3.3 Spring AOP实现基本线索</h3><p>我们选择ProxyFactoryBean作为入口点和分析的开始。ProxyFactoryBean是在Spring IoC环境中，创建AOP应用的最底层方法，从中，可以看到一条实现AOP的基本线索。</p>
<p>所有的逻辑从以下的方法开始,我们主要针对单例的代理对象的生成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">    <span class="comment">//这里初始化通知器链</span></div><div class="line">    initializeAdvisorChain();</div><div class="line">    <span class="keyword">if</span> (isSingleton()) &#123;</div><div class="line">        <span class="comment">//根据定义需要生成单例的proxy</span></div><div class="line">        <span class="keyword">return</span> getSingletonInstance();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.targetName == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.logger.warn(</div><div class="line">                <span class="string">"Using non-singleton proxies with singleton targets is often undesirable. Enable prototype proxies by setting the 'targetName' property."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//这里根据定义需要生成prototype类型的proxy</span></div><div class="line">    <span class="keyword">return</span> newPrototypeInstance();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们深入到SpringAOP核心代码的内部，看看代理对象的生成机制，拦截器横切逻辑以及织入的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Object <span class="title">getSingletonInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.singletonInstance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//返回具体的目标对象，就是被代理的对象</span></div><div class="line">            <span class="keyword">this</span>.targetSource = freshTargetSource();</div><div class="line">            <span class="keyword">if</span> ((<span class="keyword">this</span>.autodetectInterfaces) &amp;&amp; (getProxiedInterfaces().length == <span class="number">0</span>) &amp;&amp; (!(isProxyTargetClass()))) &#123;</div><div class="line">                <span class="comment">//从targetsource中获取目标对象的class</span></div><div class="line">                Class targetClass = getTargetClass();</div><div class="line">                <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> FactoryBeanNotInitializedException(<span class="string">"Cannot determine target class for proxy"</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//这里设置代理对象的借口</span></div><div class="line">                setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, <span class="keyword">this</span>.proxyClassLoader));</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//这里使用proxyfactory来生成我们需要的proxy。</span></div><div class="line">            <span class="keyword">super</span>.setFrozen(<span class="keyword">this</span>.freezeProxy);</div><div class="line">            <span class="keyword">this</span>.singletonInstance = getProxy(createAopProxy());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.singletonInstance;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>ProxyFactoryBean是AdvisedSupport的子类，Spring使用AopProxy接口把AOP代理的实现与框架的其他部分分离开来。在AdvisedSupport中通过这样的方式来得到AopProxy,当然这里需要得到AopProxyFactory的帮助 ，从JDK或者cglib中得到想要的代理对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!(<span class="keyword">this</span>.active)) &#123;</div><div class="line">            activate();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>getAopProxyFactory()获取ProxyCreatorSupport的属性aopProxyFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> AopProxyFactory <span class="title">getAopProxyFactory</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.aopProxyFactory;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>该属性被默认初始化为DefaultAopProxyFactory对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProxyCreatorSupport</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.aopProxyFactory = <span class="keyword">new</span> DefaultAopProxyFactory();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProxyCreatorSupport</span><span class="params">(AopProxyFactory aopProxyFactory)</span> </span>&#123;</div><div class="line">        Assert.notNull(aopProxyFactory, <span class="string">"AopProxyFactory must not be null"</span>);</div><div class="line">        <span class="keyword">this</span>.aopProxyFactory = aopProxyFactory;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个DefaultAopProxyFactory是Spring用来生成AopProxy的地方，它包含JDK和Cglib两种实现方式。让我接着往里面看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*** Eclipse Class Decompiler plugin, copyright (c) 2016 Chen Chao (cnfree2000@hotmail.com) ***/</span></div><div class="line"><span class="keyword">package</span> org.springframework.aop.framework;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</div><div class="line"><span class="keyword">import</span> org.springframework.aop.SpringProxy;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</div><div class="line">        <span class="comment">//做一些判断操作。isoptimize（）是指是否采取进一步的优化，true采用cglib来生成代理。</span></div><div class="line">        <span class="comment">//isproxytargetclass决定是否采用基于接口的代理。</span></div><div class="line">        <span class="keyword">if</span> ((config.isOptimize()) || (config.isProxyTargetClass()) || (hasNoUserSuppliedProxyInterfaces(config))) &#123;</div><div class="line">            Class targetClass = config.getTargetClass();</div><div class="line">            <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(</div><div class="line">                        <span class="string">"TargetSource cannot determine target class: Either an interface or a target is required for proxy creation."</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果目标对象实现的接口，则采用jdk动态代理来生成proxy</span></div><div class="line">            <span class="keyword">if</span> ((targetClass.isInterface()) || (Proxy.isProxyClass(targetClass))) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果target不是接口的实现的话，返回cglib类型的aopproxy</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//不满足最开始的判断 直接使用jdk动态代理</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNoUserSuppliedProxyInterfaces</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</div><div class="line">        Class[] ifcs = config.getProxiedInterfaces();</div><div class="line">        <span class="keyword">return</span> ((ifcs.length == <span class="number">0</span>) || ((ifcs.length == <span class="number">1</span>) &amp;&amp; (SpringProxy.class.isAssignableFrom(ifcs[<span class="number">0</span>]))));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到其中的代理对象可以由JDK或者Cglib来生成，JdkDynamicAopProxy类和Cglib2AopProxy都实现的是AopProxy的接口，我们进入JdkDynamicAopProxy实现中看看Proxy是怎样生成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdkDynamicAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</div><div class="line">        Assert.notNull(config, <span class="string">"AdvisedSupport must not be null"</span>);</div><div class="line">        <span class="keyword">if</span> ((config.getAdvisors().length == <span class="number">0</span>) &amp;&amp; (config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"No advisors and no TargetSource specified"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.advised = config;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> getProxy(ClassUtils.getDefaultClassLoader());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">            logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//根据advised中的配置信息，获取proxy需要代理的接口、放入proxiedInterfaces中。</span></div><div class="line">        Class[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised);</div><div class="line">        findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</div><div class="line">        <span class="comment">//这里我们调用jdk proxy 来生成需要的proxy实例</span></div><div class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>再来看cglib代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjenesisCglibAopProxy</span> <span class="keyword">extends</span> <span class="title">CglibAopProxy</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(ObjenesisCglibAopProxy.class);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SpringObjenesis objenesis = <span class="keyword">new</span> SpringObjenesis();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjenesisCglibAopProxy</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(config);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">createProxyClassAndInstance</span><span class="params">(Enhancer enhancer, Callback[] callbacks)</span> </span>&#123;</div><div class="line">        Class proxyClass = enhancer.createClass();</div><div class="line">        Object proxyInstance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (objenesis.isWorthTrying()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                proxyInstance = objenesis.newInstance(proxyClass, enhancer.getUseCache());</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">                logger.debug(<span class="string">"Unable to instantiate proxy using Objenesis, falling back to regular proxy construction"</span>,</div><div class="line">                        ex);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (proxyInstance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                proxyInstance = (<span class="keyword">this</span>.constructorArgs != <span class="keyword">null</span>)</div><div class="line">                        ? proxyClass.getConstructor(<span class="keyword">this</span>.constructorArgTypes).newInstance(<span class="keyword">this</span>.constructorArgs)</div><div class="line">                        : proxyClass.newInstance();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(</div><div class="line">                        <span class="string">"Unable to instantiate proxy using Objenesis, and regular proxy instantiation via default constructor fails as well"</span>,</div><div class="line">                        ex);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ((Factory) proxyInstance).setCallbacks(callbacks);</div><div class="line">        <span class="keyword">return</span> proxyInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继承了CglibAopProxy。下面的和最开始的例子比较，是不是很熟悉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">            logger.debug(<span class="string">"Creating CGLIB proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Class rootClass = <span class="keyword">this</span>.advised.getTargetClass();</div><div class="line">            Assert.state(rootClass != <span class="keyword">null</span>, <span class="string">"Target class must be available for creating a CGLIB proxy"</span>);</div><div class="line"></div><div class="line">            Class proxySuperClass = rootClass;</div><div class="line">            <span class="keyword">if</span> (ClassUtils.isCglibProxyClass(rootClass)) &#123;</div><div class="line">                proxySuperClass = rootClass.getSuperclass();</div><div class="line">                Class[] additionalInterfaces = rootClass.getInterfaces();</div><div class="line">                <span class="keyword">for</span> (Class additionalInterface : additionalInterfaces) &#123;</div><div class="line">                    <span class="keyword">this</span>.advised.addInterface(additionalInterface);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            validateClassIfNecessary(proxySuperClass, classLoader);</div><div class="line"></div><div class="line">            Enhancer enhancer = createEnhancer();</div><div class="line">            <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</div><div class="line">                enhancer.setClassLoader(classLoader);</div><div class="line">                <span class="keyword">if</span> ((classLoader <span class="keyword">instanceof</span> SmartClassLoader)</div><div class="line">                        &amp;&amp; (((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass))) &#123;</div><div class="line">                    enhancer.setUseCache(<span class="keyword">false</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            enhancer.setSuperclass(proxySuperClass);</div><div class="line">            enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</div><div class="line">            enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</div><div class="line">            enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</div><div class="line"></div><div class="line">            Callback[] callbacks = getCallbacks(rootClass);</div><div class="line">            Class[] types = <span class="keyword">new</span> Class[callbacks.length];</div><div class="line">            <span class="keyword">int</span> k;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; types.length; ++k) &#123;</div><div class="line">                types[k] = callbacks[k].getClass();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(<span class="keyword">this</span>.advised.getConfigurationOnlyCopy(),</div><div class="line">                    <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</div><div class="line">            enhancer.setCallbackTypes(types);</div><div class="line"></div><div class="line">            <span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</div><div class="line">        &#125; <span class="keyword">catch</span> (CodeGenerationException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Could not generate CGLIB subclass of class ["</span> + <span class="keyword">this</span>.advised.getTargetClass()</div><div class="line">                    + <span class="string">"]: "</span> + <span class="string">"Common causes of this problem include using a final class or a non-visible class"</span>, ex);</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Could not generate CGLIB subclass of class ["</span> + <span class="keyword">this</span>.advised.getTargetClass()</div><div class="line">                    + <span class="string">"]: "</span> + <span class="string">"Common causes of this problem include using a final class or a non-visible class"</span>, ex);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Unexpected AOP exception"</span>, ex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>用Proxy包装target之后，通过ProxyFactoryBean得到对其方法的调用就被Proxy拦截了， <strong><em>ProxyFactoryBean的getObject()方法得到的实际上是一个Proxy了，target对象已经被封装了。</em></strong>对 ProxyFactoryBean这个工厂bean而言，其生产出来的对象是封装了目标对象的代理对象。</p>
<h3 id="3-4拦截器的作用"><a href="#3-4拦截器的作用" class="headerlink" title="3.4拦截器的作用"></a>3.4拦截器的作用</h3><p>前面分析了SpringAOP实现中得到Proxy对象的过程，接下来我们去探寻Spring AOP中拦截器链是怎样被调用的，也就是Proxy模式是怎样起作用的。<br>还记得在JdkDynamicAopProxy中生成Proxy对象的时候，有一句这样的代码吗？</p>
<pre><code>return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
</code></pre><p>这里我们的JdkDynamicAopProxy实现了InvocationHandler这个接口，<code>final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable</code>.</p>
<p>this参数对应的是InvocationHandler对象,也就是说当 Proxy对象的函数被调用的时候，InvocationHandler的invoke方法会被作为回调函数调用.</p>
<p>我们来看一下动态代理中invoke函数的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        Object oldProxy = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</div><div class="line">        Class targetClass = <span class="keyword">null</span>;</div><div class="line">        Object target = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Object localObject1;</div><div class="line">            <span class="comment">//目标对象未实现equals方法</span></div><div class="line">            <span class="keyword">if</span> ((!(<span class="keyword">this</span>.equalsDefined)) &amp;&amp; (AopUtils.isEqualsMethod(method))) &#123;</div><div class="line">                localObject1 = Boolean.valueOf(equals(args[<span class="number">0</span>]));</div><div class="line">                <span class="keyword">return</span> localObject1;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//目标对象未实现hashcode方法</span></div><div class="line">            <span class="keyword">if</span> ((!(<span class="keyword">this</span>.hashCodeDefined)) &amp;&amp; (AopUtils.isHashCodeMethod(method))) &#123;</div><div class="line">                localObject1 = Integer.valueOf(hashCode());</div><div class="line">                <span class="keyword">return</span> localObject1;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//opaque顺序控制生成代理对象是否可以强制转换类型为advised，默认为false。</span></div><div class="line">            <span class="comment">//z这里针对opaque为true且代理的为借口自身，并且代理类为advised借口的子接口，不进行代理操作。</span></div><div class="line">            <span class="keyword">if</span> ((!(<span class="keyword">this</span>.advised.opaque)) &amp;&amp; (method.getDeclaringClass().isInterface())</div><div class="line">                    &amp;&amp; (method.getDeclaringClass().isAssignableFrom(Advised.class))) &#123;</div><div class="line">            <span class="comment">//这里就是目标对象的调用</span></div><div class="line">                localObject1 = AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</div><div class="line">                <span class="keyword">return</span> localObject1;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//设置exposeproxy为true，让springaop框架将生成的当前代理对象绑定到threadlocal</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</div><div class="line">                oldProxy = AopContext.setCurrentProxy(proxy);</div><div class="line">                setProxyContext = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//这里是得到目标对象，目标对象可能来自一个示例池或者一个简单的java对象。</span></div><div class="line">            target = targetSource.getTarget();</div><div class="line">            <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</div><div class="line">                targetClass = target.getClass();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//重要！！！：：：这里获得定义好的拦截器链</span></div><div class="line">            List chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</div><div class="line">            Object retVal;</div><div class="line">            Object retVal;</div><div class="line">            <span class="comment">//如果没有拦截器，直接调用目标的对象方法，不创建methodinvocation</span></div><div class="line">            <span class="keyword">if</span> (chain.isEmpty()) &#123;</div><div class="line">                Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</div><div class="line">                retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//如果有拦截器的设定，那么需要调用拦截器之后才能调用目标对象的相应的方法。</span></div><div class="line">                <span class="comment">//通过构造一个ReflectiveMethodInvocation来实现</span></div><div class="line">                MethodInvocation invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass,</div><div class="line">                        chain);</div><div class="line">                <span class="comment">//通过ReflectiveMethodInvocation来调用拦截器连和相应的目标方法。</span></div><div class="line">                <span class="comment">//在proceed方法内部实现了自身的递归调用来便利整个拦截器链。</span></div><div class="line"></div><div class="line">                retVal = invocation.proceed();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Class returnType = method.getReturnType();</div><div class="line">            <span class="keyword">if</span> ((retVal != <span class="keyword">null</span>) &amp;&amp; (retVal == target) &amp;&amp; (returnType.isInstance(proxy))</div><div class="line">                    &amp;&amp; (!(RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())))) &#123;</div><div class="line">                retVal = proxy;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((retVal == <span class="keyword">null</span>) &amp;&amp; (returnType != Void.TYPE) &amp;&amp; (returnType.isPrimitive())) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</div><div class="line">                        <span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Object localObject2 = retVal;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> localObject2;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> ((target != <span class="keyword">null</span>) &amp;&amp; (!(targetSource.isStatic()))) &#123;</div><div class="line">                <span class="comment">//释放gettarget方法获取的target对象，和targetsource实现有关</span></div><div class="line">                targetSource.releaseTarget(target);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (setProxyContext) &#123;</div><div class="line">                AopContext.setCurrentProxy(oldProxy);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上面所说的目标对象方法的调用，是通过AopUtils的方法调用，使用反射机制来对目标对象的方法进行的;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">invokeJoinpointUsingReflection</span><span class="params">(Object target, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ReflectionUtils.makeAccessible(method);</div><div class="line">        <span class="keyword">return</span> method.invoke(target, args);</div><div class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> ex.getTargetException();</div><div class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">"AOP configuration seems to be invalid: tried calling method ["</span> + method</div><div class="line">                + <span class="string">"] on target ["</span> + target + <span class="string">"]"</span>, ex);</div><div class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">"Could not access method ["</span> + method + <span class="string">"]"</span>, ex);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，我们来看具体的ReflectiveMethodInvocation中proceed()方法的实现，也就是拦截器链的实现机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">//重点！！！currentInterceptorIndex初始化值为-1，首先判断长度是否为0，为0直接调用目标对象的方法。</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> invokeJoinpoint();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Object interceptorOrInterceptionAdvice = <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers</div><div class="line">                .get(++<span class="keyword">this</span>.currentInterceptorIndex);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</div><div class="line">            <span class="comment">//匹配逻辑，只要方法匹配就调用拦截器，不匹配，跳过这个拦截器，调用下一个。</span></div><div class="line">            InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</div><div class="line">            <span class="comment">//需要注意一点，我们这里虽然反悔了，但是匹配到的拦截器自身的invoke方法还是会调用的，</span></div><div class="line">            <span class="comment">//继续遍历拦截器链</span></div><div class="line">            <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</div><div class="line">                <span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//没匹配， 调用下一个拦截器，重复上面逻辑</span></div><div class="line">            <span class="keyword">return</span> proceed();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果是MethodInterceptor，我们调用invoke方法，主要为了兼容原始aop联盟的东西，</span></div><div class="line">        <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从上面的分析我们看到了Spring AOP拦截机制的基本实现，比如Spring怎样得到Proxy，怎样利用JAVA Proxy以及反射机制对用户定义的拦截器链进行处理。</p>
<h3 id="3-5织入的实现"><a href="#3-5织入的实现" class="headerlink" title="3.5织入的实现"></a>3.5织入的实现</h3><p>在上面调用拦截器的时候，经过一系列的注册，适配的过程以后，拦截器在拦截的时候，会调用到预置好的一个通知适配器，设置通知拦截器，这是一系列Spring设计好为通知服务的类的一个，是最终完成通知拦截和实现的地方，例如对 MethodBeforeAdviceInterceptor的实现是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodBeforeAdviceInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> MethodBeforeAdvice advice;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodBeforeAdviceInterceptor</span><span class="params">(MethodBeforeAdvice advice)</span> </span>&#123;</div><div class="line">        Assert.notNull(advice, <span class="string">"Advice must not be null"</span>);</div><div class="line">        <span class="keyword">this</span>.advice = advice;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());</div><div class="line">        <span class="comment">//这个invoke方法是拦截器的回调方法，会在代理对象的方法被调用的时候出发回调</span></div><div class="line">        <span class="keyword">return</span> mi.proceed();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到通知适配器将advice适配成Interceptor以后，会调用advice的before方法去执行横切逻辑。这样就成功的完成了before通知的织入。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/03/Spring-AOP源码分析/" itemprop="url">
                  Spring_AOP源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-11-03T01:15:11+08:00" content="2016-11-03">
              2016-11-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spring-AOP-源码分析"><a href="#Spring-AOP-源码分析" class="headerlink" title="Spring AOP 源码分析"></a>Spring AOP 源码分析</h1><h2 id="零-Spring-aop的使用"><a href="#零-Spring-aop的使用" class="headerlink" title="零.Spring aop的使用"></a>零.Spring aop的使用</h2><p>想要分析aop源码。总要先知道spring aop怎么使用吧。要不然，分析个orz…</p>
<p>使用Spring AOP可以基于两种方式，一种是比较方便和强大的注解方式，另一种则是中规中矩的xml配置方式。</p>
<h3 id="0-1-基于注解的使用"><a href="#0-1-基于注解的使用" class="headerlink" title="0.1 基于注解的使用"></a>0.1 基于注解的使用</h3><p>第一步xml配置：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd
    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;

    &lt;!-- 激活组件扫描功能,在包cn.ysh.studio.spring.aop及其子包下面自动扫描通过注解配置的组件 --&gt;
    &lt;context:component-scan base-package=&quot;cn.ysh.studio.spring.aop&quot;/&gt;
    &lt;!-- 激活自动代理功能 --&gt;
    &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;

    &lt;!-- 用户服务对象 --&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;cn.ysh.studio.spring.aop.service.UserService&quot; /&gt;

&lt;/beans&gt;
</code></pre><p>第二步是为Aspect切面类添加注解：</p>
<!--lang: java--> 
<pre><code>@Component
//声明这是一个切面Bean
@Aspect
public class ServiceAspect {

    private final static Log log = LogFactory.getLog(ServiceAspect.class);

    //配置切入点,该方法无方法体,主要为方便同类中其他方法使用此处配置的切入点
    @Pointcut(&quot;execution(* cn.ysh.studio.spring.aop.service..*(..))&quot;)
    public void aspect(){    }

    /*
     * 配置前置通知,使用在方法aspect()上注册的切入点
     * 同时接受JoinPoint切入点对象,可以没有该参数
     */
    @Before(&quot;aspect()&quot;)
    public void before(JoinPoint joinPoint){
        if(log.isInfoEnabled()){
            log.info(&quot;before &quot; + joinPoint);
        }
    }

    //配置后置通知,使用在方法aspect()上注册的切入点
    @After(&quot;aspect()&quot;)
    public void after(JoinPoint joinPoint){
        if(log.isInfoEnabled()){
            log.info(&quot;after &quot; + joinPoint);
        }
    }

    //配置环绕通知,使用在方法aspect()上注册的切入点
    @Around(&quot;aspect()&quot;)
    public void around(JoinPoint joinPoint){
        long start = System.currentTimeMillis();
        try {
            ((ProceedingJoinPoint) joinPoint).proceed();
            long end = System.currentTimeMillis();
            if(log.isInfoEnabled()){
                log.info(&quot;around &quot; + joinPoint + &quot;\tUse time : &quot; + (end - start) + &quot; ms!&quot;);
            }
        } catch (Throwable e) {
            long end = System.currentTimeMillis();
            if(log.isInfoEnabled()){
                log.info(&quot;around &quot; + joinPoint + &quot;\tUse time : &quot; + (end - start) + &quot; ms with exception : &quot; + e.getMessage());
            }
        }
    }

    //配置后置返回通知,使用在方法aspect()上注册的切入点
    @AfterReturning(&quot;aspect()&quot;)
    public void afterReturn(JoinPoint joinPoint){
        if(log.isInfoEnabled()){
            log.info(&quot;afterReturn &quot; + joinPoint);
        }
    }

    //配置抛出异常后通知,使用在方法aspect()上注册的切入点
    @AfterThrowing(pointcut=&quot;aspect()&quot;, throwing=&quot;ex&quot;)
    public void afterThrow(JoinPoint joinPoint, Exception ex){
        if(log.isInfoEnabled()){
            log.info(&quot;afterThrow &quot; + joinPoint + &quot;\t&quot; + ex.getMessage());
        }
    }

}
</code></pre><!---> 

第三步测试：

    public class Tester {

        private final static Log log = LogFactory.getLog(Tester.class);

        public static void main(String[] args) {
            //启动Spring容器
            ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
            //获取service组件
            UserService service = (UserService) context.getBean("userService");
            //以普通的方式调用UserService对象的三个方法
            User user = service.get(1L);
            service.save(user);
            try {
                service.delete(1L);
            } catch (Exception e) {
                if(log.isWarnEnabled()){
                    log.warn("Delete user : " + e.getMessage());
                }
            }
        }
    }

### 0.2 xml配置 ###

    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:context="http://www.springframework.org/schema/context"
        xmlns:aop="http://www.springframework.org/schema/aop"
        xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd
            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd">


        <!-- 系统服务组件的切面Bean -->
<pre><code>    &lt;bean id=&quot;serviceAspect&quot; class=&quot;cn.ysh.studio.spring.aop.aspect.ServiceAspect&quot;/&gt;
    &lt;!-- AOP配置 --&gt;
    &lt;aop:config&gt;
        &lt;!-- 声明一个切面,并注入切面Bean,相当于@Aspect --&gt;
        &lt;aop:aspect id=&quot;simpleAspect&quot; ref=&quot;serviceAspect&quot;&gt;
            &lt;!-- 配置一个切入点,相当于@Pointcut --&gt;
            &lt;aop:pointcut expression=&quot;execution(* cn.ysh.studio.spring.aop.service..*(..))&quot; id=&quot;simplePointcut&quot;/&gt;
            &lt;!-- 配置通知,相当于@Before、@After、@AfterReturn、@Around、@AfterThrowing --&gt;
            &lt;aop:before pointcut-ref=&quot;simplePointcut&quot; method=&quot;before&quot;/&gt;
            &lt;aop:after pointcut-ref=&quot;simplePointcut&quot; method=&quot;after&quot;/&gt;
            &lt;aop:after-returning pointcut-ref=&quot;simplePointcut&quot; method=&quot;afterReturn&quot;/&gt;
            &lt;aop:after-throwing pointcut-ref=&quot;simplePointcut&quot; method=&quot;afterThrow&quot; throwing=&quot;ex&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre><p>AOP用起来还是很简单的。就把xml配置好就算完工了。有Advisor和aspect两种方式来完成。如果是用Advisor的话需要实现AfterReturningAdvice，MethodBeforeAdvice，ThrowsAdvice等接口。而如果用aspect的话则不用继承或者实现其他的类，一个普通的类即可。</p>
<h2 id="一．AOP介绍"><a href="#一．AOP介绍" class="headerlink" title="一．AOP介绍"></a>一．AOP介绍</h2><p>软件开发经历了从汇编语言到高级语言和从过程化编程到面向对象编程；前者是为了提高开发效率，而后者则使用了归纳法，把具有共性的东西进行归类并使之模块化，达到便于维护和扩展的目的；如果说面向对象编程可以对业务需求进行很好的分解使之模块化；那么面向切面编程AOP（Aspect-Oriented Programming）则可以对系统需求进行很好的模软件开发经历了从汇编语言到高级语言和从过程化编程到面向对象编程；前者是为了提高开发效率，而后者则使用了归纳法，把具有共性的东西进行归类并使之模块化，达到便于维护和扩展的目的；如果说面向对象编程可以对业务需求进行很好的分解使之模块化；那么面向切面编程AOP（Aspect-Oriented Programming）则可以对系统需求进行很好的模块组织，简化系统需求和实现之间的对比关系，是对OOP思想的一种补充；块组织，简化系统需求和实现之间的对比关系，是对OOP思想的一种补充。</p>
<p>举个例子来说明一下吧！现在系统中有很多的业务方法，如上传产品信息、修改产品信息、发布公司库等；现在需要对这些方法的执行做性能监控，看每个业务方法的执行时间；在不改变原业务代码的基础上，也许我们会这么做。</p>
<p>Offer接口：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public interface IOffer {
    public void postOffer();
    public void modifyOffer();
}
</code></pre><p>Offer实现：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public class OfferImpl implements IOffer {
    public void postOffer() {
        System.out.println(&quot;post offer&quot;);
    }

    public void modifyOffer() {
        System.out.println(&quot;modify offer&quot;);
    }
}
</code></pre><p>工具类：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public class PerformanceUtil {
    public static long start=0;
    public static long end=0;
    public static void startPerformance(){
        start=System.currentTimeMillis();
    }
    public static void endPerformance(){
        end=System.currentTimeMillis();
        System.out.println(&quot;method use:&quot;+(end-start));
    }
}
</code></pre><p>Offer代理：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public class OfferProxy implements IOffer {

    private IOffer delegate;

    public OfferProxy(IOffer delegate){
        this.delegate=delegate;
    }
    public void postOffer() {
        PerformanceUtil.startPerformance();
        delegate.postOffer();
        PerformanceUtil.endPerformance();
    }

    public void modifyOffer() {
        PerformanceUtil.startPerformance();
        delegate.modifyOffer();
        PerformanceUtil.endPerformance();
    }

}
</code></pre><p>Offer测试：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public class TestProxy {
    public static void main(String[] args) {
        IOffer offer= new OfferProxy(new OfferImpl());
        offer.postOffer();
        offer.modifyOffer();
    }
}
</code></pre><p>输出：</p>
<pre><code>post offer
method use:1
modify offer
method use:0
</code></pre><p>上面的例子中，OfferProxy实现了IOffer，而所有的业务实现均委托给其成员offer；可以想像，这应该就是最简单的AOP的实现了；但这种方式会存在一个问题：如果有非常多的这种业务对象需要性能监控，我们就需要写同样多的XyzProxy来满足需求，这也是非常巨大的工作量。</p>
<h2 id="二．-代理模式"><a href="#二．-代理模式" class="headerlink" title="二．    代理模式"></a>二．    代理模式</h2><p>代理模式中，存在一个称为ProxyObject的代理对象和RealObject的真实对象，它们都实现了相同的接口；在调用的地方持有ProxyObject的实例，当调用request()方法时，ProxyObject可以在执行RealObject.request()前后做一些特定的业务，甚至不调用RealObject.request()方法。</p>
<p>目前实现代理模式的方式有两种：基于JDK的动态代理和基于CGLIB字节码的代理。</p>
<h3 id="2-1-JDK动态代理"><a href="#2-1-JDK动态代理" class="headerlink" title="2.1 JDK动态代理"></a>2.1 JDK动态代理</h3><p>JDK动态代理，顾名思义，是基于JDK的反射(reflect)机制；在JDK中，提供了InvocationHandler这个接口。</p>
<p>注释如下：</p>
<pre><code>InvocationHandler is the interface implemented by the invocation handler of a proxy instance.
Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.
</code></pre><p>意思是说：该接口由被代理对象的handler所实现；当调用代理对象的方法时，该方法调用将被编码，然后交给代理对象的invoke方法去执行。<br>因此上面的代码可以改写成如下所示：</p>
<p>实现：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyFactory implements InvocationHandler {
    private Object delegate;

    public Object bind(Object delegate){
        this.delegate= delegate;
        return Proxy.newProxyInstance(delegate.getClass().getClassLoader(), 
                delegate.getClass().getInterfaces(), this);
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        PerformanceUtil.startPerformance();
        Object result=null;
        try {
            result=method.invoke(delegate, args);
        } catch (Exception e) {
            // TODO: handle exceptions
        }
        PerformanceUtil.endPerformance();
        return result;
    }

}
</code></pre><p>测试：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public class TestJDKProxy {
    public static void main(String[] args) {
        IOffer offer = (IOffer) new ProxyFactory().bind(new OfferImpl());
        offer.postOffer();
        offer.modifyOffer();
    }
}
</code></pre><p>结果：</p>
<pre><code>post offer
method use:1
modify offer
method use:0
</code></pre><p>通过这种方式，你不需要为针对每一个业务写一个代理对象，就可以很轻松地完成你的需求；但也许你已经注意到了，JDK的动态代理，在创建代理对象(上面红色代码部分)时，被代理的对象需要实现接口(即面向接口编程)；</p>
<h3 id="2-2CGLIB代理方式"><a href="#2-2CGLIB代理方式" class="headerlink" title="2.2CGLIB代理方式"></a>2.2CGLIB代理方式</h3><p>如果目标对象没有实现任何接口，那怎么办呢？不用担心，你可以用CGLIB来实现代理。</p>
<p>实现：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

import java.lang.reflect.Method;

import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;


public class CglibProxyFactory  implements MethodInterceptor{

    private Object delegate;

    public Object bind(Object delegate){
        this.delegate=delegate;
        Enhancer enhancer= new Enhancer();
        enhancer.setSuperclass(delegate.getClass());
        enhancer.setCallback(this);
        return enhancer.create();
    }
    public Object intercept(Object object, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        PerformanceUtil.startPerformance();
        Object o =proxy.invoke(this.delegate, args);
        PerformanceUtil.endPerformance();
        return o;
    }

}
</code></pre><p>测试类：</p>
<pre><code>package edu.zju.cs.lyp.Spring_aop;

public class TestCglibProxy {
    public static void main(String[] args) {
        DefaultOffer defaultOffer= (DefaultOffer) new CglibProxyFactory().bind(new DefaultOffer());
        defaultOffer.postOffer();
        defaultOffer.modifyOffer();
    }
}
</code></pre><p>测试结果：</p>
<pre><code>post offer
method use:20
modify offer
method use:0
</code></pre><p>使用CGLIB创建的代理对象，其实就是继承了要代理的目标类，然后对目标类中所有非final方法进行覆盖，但在覆盖方法时会添加一些拦截代码(上面CglibProxyFactory类中的intercept方法)。</p>
<h2 id="三．-Spring-AOP-实现"><a href="#三．-Spring-AOP-实现" class="headerlink" title="三．    Spring AOP 实现"></a>三．    Spring AOP 实现</h2><h3 id="3-1-Spring-AOP-几个基本概念"><a href="#3-1-Spring-AOP-几个基本概念" class="headerlink" title="3.1 Spring AOP 几个基本概念"></a>3.1 Spring AOP 几个基本概念</h3><p>Spring AOP jar包：<strong>spring-aop-4.2.5.release.jar</strong></p>
<p>Spring AOP中的几个基本概念，每次学习AOP都被这几个概念折腾的很不爽，我们在这里再把这几个概念描述一遍，力争把这几个概念搞清，在每次review这块内容的时候可以很快上手。</p>
<ol>
<li>切面(Aspect)：切面就是一个关注点的模块化，如事务管理、日志管理、权限管理等；</li>
<li>连接点(Joinpoint)：程序执行时的某个特定的点，在Spring中就是一个方法的执行；</li>
<li>通知(Advice)：通知就是在切面的某个连接点上执行的操作，也就是事务管理、日志管理等；</li>
<li>切入点(Pointcut)：切入点就是描述某一类选定的连接点，也就是指定某一类要织入通知的方法；</li>
<li>目标对象(Target)：就是被AOP动态代理的目标对象；</li>
</ol>
<p>用一张图来形象地表达AOP的概念及其关系如下：</p>
<p><img src="http://i.imgur.com/SoF1QtC.png" alt=""></p>
<h3 id="3-2-Spring-AOP-中切入点、通知、切面的实现"><a href="#3-2-Spring-AOP-中切入点、通知、切面的实现" class="headerlink" title="3.2 Spring AOP 中切入点、通知、切面的实现"></a>3.2 Spring AOP 中切入点、通知、切面的实现</h3><p>理解了上面的几个概念后，我们分别来看看Spring AOP是如何实现这些概念的；</p>
<h4 id="3-2-1-切入点-Pointcut"><a href="#3-2-1-切入点-Pointcut" class="headerlink" title="3.2.1.切入点(Pointcut)"></a>3.2.1.切入点(Pointcut)</h4><p>它定义了哪些连接点需要被织入横切逻辑；在Java中，连接点对应哪些类(接口)的方法。因此，我们都能猜到，所谓的切入点，就是定义了匹配哪些娄的哪些方法的一些规则，可以是静态的基于类(方法)名的值匹配，也可以是基于正则表达式的模式匹配。</p>
<p>来看看Spring AOP Pointcut相关的类图：</p>
<p><img src="http://i.imgur.com/0Fpm5dB.png" alt=""></p>
<p>在Pointcut接口的定义中，也许你已经想到了，ClassFilter是类过滤器，它定义了哪些类名需要拦截；典型的两个实现类为TypePatternClassFilter和TrueClassFilter(所有类均匹配)；而MethodMatcher为方法匹配器，定义哪些方法需要拦截。</p>
<p>在上面的类图中：</p>
<ul>
<li>StaticMethodMatch与DynamicMethodMatch的区别是后者在运行时会依据方法的参数值进行匹配。</li>
<li>NameMatchMethodPointCut根据指定的mappedNames来匹配方法。</li>
<li>AbstractRegexpMethodPointCut根据正则表达式来匹配方法</li>
</ul>
<p>类图中部分代码实现：</p>
<p>MethodMatcher.class:</p>
<pre><code>package org.springframework.aop;

import java.lang.reflect.Method;

public abstract interface MethodMatcher {
    public static final MethodMatcher TRUE = TrueMethodMatcher.INSTANCE;

    public abstract boolean matches(Method paramMethod, Class&lt;?&gt; paramClass);

    public abstract boolean isRuntime();

    public abstract boolean matches(Method paramMethod, Class&lt;?&gt; paramClass, Object[] paramArrayOfObject);
}
</code></pre><p>StaticMethodMatcher.class:</p>
<pre><code>package org.springframework.aop.support;

import java.lang.reflect.Method;
import org.springframework.aop.MethodMatcher;

public abstract class StaticMethodMatcher implements MethodMatcher {
    public final boolean isRuntime() {
        return false;
    }

    public final boolean matches(Method method, Class&lt;?&gt; targetClass, Object[] args) {
        throw new UnsupportedOperationException(&quot;Illegal MethodMatcher usage&quot;);
    }
}
</code></pre><p>DynamicMethodMatcher.class:</p>
<pre><code>package org.springframework.aop.support;

import java.lang.reflect.Method;
import org.springframework.aop.MethodMatcher;

public abstract class DynamicMethodMatcher implements MethodMatcher {
    public final boolean isRuntime() {
        return true;
    }

    public boolean matches(Method method, Class&lt;?&gt; targetClass) {
        return true;
    }
}
</code></pre><p>Pointcut.class:</p>
<pre><code>package org.springframework.aop;

public abstract interface Pointcut {
    public static final Pointcut TRUE = TruePointcut.INSTANCE;

    public abstract ClassFilter getClassFilter();

    public abstract MethodMatcher getMethodMatcher();
}
</code></pre><h4 id="3-2-2-通知-Advice"><a href="#3-2-2-通知-Advice" class="headerlink" title="3.2.2.通知(Advice)"></a>3.2.2.通知(Advice)</h4><p>通知定义了具体的横切逻辑。在Spring中，存在两种类型的Advice，即per-class和per-instance的Advice。</p>
<p>所谓per-class，即该类型的Advice只提供方法拦截，不会为目标对象保存任何状态或者添加新的特性，它也是我们最常见的Advice。下面是per-class的类图：</p>
<p><img src="http://i.imgur.com/tGVnfQi.png" alt=""></p>
<ul>
<li>BeforeAdvice：在连接点前执行的横切逻辑。</li>
<li>AfterReturningAdvice：在连接点执行后，再执行横切逻辑。</li>
<li>AfterAdvice：一般由程序自己实现，当抛出异常后，执行横切逻辑。</li>
<li>AroundAdvice：Spring AOP中并没有提供这个接口，而是采用了AOP Alliance的MethodInteceptor接口；通过看AfterReturningAdvice的源码我们知道，它是不能更改连接点所在方法的返回值的(更改引用)；但使用的MethodInteceptor，所有的事情，都不在话下。</li>
</ul>
<p>部分源码介绍：</p>
<p>AfterAdvice,Advice两个接口是空的</p>
<p>AfterReturningAdvice.class</p>
<pre><code>package org.springframework.aop;

import java.lang.reflect.Method;

public abstract interface AfterReturningAdvice extends AfterAdvice {
    public abstract void afterReturning(Object paramObject1, Method paramMethod, Object[] paramArrayOfObject,
            Object paramObject2) throws Throwable;
}
</code></pre><p>MethodBeforeAdvice.class</p>
<pre><code>import java.lang.reflect.Method;

public abstract interface MethodBeforeAdvice extends BeforeAdvice {
    public abstract void before(Method paramMethod, Object[] paramArrayOfObject, Object paramObject) throws Throwable;
}
</code></pre><p>MethodInterceptor.class</p>
<pre><code>package org.aopalliance.intercept;

public abstract interface MethodInterceptor extends Interceptor {
    public abstract Object invoke(MethodInvocation paramMethodInvocation) throws Throwable;
}
</code></pre><p>在上面的类图中，还有两种类没有介绍，那就是 <strong><em>AdviceAdapter 和 </em></strong>AdviceInteceptor.结构如图所示<br><img src="http://i.imgur.com/0ooNuhA.png" alt=""></p>
<p>我们以AfterReturningAdviceInterceptor为例来说明：</p>
<pre><code>package org.springframework.aop.framework.adapter;

import java.io.Serializable;
import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.springframework.aop.AfterAdvice;
import org.springframework.aop.AfterReturningAdvice;
import org.springframework.util.Assert;

public class AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice, Serializable {
    private final AfterReturningAdvice advice;

    public AfterReturningAdviceInterceptor(AfterReturningAdvice advice) {
        Assert.notNull(advice, &quot;Advice must not be null&quot;);
        this.advice = advice;
    }

    public Object invoke(MethodInvocation mi) throws Throwable {
        Object retVal = mi.proceed();
        this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());
        return retVal;
    }
}
</code></pre><p>该类实现了MethodInterceptor和AfterAdvice接口，同时构造函数中还有一个AfterReturningAdvice实例的参数；这个类存在的作用是为了什么呢？Spring AOP把所有的Advice都适配成了MethodInterceptor，统一的好处是方便后面横切逻辑的执行(参看下一节)，适配的工作即由<em>*</em>AdviceAdapter完成；</p>
<p>Spring AOP所谓的AfterReturningAdvice，通过适配成MethodInterceptor后，其实就是在invoke方法中，先执行目标对象的方法，再执行的AfterReturningAdvice所定义的横切逻辑。</p>
<p>对于per-instance的Advice，目前只有一种实现，就是Introduction，使用的场景比较少。</p>
<p><img src="http://i.imgur.com/EmLqrLw.png" alt=""></p>
<h4 id="3-2-3-切面-Aspect"><a href="#3-2-3-切面-Aspect" class="headerlink" title="3.2.3.切面(Aspect)"></a>3.2.3.切面(Aspect)</h4><p>在Spring中，Advisor就是切面；但与通常的Aspect不同的是，Advisor通常只有一个Pointcut和一个Advice，而Aspect则可以包含多个Pointcut和多个Advice，因此Advisor是一种特殊的Aspect。</p>
<p>接下来看下per-class Advisor的类图：</p>
<p><img src="http://i.imgur.com/rELgifs.png" alt=""></p>
<p>继承关系如下：</p>
<p><img src="http://i.imgur.com/oSYJlw4.png" alt=""></p>
<p>Advisor包含一个Pointcut和一个Advisor；在AbstractGenericPointcutAdvisor中，持有一个Advice的引用；下面的几个实现，均是针对前面提到的几种不同的Pointcut的实现。</p>
<h3 id="3-3-Spring-AOP实现基本线索"><a href="#3-3-Spring-AOP实现基本线索" class="headerlink" title="3.3 Spring AOP实现基本线索"></a>3.3 Spring AOP实现基本线索</h3><p>我们选择ProxyFactoryBean作为入口点和分析的开始。ProxyFactoryBean是在Spring IoC环境中，创建AOP应用的最底层方法，从中，可以看到一条实现AOP的基本线索。</p>
<p>所有的逻辑从以下的方法开始,我们主要针对单例的代理对象的生成：</p>
<pre><code>public Object getObject() throws BeansException {
    //这里初始化通知器链
    initializeAdvisorChain();
    if (isSingleton()) {
        //根据定义需要生成单例的proxy
        return getSingletonInstance();
    }

    if (this.targetName == null) {
        this.logger.warn(
                &quot;Using non-singleton proxies with singleton targets is often undesirable. Enable prototype proxies by setting the &apos;targetName&apos; property.&quot;);
    }
    //这里根据定义需要生成prototype类型的proxy
    return newPrototypeInstance();
}
</code></pre><p>下面我们深入到SpringAOP核心代码的内部，看看代理对象的生成机制，拦截器横切逻辑以及织入的实现。</p>
<pre><code>private synchronized Object getSingletonInstance() {
        if (this.singletonInstance == null) {
            //返回具体的目标对象，就是被代理的对象
            this.targetSource = freshTargetSource();
            if ((this.autodetectInterfaces) &amp;&amp; (getProxiedInterfaces().length == 0) &amp;&amp; (!(isProxyTargetClass()))) {
                //从targetsource中获取目标对象的class
                Class targetClass = getTargetClass();
                if (targetClass == null) {
                    throw new FactoryBeanNotInitializedException(&quot;Cannot determine target class for proxy&quot;);
                }
                //这里设置代理对象的借口
                setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader));
            }
            //这里使用proxyfactory来生成我们需要的proxy。
            super.setFrozen(this.freezeProxy);
            this.singletonInstance = getProxy(createAopProxy());
        }
        return this.singletonInstance;
    }
</code></pre><p>ProxyFactoryBean是AdvisedSupport的子类，Spring使用AopProxy接口把AOP代理的实现与框架的其他部分分离开来。在AdvisedSupport中通过这样的方式来得到AopProxy,当然这里需要得到AopProxyFactory的帮助 ，从JDK或者cglib中得到想要的代理对象：</p>
<pre><code>protected final synchronized AopProxy createAopProxy() {
        if (!(this.active)) {
            activate();
        }
        return getAopProxyFactory().createAopProxy(this);
    }
</code></pre><p>getAopProxyFactory()获取ProxyCreatorSupport的属性aopProxyFactory</p>
<pre><code>public AopProxyFactory getAopProxyFactory() {
        return this.aopProxyFactory;
    }
</code></pre><p>该属性被默认初始化为DefaultAopProxyFactory对象。</p>
<pre><code>public ProxyCreatorSupport() {
    this.aopProxyFactory = new DefaultAopProxyFactory();
}
public ProxyCreatorSupport(AopProxyFactory aopProxyFactory) {
        Assert.notNull(aopProxyFactory, &quot;AopProxyFactory must not be null&quot;);
        this.aopProxyFactory = aopProxyFactory;
    }
</code></pre><p>这个DefaultAopProxyFactory是Spring用来生成AopProxy的地方，它包含JDK和Cglib两种实现方式。让我接着往里面看：</p>
<pre><code>/*** Eclipse Class Decompiler plugin, copyright (c) 2016 Chen Chao (cnfree2000@hotmail.com) ***/
package org.springframework.aop.framework;

import java.io.Serializable;
import java.lang.reflect.Proxy;
import org.springframework.aop.SpringProxy;

public class DefaultAopProxyFactory implements AopProxyFactory, Serializable {
    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
        //做一些判断操作。isoptimize（）是指是否采取进一步的优化，true采用cglib来生成代理。
        //isproxytargetclass决定是否采用基于接口的代理。
        if ((config.isOptimize()) || (config.isProxyTargetClass()) || (hasNoUserSuppliedProxyInterfaces(config))) {
            Class targetClass = config.getTargetClass();
            if (targetClass == null) {
                throw new AopConfigException(
                        &quot;TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.&quot;);
            }
            //如果目标对象实现的接口，则采用jdk动态代理来生成proxy
            if ((targetClass.isInterface()) || (Proxy.isProxyClass(targetClass))) {
                return new JdkDynamicAopProxy(config);
            }
            //如果target不是接口的实现的话，返回cglib类型的aopproxy
            return new ObjenesisCglibAopProxy(config);
        }
        //不满足最开始的判断 直接使用jdk动态代理
        return new JdkDynamicAopProxy(config);
    }

    private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) {
        Class[] ifcs = config.getProxiedInterfaces();
        return ((ifcs.length == 0) || ((ifcs.length == 1) &amp;&amp; (SpringProxy.class.isAssignableFrom(ifcs[0]))));
    }
}
</code></pre><p>可以看到其中的代理对象可以由JDK或者Cglib来生成，JdkDynamicAopProxy类和Cglib2AopProxy都实现的是AopProxy的接口，我们进入JdkDynamicAopProxy实现中看看Proxy是怎样生成的：</p>
<pre><code>public JdkDynamicAopProxy(AdvisedSupport config) throws AopConfigException {
        Assert.notNull(config, &quot;AdvisedSupport must not be null&quot;);
        if ((config.getAdvisors().length == 0) &amp;&amp; (config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE)) {
            throw new AopConfigException(&quot;No advisors and no TargetSource specified&quot;);
        }
        this.advised = config;
    }

    public Object getProxy() {
        return getProxy(ClassUtils.getDefaultClassLoader());
    }

    public Object getProxy(ClassLoader classLoader) {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + this.advised.getTargetSource());
        }
        //根据advised中的配置信息，获取proxy需要代理的接口、放入proxiedInterfaces中。
        Class[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised);
        findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
        //这里我们调用jdk proxy 来生成需要的proxy实例
        return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
    }
</code></pre><p>再来看cglib代理</p>
<pre><code>class ObjenesisCglibAopProxy extends CglibAopProxy {
    private static final Log logger = LogFactory.getLog(ObjenesisCglibAopProxy.class);

    private static final SpringObjenesis objenesis = new SpringObjenesis();

    public ObjenesisCglibAopProxy(AdvisedSupport config) {
        super(config);
    }

    protected Object createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks) {
        Class proxyClass = enhancer.createClass();
        Object proxyInstance = null;

        if (objenesis.isWorthTrying()) {
            try {
                proxyInstance = objenesis.newInstance(proxyClass, enhancer.getUseCache());
            } catch (Throwable ex) {
                logger.debug(&quot;Unable to instantiate proxy using Objenesis, falling back to regular proxy construction&quot;,
                        ex);
            }

        }

        if (proxyInstance == null) {
            try {
                proxyInstance = (this.constructorArgs != null)
                        ? proxyClass.getConstructor(this.constructorArgTypes).newInstance(this.constructorArgs)
                        : proxyClass.newInstance();
            } catch (Throwable ex) {
                throw new AopConfigException(
                        &quot;Unable to instantiate proxy using Objenesis, and regular proxy instantiation via default constructor fails as well&quot;,
                        ex);
            }

        }

        ((Factory) proxyInstance).setCallbacks(callbacks);
        return proxyInstance;
    }
}
</code></pre><p>继承了CglibAopProxy。下面的和最开始的例子比较，是不是很熟悉。</p>
<pre><code>public Object getProxy(ClassLoader classLoader) {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Creating CGLIB proxy: target source is &quot; + this.advised.getTargetSource());
        }
        try {
            Class rootClass = this.advised.getTargetClass();
            Assert.state(rootClass != null, &quot;Target class must be available for creating a CGLIB proxy&quot;);

            Class proxySuperClass = rootClass;
            if (ClassUtils.isCglibProxyClass(rootClass)) {
                proxySuperClass = rootClass.getSuperclass();
                Class[] additionalInterfaces = rootClass.getInterfaces();
                for (Class additionalInterface : additionalInterfaces) {
                    this.advised.addInterface(additionalInterface);
                }

            }

            validateClassIfNecessary(proxySuperClass, classLoader);

            Enhancer enhancer = createEnhancer();
            if (classLoader != null) {
                enhancer.setClassLoader(classLoader);
                if ((classLoader instanceof SmartClassLoader)
                        &amp;&amp; (((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass))) {
                    enhancer.setUseCache(false);
                }
            }
            enhancer.setSuperclass(proxySuperClass);
            enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
            enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
            enhancer.setStrategy(new ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));

            Callback[] callbacks = getCallbacks(rootClass);
            Class[] types = new Class[callbacks.length];
            int k;
            for (int k = 0; k &lt; types.length; ++k) {
                types[k] = callbacks[k].getClass();
            }

            enhancer.setCallbackFilter(new ProxyCallbackFilter(this.advised.getConfigurationOnlyCopy(),
                    this.fixedInterceptorMap, this.fixedInterceptorOffset));
            enhancer.setCallbackTypes(types);

            return createProxyClassAndInstance(enhancer, callbacks);
        } catch (CodeGenerationException ex) {
            throw new AopConfigException(&quot;Could not generate CGLIB subclass of class [&quot; + this.advised.getTargetClass()
                    + &quot;]: &quot; + &quot;Common causes of this problem include using a final class or a non-visible class&quot;, ex);
        } catch (IllegalArgumentException ex) {
            throw new AopConfigException(&quot;Could not generate CGLIB subclass of class [&quot; + this.advised.getTargetClass()
                    + &quot;]: &quot; + &quot;Common causes of this problem include using a final class or a non-visible class&quot;, ex);
        } catch (Exception ex) {
            throw new AopConfigException(&quot;Unexpected AOP exception&quot;, ex);
        }
    }
</code></pre><p>用Proxy包装target之后，通过ProxyFactoryBean得到对其方法的调用就被Proxy拦截了， <strong><em>ProxyFactoryBean的getObject()方法得到的实际上是一个Proxy了，target对象已经被封装了。</em></strong>对 ProxyFactoryBean这个工厂bean而言，其生产出来的对象是封装了目标对象的代理对象。</p>
<h3 id="3-4拦截器的作用"><a href="#3-4拦截器的作用" class="headerlink" title="3.4拦截器的作用"></a>3.4拦截器的作用</h3><p>前面分析了SpringAOP实现中得到Proxy对象的过程，接下来我们去探寻Spring AOP中拦截器链是怎样被调用的，也就是Proxy模式是怎样起作用的。<br>还记得在JdkDynamicAopProxy中生成Proxy对象的时候，有一句这样的代码吗？</p>
<pre><code>return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
</code></pre><p>这里我们的JdkDynamicAopProxy实现了InvocationHandler这个接口，<code>final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable</code>.</p>
<p>this参数对应的是InvocationHandler对象,也就是说当 Proxy对象的函数被调用的时候，InvocationHandler的invoke方法会被作为回调函数调用.</p>
<p>我们来看一下动态代理中invoke函数的实现：</p>
<pre><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object oldProxy = null;
        boolean setProxyContext = false;

        TargetSource targetSource = this.advised.targetSource;
        Class targetClass = null;
        Object target = null;
        try {
            Object localObject1;
            //目标对象未实现equals方法
            if ((!(this.equalsDefined)) &amp;&amp; (AopUtils.isEqualsMethod(method))) {
                localObject1 = Boolean.valueOf(equals(args[0]));
                return localObject1;
            }
            //目标对象未实现hashcode方法
            if ((!(this.hashCodeDefined)) &amp;&amp; (AopUtils.isHashCodeMethod(method))) {
                localObject1 = Integer.valueOf(hashCode());
                return localObject1;
            }
            //opaque顺序控制生成代理对象是否可以强制转换类型为advised，默认为false。
            //z这里针对opaque为true且代理的为借口自身，并且代理类为advised借口的子接口，不进行代理操作。
            if ((!(this.advised.opaque)) &amp;&amp; (method.getDeclaringClass().isInterface())
                    &amp;&amp; (method.getDeclaringClass().isAssignableFrom(Advised.class))) {
            //这里就是目标对象的调用
                localObject1 = AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);
                return localObject1;
            }
            //设置exposeproxy为true，让springaop框架将生成的当前代理对象绑定到threadlocal
            if (this.advised.exposeProxy) {
                oldProxy = AopContext.setCurrentProxy(proxy);
                setProxyContext = true;
            }
            //这里是得到目标对象，目标对象可能来自一个示例池或者一个简单的java对象。
            target = targetSource.getTarget();
            if (target != null) {
                targetClass = target.getClass();
            }
            //重要！！！：：：这里获得定义好的拦截器链
            List chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
            Object retVal;
            Object retVal;
            //如果没有拦截器，直接调用目标的对象方法，不创建methodinvocation
            if (chain.isEmpty()) {
                Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
                retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
            } else {
                //如果有拦截器的设定，那么需要调用拦截器之后才能调用目标对象的相应的方法。
                //通过构造一个ReflectiveMethodInvocation来实现
                MethodInvocation invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass,
                        chain);
                //通过ReflectiveMethodInvocation来调用拦截器连和相应的目标方法。
                //在proceed方法内部实现了自身的递归调用来便利整个拦截器链。

                retVal = invocation.proceed();
            }

            Class returnType = method.getReturnType();
            if ((retVal != null) &amp;&amp; (retVal == target) &amp;&amp; (returnType.isInstance(proxy))
                    &amp;&amp; (!(RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())))) {
                retVal = proxy;
            } else if ((retVal == null) &amp;&amp; (returnType != Void.TYPE) &amp;&amp; (returnType.isPrimitive())) {
                throw new AopInvocationException(
                        &quot;Null return value from advice does not match primitive return type for: &quot; + method);
            }

            Object localObject2 = retVal;

            return localObject2;
        } finally {
            if ((target != null) &amp;&amp; (!(targetSource.isStatic()))) {
                //释放gettarget方法获取的target对象，和targetsource实现有关
                targetSource.releaseTarget(target);
            }
            if (setProxyContext) {
                AopContext.setCurrentProxy(oldProxy);
            }
        }
    }
</code></pre><p>上面所说的目标对象方法的调用，是通过AopUtils的方法调用，使用反射机制来对目标对象的方法进行的;</p>
<pre><code>public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) throws Throwable {
    try {
        ReflectionUtils.makeAccessible(method);
        return method.invoke(target, args);
    } catch (InvocationTargetException ex) {
        throw ex.getTargetException();
    } catch (IllegalArgumentException ex) {
        throw new AopInvocationException(&quot;AOP configuration seems to be invalid: tried calling method [&quot; + method
                + &quot;] on target [&quot; + target + &quot;]&quot;, ex);
    } catch (IllegalAccessException ex) {
        throw new AopInvocationException(&quot;Could not access method [&quot; + method + &quot;]&quot;, ex);
    }
}
</code></pre><p>接下来，我们来看具体的ReflectiveMethodInvocation中proceed()方法的实现，也就是拦截器链的实现机制：</p>
<pre><code>public Object proceed() throws Throwable {
        //重点！！！currentInterceptorIndex初始化值为-1，首先判断长度是否为0，为0直接调用目标对象的方法。
        if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {
            return invokeJoinpoint();
        }

        Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers
                .get(++this.currentInterceptorIndex);

        if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {
            //匹配逻辑，只要方法匹配就调用拦截器，不匹配，跳过这个拦截器，调用下一个。
            InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
            //需要注意一点，我们这里虽然反悔了，但是匹配到的拦截器自身的invoke方法还是会调用的，
            //继续遍历拦截器链
            if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {
                return dm.interceptor.invoke(this);
            }
            //没匹配， 调用下一个拦截器，重复上面逻辑
            return proceed();
        }
        //如果是MethodInterceptor，我们调用invoke方法，主要为了兼容原始aop联盟的东西，
        return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);
    }
</code></pre><p>从上面的分析我们看到了Spring AOP拦截机制的基本实现，比如Spring怎样得到Proxy，怎样利用JAVA Proxy以及反射机制对用户定义的拦截器链进行处理。</p>
<h3 id="3-5织入的实现"><a href="#3-5织入的实现" class="headerlink" title="3.5织入的实现"></a>3.5织入的实现</h3><p>在上面调用拦截器的时候，经过一系列的注册，适配的过程以后，拦截器在拦截的时候，会调用到预置好的一个通知适配器，设置通知拦截器，这是一系列Spring设计好为通知服务的类的一个，是最终完成通知拦截和实现的地方，例如对 MethodBeforeAdviceInterceptor的实现是这样的：</p>
<pre><code>public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable {
    private MethodBeforeAdvice advice;

    public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) {
        Assert.notNull(advice, &quot;Advice must not be null&quot;);
        this.advice = advice;
    }

    public Object invoke(MethodInvocation mi) throws Throwable {
        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());
        //这个invoke方法是拦截器的回调方法，会在代理对象的方法被调用的时候出发回调
        return mi.proceed();
    }
}
</code></pre><p>可以看到通知适配器将advice适配成Interceptor以后，会调用advice的before方法去执行横切逻辑。这样就成功的完成了before通知的织入。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/28/数据仓库三种变化类型/" itemprop="url">
                  数据仓库三种变化类型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-10-28T11:50:06+08:00" content="2016-10-28">
              2016-10-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据仓库/" itemprop="url" rel="index">
                    <span itemprop="name">数据仓库</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>类型1：对于数据元素的历史记录不重要的时候使用，当一个数据源变化的时候，对应的维度属性将会被覆盖，</p>
<p>类型2：当变化的数据元素历史记录也很重要的时候采用，源数据的元素变化的时候，会在维度表中插入新的一行来满足需求。</p>
<p>类型3：当所有分析伴随新值或者旧值的变化前后记录的事实时，需要使用到变化类型3.使用类型1和类型2是不能够解决的。<br>比如：分析所有事实的情况，使用的是新值记录变化发生前后的情况。</p>
<p>###3种事实表</p>
<p>1.事务事实表<br>描述事件，获取事件，或行为的细节</p>
<p>2.事务表快照<br>描述状态，获取事件或行为的效果</p>
<p>3.累计快照<br>累计快照可以跟踪业务流程的一个或多个步骤的时间间隔。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/24/深入理解JVM七-虚拟机类加载机制/" itemprop="url">
                  深入理解JVM七-虚拟机类加载机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-10-24T18:59:48+08:00" content="2016-10-24">
              2016-10-24
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>类从被加载到卸载，整个生命周期如下：</p>
<ul>
<li>加载（loading）</li>
<li>连接（验证verification 准备preparation 解析resolution）</li>
<li>初始化（initialization）</li>
<li>使用（using）</li>
<li>卸载（unloading）</li>
</ul>
<p>主动引用，触发类的初始化：</p>
<ul>
<li>1.遇到new getstatic putstatic invokestatic</li>
<li>2.使用java.lang.reflect包的方法对垒进行反射调用。</li>
<li>3.初始化一个类的时候，如果发现父类还没有进行过初始化，则先触发其父类的初始化。</li>
<li>4.当虚拟机启动时，用户需要制定一个要执行的主类，虚拟机则会先初始化这个主类。</li>
<li>5.当使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.methodhandle实例最后解析的结果ref_getstatic ref_putstatic ref_invokestatic 的方法句柄。</li>
</ul>
<p>主要过程参照另一篇blog<br><a href="http://raincoffee.info/2016/09/22/java%E7%B1%BB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/" title="类的加载初始化过程" target="_blank" rel="external">http://raincoffee.info/2016/09/22/java%E7%B1%BB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/</a></p>
<p>###类加载器###</p>
<p>1.类与类加载器<br>比较两个类食肉相等，只能有一个类加载器加载的前提下才有意义。否则，即使这两个类来源于同一个class文件，被同一个虚拟机加载，只要夹在他们的类加载器不同，拿着两个雷一定不同。</p>
<pre><code>package jvm;

import java.io.IOException;
import java.io.InputStream;


/**
 * 
 * @author neuly
 *
 */
public class ClassLoaderTest {
    public static void main(String[] args) throws Exception{
        ClassLoader myloader= new ClassLoader() {
                @Override
                public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException{
                    try {
                        String fileName=name.substring(name.lastIndexOf(&quot;.&quot;)+1)+&quot;.class&quot;;
                        InputStream is= getClass().getResourceAsStream(fileName);
                        if(is==null){
                            return super.loadClass(name);
                        }
                        byte[] b = new byte[is.available()];
                        is.read(b);
                        return defineClass(name, b, 0,b.length);
                    } catch (IOException e) {;; 
                        // TODO: handle exception
                        throw new ClassNotFoundException(name);
                    }

                }
            };
            Object obj =myloader.loadClass(&quot;jvm.ClassLoaderTest&quot;).newInstance();
            System.out.println(obj.getClass());
            System.out.println(obj instanceof jvm.ClassLoaderTest);
    }
}
</code></pre><p>结果 </p>
<pre><code>class jvm.ClassLoaderTest
false
</code></pre><p>代码加载与自己同一路径下的class文件。</p>
<p>###2.双亲委派模型###</p>
<p>自动类加载器<br>↑<br>扩展类加载器<br>↑<br>应用程序类加载器<br>↑<br>自定义类加载器</p>
<p>双亲委派工作过程：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，二十八请求为派给父类加载器去完成。每一个层次的类加载器都是如此，因此所有的加载请求最终都应传送到顶层的启动类加载器中，只有当弗雷加载器反馈自己不能完成这个加载请求时，自加载器才会尝试自己去加载。</p>
<p>###2.破坏双亲委派模型###</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/24/深入理解JVM六-类文件结构/" itemprop="url">
                  深入理解JVM六-类文件结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-10-24T16:36:18+08:00" content="2016-10-24">
              2016-10-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>class文件是一组以八位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在class文件中，中间没有添加任何分隔符，这使得整个class文件中存储的内容几乎全部都是程序运行的必要数据，没有空隙存在。当需要占用8位字节以上的空间数据时，则会按照高位在前的方式分割成若干个8位字节进行存储。</p>
<p>###class文件结构介绍：</p>
<p>根据java虚拟机规范的规定，class文件格式采用一种类似c语言结构体的伪结构来存储，这种伪结构中只有两种数据类型：无符号数和表。</p>
<p>无符号数：无符号数属于基本的数据类型，以u1,u2,u4,u8来分别代表1个字节，2个字节，4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值，或者按照utf-8编码构成字符串值。</p>
<p>表：表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info“结尾。表用于描述有层次关系的复合结构的数据，整个class文件本质上就是一张表，它由下列数据项构成：</p>
<pre><code>ClassFile {  
    u4 magic;//魔数(0xCAFEBABE)  
    u2 minor_version;//次版本号  
    u2 major_version;//主版本号  
    u2 constant_pool_count;//常量池容量计数值  
    cp_info constant_pool[constant_pool_count-1];//常量池  
    u2 access_flags;//访问标志  
    u2 this_class;//类索引  
    u2 super_class;//父类索引  
    u2 interfaces_count;//接口计数器  
    u2 interfaces[interfaces_count];//接口索引集合  
    u2 fields_count;//字段计数器  
    field_info fields[fields_count];//字段表  
    u2 methods_count;//方法计数器  
    method_info methods[methods_count];//方法表  
    u2 attributes_count;//属性表计数器  
    attribute_info attributes[attributes_count];//属性表集合  
}  
</code></pre><p>无论是无符号数还是表，当需要描述的同一类型但是数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式（比如说一个类可能实现了多个接口，这时候需要一个计数器来指定接口的数量），这时候称这一系列连续的某一类型的数据为某一类型的集合。上面的文件格式是固定的，每个数据项的顺序，占用字节数都是被严格限定的，不允许改变。</p>
<p>1.魔数：class文件头四个字节代表魔数，它的作用是用于确定该文件是一个能被虚拟机接受的class文件,其值为0xCAFEBABE.</p>
<p>2.版本：魔数后四个字节代表class文件的版本号，其中前两个字节代表次版本号，后两个字节代表主版本号。高版本的jdk能向下兼容以前版本的class文件，但不能运行以后版本的class文件。</p>
<p>3.常量池：主版本之后的是常量池入口，常量池是class文件结构中与其他项目关联最多的数据类型，也是占用class文件空间最大的数据项目之一，同时还是在class文件中第一个出现的表类型的数据项目。因为常量池中常量数量不固定，所以在常量池入口前需要放置一个计数器，占用两个字节。比如如果该位置的值为0x0016,那就代表常量池中有21项常量（从1开始），第0项空出来是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达”不引用任何一个常量池项目“的意思，这种情况就可以把索引置为0来表示。class文件结构只有常量池的容量计数器是从1开始的，其他集合类型都是从0开始的。<br>    常量池中主要存放两类数据：字面量和符号引用；<br>（1）字面量：比如文本字符串，被声明为final的常量值等。<br>（2）符号引用：包括类和接口的权限定名，字段的名称和描述符，方法的名称和描述符。</p>
<p>4.访问标志（access_flags）：常量池之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息（比如这个class是否是public是否是final等等)。</p>
<p>5.类索引，父类索引，接口索引：类索引和父类索引都是一个u2类型的数据，而接口索引集合时一组u2类型的数据的集合，class文件中由这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名（除了kava.lang.Object以外所有类的父类索引均不为0）。接口索引集合用来描述这个类实现了哪些接口。<br>    类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。</p>
<p>6.字段表集合：字段表集合用于描述接口或者类中声明的变量。字段包括了类级变量或者实例级变量，但是不包括方法内部声明的变量。</p>
<p>7.方法表集合：内容跟属性表集合基本一致</p>
<p>8.属性表集合：在class文件、字段表、方法表中都可以携带字节的属性表集合，用于描述某些场景专有的信息。属性表中的数据项目不需要有严格的顺序，java虚拟机在运行时会自动的忽略掉不认识的属性，其中系统预定义了9种虚拟机应该识别的属性，</p>
<p>连接：<br><a href="http://blog.csdn.net/kobejayandy/article/details/39620833" target="_blank" rel="external">http://blog.csdn.net/kobejayandy/article/details/39620833</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/24/深入理解JVM笔记五/" itemprop="url">
                  深入理解JVM笔记五-调优案例分析与实战
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-10-24T15:00:22+08:00" content="2016-10-24">
              2016-10-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>高性能硬件上部署程序，目前主要有两种方式：</p>
<ul>
<li>使用64位JDK来使用大内存</li>
<li>使用若干个32位虚拟机建立逻辑集群来利用硬件资源</li>
</ul>
<p>集群间同步导致的内存溢出；</p>
<p>堆外内存导致的溢出错误：</p>
<p>direct memory:可通过-XX：MaxDirectMemorySize调整大小，内存不足会抛出outofmemory或者outofmemoryerror：direct buffer memory。</p>
<p>线程堆栈：通过-Xss调整大小。不足抛出stackoverflowerror。</p>
<p>eclipse性能调优参考深入理解jvm第5章</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/23/兰天震的设计/" itemprop="url">
                  兰天震的设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-10-23T20:45:12+08:00" content="2016-10-23">
              2016-10-23
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://i.imgur.com/x94fo9Q.jpg" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/21/深入理解JVM笔记四/" itemprop="url">
                  深入理解JVM笔记四-虚拟机性能监控与故障处理工具
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-10-21T16:22:24+08:00" content="2016-10-21">
              2016-10-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###jdk命令行工具</p>
<p>1.jps<br>虚拟机进程状态工具</p>
<pre><code>常用的几个参数：
-l   输出Java应用程序的main class的完整包

-q 仅显示pid，不显示其它任何相关信息

-m 输出传递给main方法的参数

-v 输出传递给JVM的参数。在诊断JVM相关问题的时候，这个参数可以查看JVM相关参数的设置
</code></pre><p>2.jstat</p>
<p>虚拟机统计信息监视工具</p>
<pre><code>C:\Program Files\Java\jdk1.8.0_91\bin&gt;jstat -gcutil 1676
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT
  0.00 100.00  53.66  80.08  91.20  81.37     72    2.443     0    0.000    2.443

C:\Program Files\Java\jdk1.8.0_91\bin&gt;jstat -gc 1676
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
 0.0   6144.0  0.0   6144.0 83968.0  53248.0   172032.0   137768.9  173184.0 157951.9 23168.0 18851.1     72    2.443   0      0.000    2.443
</code></pre><blockquote>
<p>堆内存 = 年轻代 + 年老代 + 永久代</p>
<p>年轻代 = Eden区 + 两个Survivor区（From和To）</p>
<p>S0C、S1C、S0U、S1U：Survivor 0/1区容量（Capacity）和使用量（Used）</p>
<p>EC、EU：Eden区容量和使用量</p>
<p>OC、OU：年老代容量和使用量</p>
<p>PC、PU：永久代容量和使用量</p>
<p>YGC、YGCT：年轻代GC次数和GC耗时</p>
<p>FGC、FGCT：Full GC次数和Full GC耗时</p>
<p>GCT：GC总耗时</p>
</blockquote>
<p><img src="http://i.imgur.com/uQntEKD.png" alt=""></p>
<p>###3  jinfo   </p>
<p>java配置信息工具</p>
<p>观察运行中的java程序的运行环境参数：参数包括Java System属性和JVM命令行参数</p>
<p>实例：jinfo 2083</p>
<p>其中2083就是java进程id号，可以用jps得到这个id号。</p>
<p>输出内容太多了，不在这里一一列举，大家可以自己尝试这个命令。</p>
<p>###4 jmap  Java内存映像工具<br> jmap（Memory Map）和  jhat（Java Heap Analysis Tool）<br> jmap用来查看堆内存使用状况，一般结合jhat使用。</p>
<p>###5.jhat 虚拟机堆转储快照分析工具</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/21/深入理解JVM笔记三/" itemprop="url">
                  深入理解JVM笔记三
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-10-21T14:30:38+08:00" content="2016-10-21">
              2016-10-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>内存分配策略</p>
<p>###1.对象有现在eden区分配。</p>
<p>大多数情况下，对象在新生代eden区中分配，当Eden区没有足够的空间分配，虚拟机将发起一次minor GC。<br>虚拟机提供<code>-XX：+PrintGCDetails</code>这个日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并在进程退出的时候输出当前的内存各区域分配的情况。</p>
<pre><code>public class aa{
        /**
         * -verbose:gc -Xms20M -Xms20M -Xmn10M -XX:+PrintGCDetails 
         * -XX:SurvivorRatio=8
         * 
         */
public static final int _1MB =1024*1024;
        public static void main(String[] args) {

            byte[] allocation1,allocation2,allocation3,allocation4;
            allocation1= new byte[2*_1MB];
            allocation2= new byte[2*_1MB];
            allocation3= new byte[2*_1MB];
            allocation4= new byte[3*_1MB];
        }
}
[GC (Allocation Failure) [PSYoungGen: 7128K-&gt;648K(9216K)] 7128K-&gt;6800K(19456K), 0.0030424 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (Ergonomics) [PSYoungGen: 648K-&gt;0K(9216K)] [ParOldGen: 6152K-&gt;6673K(27648K)] 6800K-&gt;6673K(36864K), [Metaspace: 2654K-&gt;2654K(1056768K)], 0.0070118 secs] [Times: user=0.06 sys=0.00, real=0.01 secs] 
Heap
 PSYoungGen      total 9216K, used 3154K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 38% used [0x00000000ff600000,0x00000000ff914930,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
 ParOldGen       total 27648K, used 6673K [0x0000000081c00000, 0x0000000083700000, 0x00000000ff600000)
  object space 27648K, 24% used [0x0000000081c00000,0x0000000082284408,0x0000000083700000)
 Metaspace       used 2660K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 288K, capacity 386K, committed 512K, reserved 1048576K
</code></pre><p>###2.对象直接进入老年代</p>
<p>虚拟机提供一个-XX:pertenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在eden取以及两个survivor区之间发生大量的内存复制。（新生代采用复制算法收集内存）</p>
<pre><code>public class aa{
        /**
         * -verbose:gc -Xms20M -Xms20M -Xmn10M -XX:+PrintGCDetails -XX:PertenureSizeThreshold=3145728
         * -XX:SurvivorRatio=8
         * 
         */
public static final int _1MB =1024*1024;
        public static void main(String[] args) {

            byte[] allocation4;
            allocation4= new byte[4*_1MB];
        }
}
</code></pre><p>###3.长期存活的对象将直接进入老年代</p>
<p>虚拟机给每个对象定义了一个age年龄计数器。如果对象在eden出生并经历了第一次minor gc仍然活着的话，并且能够被survivor容纳，警备移动大survivor空间，并且对象的年龄设为1.对于survivor中没熬过一次minor gc，年龄就增加1.当她的年龄增加到一定程度，默认是15，就会被净胜到老年代。对象净胜到老年代的年龄阈值通过参数-XX:MaxTenuringThreshold设置。</p>
<p>###4.动态对象年龄判定</p>
<p>为了更好地适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到阈值才能够到老年代，瑞国survivor中相同年龄所有对象的大小纸盒大于survivor空间的一般，年龄大于或等于改年龄的对象就可以进入老年代了。</p>
<p>###5.空间分配担保</p>
<p>在发生minor gc之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果这个条件成立，那么minor gc可以确保是安全的。如果不成立，虚拟机会查看handlepromotionfailure设置值食肉允许担保失败，如果允许，那么就会继续检查老年代中最大可用连续空间时都大于历次净胜到老年代对象的平均大小。如果大于，将尝试着进行一次minor gc，尽管这次minor gc是有风险的。如果小于，或者handlepromotionfailure设置不允许毛线，那么就要改为进行一次full gc。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Loren" />
          <p class="site-author-name" itemprop="name">Loren</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">55</span>
              <span class="site-state-item-name">Artikel</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">Kategorien</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">Tags</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Loren</span>
</div>

<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

  


</body>
</html>
