<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="lyp's blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.jpg?v=5.0.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="lyp's blog">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="lyp's blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lyp's blog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '3188510942',
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/5/"/>


  <title> lyp's blog </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">lyp's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/18/深入理解JVM笔记一/" itemprop="url">
                  深入理解JVM笔记一-java内存区域与内存溢出异常
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-18T15:03:57+08:00" content="2016-10-18">
              2016-10-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#自动内存管理机制</p>
<p>##java内存区域与内存溢出异常</p>
<p>###1.java虚拟机运行时数据区</p>
<p><img src="http://i.imgur.com/9y9f9Z1.png" alt=""></p>
<ul>
<li><p>程序计数器（Program Counter Register）</p>
<blockquote>
<p>它是一块较小的内存空间，它的作用可以看做是当先线程所执行的字节码的信号指示器。</p>
<p>每一条JVM线程都有自己的PC寄存器，各条线程之间互不影响，独立存储，这类内存区域被称为“线程私有”内存</p>
<p>在任意时刻，一条JVM线程只会执行一个方法的代码。该方法称为该线程的当前方法（Current Method）</p>
<p>如果该方法是java方法，那PC寄存器保存JVM正在执行的字节码指令的地址</p>
<p>如果该方法是native，那PC寄存器的值是undefined。</p>
<p>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
</blockquote>
</li>
<li><p>Java虚拟机栈（Java Virtual Machine Stack）</p>
<blockquote>
<p>与PC寄存器一样，Java虚拟机栈也是线程私有的。每一个JVM线程都有自己的java虚拟机栈，这个栈与线程同时创建，它的生命周期与线程相同。</p>
<p>虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>JVM stack 可以被实现成固定大小，也可以根据计算动态扩展。</p>
<p>如果采用固定大小的JVM stack设计，那么每一条线程的JVM Stack容量应该在线程创建时独立地选定。JVM实现应该提供调节JVM Stack初始容量的手段；如果采用动态扩展和收缩的JVM Stack方式，应该提供调节最大、最小容量的手段。</p>
<p>如果线程请求的栈深度大于虚拟机所允许的深度将抛出StackOverflowError；</p>
<p>如果JVM Stack可以动态扩展，但是在尝试扩展时无法申请到足够的内存时抛出OutOfMemoryError。</p>
</blockquote>
</li>
<li><p>本地方法栈（Native Method Stack）</p>
</li>
</ul>
<blockquote>
<p>本地方法栈与虚拟机栈作用相似，后者为虚拟机执行Java方法服务，而前者为虚拟机用到的Native方法服务。</p>
<p>虚拟机规范对于本地方法栈中方法使用的语言，使用方式和数据结构没有强制规定，甚至有的虚拟机（比如HotSpot）直接把二者合二为一。</p>
<p>这玩意儿抛出的异常跟上面的虚拟机栈一样。</p>
</blockquote>
<ul>
<li><p>Java堆（Java Heap）</p>
<blockquote>
<p>虚拟机管理的内存中最大的一块，同时也是被所有线程所共享的，它在虚拟机启动时创建，这货存在的意义就是存放对象实例，几乎所有的对象实例以及数组都要在这里分配内存。这里面的对象被自动管理，也就是俗称的GC（Garbage Collector）所管理。用就是了，有GC扛着呢，不用操心销毁回收的事儿。</p>
<p>Java堆的容量可以是固定大小，也可以随着需求动态扩展（-Xms和-Xmx），并在不需要过多空间时自动收缩。</p>
<p>Java堆所使用的内存不需要保证是物理连续的，只要逻辑上是连续的即可。</p>
<p>JVM实现应当提供给程序员调节Java 堆初始容量的手段，对于可动态扩展和收缩的堆来说，则应当提供调节其最大和最小容量的手段。</p>
<p>如果堆中没有内存完成实例分配并且堆也无法扩展，就会抛OutOfMemoryError。</p>
</blockquote>
</li>
<li><p>方法区（Method Area）</p>
<blockquote>
<p>跟堆一样是被<strong>各个线程共享的内存区域</strong>，用于存储以被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然这个区域被虚拟机规范把方法区描述为堆的一个逻辑部分，但是它的别名叫非堆，用来与堆做一下区别。</p>
<p>方法区在虚拟机启动的时候创建。</p>
<p>方法区的容量可以是固定大小的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩。</p>
<p>方法区在实际内存空间中可以是不连续的。</p>
<p>Java虚拟机实现应当提供给程序员或者最终用户调节方法区初始容量的手段，对于可以动态扩展和收缩方法区来说，则应当提供调节其最大、最小容量的手段。</p>
<p>当方法区无法满足内存分配需求时就会抛OutOfMemoryError。</p>
</blockquote>
</li>
<li><p>运行时常量池（Runtime Constant Pool）</p>
<blockquote>
<p>它是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<p>Java虚拟机对Class文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p>
<p>既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>
</blockquote>
</li>
</ul>
<p>###2.hotspot虚拟机对象探秘<br>1.对象的创建</p>
<p>new-&gt;检查这个指令参数是否能在常量池中定位到一个类的引用符号-&gt;判断这个类是否被加载、解析、初始化过-&gt;加载检查通过后，分配内存(指针碰撞，空闲列表)</p>
<p>-&gt;对分配内存空间的动作进行同步处理（CAS配上失败重试、TLAB）-&gt;虚拟机需要将分配到的内存空间都初始化为零值-&gt;对对象进行必要的设置</p>
<p>2.对象的内存布局</p>
<p>还Hotspot虚拟机中，对象的内存中存储的布局分为3块区域：对象头（header）、实例数据（Instance Data）、对其填充（Padding） </p>
<p>Hotspot虚拟机的对象头包括两部分信息，第一部分用于存储自身运行时的数据，例如：哈希码、GC分代年龄、锁状态标识、线程持有锁、偏向线程id、偏向时间戳，这部分数据数据长度在32位和64位的虚拟机（未开启指针压缩）中分别为32bit和64bit，官方称为’Mark word’。对象需要存储的运行时的数据非常多，已经超出了32位、64位bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关额外的存储成本，考虑到虚拟机的空间效率，Mark work被设计成一个非固定的数据结构以便在极小空间内存储尽可能多的信息，他会根据对象状态复用自己的存储空间。<br>对象头的另一部分是类型指针，即对象指向他的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个Java数组，那在对象中还必须有一块用于记录数组长度的数据，因为虚拟机可通过普通 Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。 </p>
<p>接下来的实例数据是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的还是在子类中定义的，都需要记录下来。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。Hotspot虚拟机的分配策略是相同宽度的字段总是被分配到一起。在满足这个前提条件下，在父类中定义的变量会出现在子类之前。</p>
<p>3.对象的访问定位</p>
<ul>
<li>句柄</li>
</ul>
<p>如果使用句柄访问的话，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据的具体各自的地址信息。如图1所示。<br><img src="http://i.imgur.com/xF8cz3T.jpg" alt=""></p>
<ul>
<li>直接指针</li>
</ul>
<p>如果使用直接指针访问的话，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如图2所示。<br><img src="http://i.imgur.com/7mWuClk.jpg" alt=""></p>
<p>###3.outofmemoryerror异常<br>1.java 堆溢出<br>2.虚拟机栈本地方法溢出<br>3.方法区和运行时常量池溢出<br>4.本机直接内存溢出</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/14/Ng机器学习notes1-weka相关算法实现/" itemprop="url">
                  Ng机器学习notes1+weka相关算法实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-14T12:30:14+08:00" content="2016-10-14">
              2016-10-14
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Andrew Ng的机器学习课程notes1.</p>
<p>参考链接：<a href="http://blog.csdn.net/qiao1245/article/details/50886247" target="_blank" rel="external">http://blog.csdn.net/qiao1245/article/details/50886247</a></p>
<p>主要内容是关于判别学习方法的，涉及到了梯度下降、随机梯度下降、最小二乘法、局部加权回归、极大似然原理、logistic regression、牛顿方法、广义线性模型、指数分布族。</p>
<p>##Ng机器学习笔记</p>
<p><strong>1.问题引入：房价预测</strong></p>
<p><img src="http://i.imgur.com/YVXqMDd.png" alt=""><br>我们可以将变量表示成X1，X2，然后结果表示为Y，那么Y和X之间存在一种映射关系，也就是说，我们可以通过X预测Y，假设二者之间关系是多元线性关系，形式上表述为：</p>
<p><img src="http://i.imgur.com/WhQcGmc.png" alt=""></p>
<p>H就是根据X对Y做出的估计，其中的参数θ是我们要求的量。<br>如何求得参数θ呢？我们可以利用损失函数的概念，损失函数表示了预测值与实际值之间的差距：</p>
<p><img src="http://i.imgur.com/b8rfDs0.png" alt=""></p>
<p>那么很显然，只要J（θ）最小化，那么θ就是最好的参数。那么我们下面就是使得J（θ）最小化，其中方法之一梯度下降方法。</p>
<p><strong>2.梯度下降</strong></p>
<p>什么是梯度？梯度是标量场中某一点上的梯度指向标量场增长最快的方向，梯度的长度是这个最大的变化率。因此，梯度方向是函数变化最快的地方。那么我们可以任意初始化θ，接下来就按照梯度方向进行调整θ只，就可以最快的到达最大值。 </p>
<p>可以得到更新θ规则，对于一个独立的样本，这种方法就是最小二乘法。 </p>
<p><img src="http://i.imgur.com/ovVDkP1.png" alt=""></p>
<p>扩展到M个样本，对J（θ）求偏导数，可以得到最终结果：<br><img src="http://i.imgur.com/aKxdpy0.png" alt=""><br>因此，梯度下降的过程就是不断地θ进行迭代，直到θ达到最大值为止<br><img src="http://i.imgur.com/3wQOxcE.png" alt=""><br>但是这样有一个很大的问题，就是每下降一步，就需要遍历整个数据集，这会导致巨大的计算量。因此，我们可以每次使用一条数据，就迭代一次，过程如下：<br><img src="http://i.imgur.com/tFXT2y1.png" alt=""><br>这样就会使得迭代过程并非一直是正向进行的，也就是可能会有向相反方向迭代的可能，但是总体还是向下的。这样还有一个问题，就是可能算法未必会收敛到最小值，而在最小值附近一直徘徊。但是最大的优点就是，快！</p>
<p>除了代数方法求得θ，我们还可以使用线性代数的方法直接求得θ参数，具体推导过程不再赘述，可以去看讲义，结果是：<br><img src="http://i.imgur.com/9bpMtTg.png" alt=""></p>
<p>这样虽然避免了计算，但是对矩阵求逆是比较慢的，而且这个方法要求X是满秩的，若不是满秩矩阵需要做处理。</p>
<p><strong>3.极大似然估计</strong></p>
<p>那么为什么采用平方和函数得到的θ就是最佳的呢？这里有对应的概率解释。对于一般的回归问题，我们可以将预测值和真实值之间表示为：<br><img src="http://i.imgur.com/H9SEMY1.png" alt=""></p>
<p><strong>4.局部加权回归</strong></p>
<p>有时候可能我们发现变量X和Y之间的关系并不是一种线性关系，但是在很小一段上，X和Y可以近似的看做线性关系，那么如何衡量这种关系呢？我们可以使用局部加权回归来解决这类问题，通过权重函数，我们可以距离目标值越远的点对整体影响越小。 </p>
<p>那么我们的问题可以化为：<br> <img src="http://i.imgur.com/cPk6OoJ.png" alt=""></p>
<p>其中，W可以表示为：<br><img src="http://i.imgur.com/7oueKN5.png" alt=""><br>这里面的τ被称为波长，用于控制权值随着距离变化的快慢。<br>那么我们像之前一样对问题进行求解。</p>
<p><strong>5.logistic回归</strong><br>有时候，我们的预测值并不是连续的，如满足伯努利分布，Y∈{0,1}，那么该怎么进行回归分析呢？<br>我们可以利用函数将连续值映射到0-1之间，一个函数就是： </p>
<p><img src="http://i.imgur.com/I20ojGR.png" alt=""></p>
<p><strong>6.牛顿方法</strong></p>
<p>除了梯度下降，还有一种牛顿方法可以对解空间进行搜索。示意图如下：<br><img src="http://i.imgur.com/NHm6GiT.png" alt=""></p>
<p>方法是先随机选一个点，求出该点的切线，延长它使之与 x 轴相<br>交，以相交时的 x 的值作为下一次迭代的值。<br>由于最大似然函数的性质，我们可以知道当导数为0时，求得θ最佳，那么我们可以得到更新规则：</p>
<p><img src="http://i.imgur.com/0ZTqRI2.png" alt=""></p>
<p>牛顿法的优点是收敛较快，但是有可能达不到最值。</p>
<p>##weka相关算法实现</p>
<p><strong>1.线性回归</strong></p>
<pre><code>weka.classifiers.functions.LinearRegression
Class for using linear regression for prediction. Uses the Akaike criterion for model selection, and is able to deal with weighted instances. 

 Valid options are: 
 -S &lt;number of selection method&gt;
  Set the attribute selection method to use. 1 = None, 2 = Greedy.
  (default 0 = M5&apos; method)

 -C
  Do not try to eliminate colinear attributes.

 -R &lt;double&gt;
  Set ridge parameter (default 1.0e-8).

 -minimal
  Conserve memory, don&apos;t keep dataset header and means/stdevs.
  Model cannot be printed out if this option is enabled. (default: keep data)

 -additional-stats
  Output additional statistics.

 -output-debug-info
  If set, classifier is run in debug mode and
  may output additional info to the console

 -do-not-check-capabilities
  If set, classifier capabilities are not checked before classifier is built
  (use with caution).

Version:$Revision: 12643 $Author:Eibe Frank (eibe@cs.waikato.ac.nz)Len Trigg (trigg@cs.waikato.ac.nz)
</code></pre><p><strong>2.逻辑回归</strong></p>
<p>Valid options are: </p>
<pre><code>-D
 Turn on debugging output.

-R &lt;ridge&gt;
 Set the ridge in the log-likelihood.

-M &lt;number&gt;
 Set the maximum number of iterations (default -1, until convergence).
</code></pre><p>参数比较少，其中-R用来调整迭代时θ对整个Cost函数的影响，默认是1E-8，-M是迭代的最大次数，如果指定为-1，则算法运行一直到收敛为止。<br>代码如下：</p>
<pre><code>class LogisticModel {

    public LogisticModel(Instances data) {
        String[] options={&quot;-M&quot;,20};
        Logistic model = new Logistic();
        try {
            model.setOptions(options);
            model.buildClassifier(data);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/13/mysql中tinyint-smallint-int-bigint区别/" itemprop="url">
                  mysql中tinyint.smallint.int.bigint区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-13T15:52:49+08:00" content="2016-10-13">
              2016-10-13
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>tinyint<br>从 -2^7 (-128) 到 2^7 - 1 (123) 的整型数据。存储大小为 1 个字节。<br>unsigned 是从 0 到 255 的整型数据。<br>所以建表的时候 只能是tinyint(3),哪怕你建tinyint(100)，他最大还是3位这么多。</p>
</li>
<li><p>smallint<br>从 -2^15 (-32,768) 到 2^15 - 1 (32,767) 的整型数据。存储大小为 2 个字节。<br>unsigned 是从 0 到 65535 的整型数据。<br>所以建表的时候 只能是smallint(5),哪怕你建smallint(100)，他最大还是5位这么多。</p>
</li>
<li><p>int<br>从 -2^31 (-2,147,483,648) 到 2^31 - 1 (2,147,483,647) 的整型数据（所有数字）.存储大小为 4 个字节。<br>unsigned 是从 0 到 4294967296 的整型数据。<br>所以建表的时候 只能是int(10),哪怕你建int(100)，他最大还是10位这么多。</p>
</li>
<li><p>bigint<br>从 -2^63 (-9,223,372,036,854,775,808) 到 2^63-1 (9,223,372,036,854,775,807) 的整型数据（所有数字）。存储大小为 8 个字节。<br>unsigned 是(自己算吧)</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/06/面向对象系统分析与设计/" itemprop="url">
                  面向对象系统分析与设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-06T17:02:48+08:00" content="2016-10-06">
              2016-10-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>####系统分析设计方法：</p>
<ul>
<li>结构化方法</li>
<li>信息建模法</li>
<li>面向对象分析设计方法</li>
</ul>
<p>面向对象的分析（Object Oriented Analysis，OOA）强调的是在问题域内发现和描述对象（或概念）。</p>
<p>面向对象的设计（ Object Oriented Design ，OOD）强调的是定义软件对象以它们是如何协作以实现需求</p>
<p>####面向对象的优点：</p>
<ul>
<li>复用<br>通过继承、关联、封装等手段</li>
<li>应变<br>弹性应对需求变化</li>
<li>沟通<br>开发人员、用户、管理人员</li>
<li>市场<br>应付市场的变化</li>
<li>士气<br>员工的士气</li>
</ul>
<p>使用OMT方法的面向对象开发过程可分为5步：</p>
<ul>
<li>分析</li>
<li>系统设计</li>
<li>对象设计</li>
<li>编代码</li>
<li>测试</li>
</ul>
<p>分为下述5个活动 </p>
<ul>
<li>编写问题陈述 </li>
<li>建立对象模型 </li>
<li>建立动态模型 </li>
<li>建立功能模型</li>
<li>细化对象模型、动态模型和功能模型，并建立文档</li>
</ul>
<p>系统设计的步骤如下：</p>
<ul>
<li>将系统划分为子系统 </li>
<li>识别并发 </li>
<li>将子系统和任务分配给处理器 </li>
<li>选择实现数据存储的策略 </li>
<li>识别出全局资源，并确定控制访问全局资源的机制 </li>
<li>选择实现软件控制的方法 </li>
<li>考虑边界条件 </li>
<li>建立折衷的优先级</li>
</ul>
<p>宏过程包括下述5个活动:</p>
<p>（1）概念化（Conceptualization）：在这个活动中，建立核心需求。<br>（2）分析（Analysis）：在这个活动中，为所期望的行为建立模型。<br>（3）设计（Design）：在这个活动中，建立体系结构。<br>（4）进化（Evolution）：在这个活动中，形成实现。<br>（5）维护（Maintenance）：在这个活动中，管理软件的交付使用。</p>
<p>微过程由4个步骤组成：</p>
<p>（1）在给定的抽象层次上识别出类和对象。<br>（2）识别出这些类和对象的语义。<br>（3）识别出类间和对象间的关系。<br>（4）实现类和对象。</p>
<p>####软件过程</p>
<p>软件过程定义了软件开发、部署和维护的步骤</p>
<ul>
<li><p>迭代式开发 </p>
<p> 迭代式开发将软件开发过程分解为一系列小的，固定周期的(比如，4个星期)的小项目，每个小项目称为一个迭代。</p>
</li>
<li><p>统一过程 (Unified Process)</p>
</li>
</ul>
<p>一种采用OOA/D方法学开发项目的过程(Ivar Jacobson)。<br>一种流行的构造面向对象系统的迭代开发过程（JBR99）。</p>
<ul>
<li>敏捷UP( Agile UP ) </li>
</ul>
<p>引入了敏捷概念的UP,是UP的一个简集。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/29/机器学习weka（三）/" itemprop="url">
                  机器学习weka（三）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-09-29T22:12:39+08:00" content="2016-09-29">
              2016-09-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/weka/" itemprop="url" rel="index">
                    <span itemprop="name">weka</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>模型序列化/持久化存储和加载</strong></p>
<p>有很多时候，你在构建了一个模型并完成调优后，你很可能会想把这个模型存入到磁盘中，免得下次再重新训练。尤其是神经网络、SVM等模型训练时间非常长，重新训练非常浪费时间。那么怎么持久化模型呢？<br>其实既然模型也是一个Java对象，那我就按照JAVA的序列化和反序列化方法保存模型对象即可。</p>
<p>以J48为例，进行序列化和存取</p>
<p>序列化：</p>
<pre><code>public static void persistModel(J48 model, String ModelPath) {
        ObjectOutputStream oos = null;
        try {
            oos = new ObjectOutputStream(
            new FileOutputStream(ModelPath));
            oos.writeObject(model);
            oos.flush();
            oos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
</code></pre><p>重新加载：</p>
<pre><code>public static J48 reloadPersistModel(String ModelPath) {
        ObjectInputStream ois = null;
        try {
            ois = new ObjectInputStream(
            new FileInputStream(new File(ModelPath)));
            J48 model = (J48) ois.readObject();
            return model;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/29/weka学习2/" itemprop="url">
                  机器学习weka（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-09-29T22:04:00+08:00" content="2016-09-29">
              2016-09-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/weka/" itemprop="url" rel="index">
                    <span itemprop="name">weka</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1.weka分类/回归模型构建与评价</strong></p>
<p>以最简单的决策树算法为例，在Weka中，决策树算法的实现是J48类，因此我们只需要创建J48对象就可以创建决策树。整个过程可以分为如下步骤： </p>
<p><strong>数据准备</strong></p>
<p>我们要做的就是加载数据，然后使用Filter对数据进行一定的操作，满足特定算法的需求。具体的将在决策树中讲解。</p>
<p><strong>模型配置</strong></p>
<p>在模型准备前，要对模型进行适当的配置，Weka中是通过传入Options数组来实现的，然后使用模型的setOptions(options)方法将模型配置信息传入</p>
<p><strong>模型学习</strong></p>
<p>模型学习过程就是使用训练数据对模型进行训练，在Weka中只需要调用模型的buildClassifier(data)方法即可。<br>上述三个过程可以用以下代码表示：</p>
<pre><code>class CARTModel {
    public CARTModel(Instances data) throws Exception{
        J48 model = new J48();
        String[] options = {&quot;-M&quot;,&quot;5&quot;,&quot;-R&quot;};
        model.setOptions(options);
        model.buildClassifier(data);
    }
}
</code></pre><p><strong>模型评价</strong></p>
<p>通过创建Evaluation对象来实现评价，具体代码如下：</p>
<pre><code>Evaluation eval = new Evaluation(testData);
 eval.crossValidateModel(model, trainSet, 10, new Random(1));
 System.out.println(eval.toSummaryString(&quot;\nResult&quot;, false));
 System.out.println(eval.toClassDetailsString());
</code></pre><p><strong>2.评价evaluation介绍</strong></p>
<p><strong>基本指标</strong></p>
<p>1、 FN：False Negative,被判定为负样本，但事实上是正样本。 </p>
<p>2、 FP：False Positive,被判定为正样本，但事实上是负样本。 </p>
<p>3、TN：True Negative,被判定为负样本，事实上也是负样本。 </p>
<p>4、TP：True Positive,被判定为正样本，事实上也是证样本。</p>
<p>5、precesion：查准率<br>即在检索后返回的结果中，真正正确的个数占整个结果的比例。precesion = TP/(TP+FP) 。 </p>
<p>6、 recall：查全率<br>即在检索结果中真正正确的个数 占整个数据集（检索到的和未检索到的）中真正正确个数的比例。recall = TP/(TP+FN)即，检索结果中，你判断为正的样本也确实为正的，以及那些没在检索结果中被你判断为负但是事实上是正的（FN）。</p>
<p>7、F-Measure<br>是Precision和Recall加权调和平均<br>P和R指标有时候会出现的矛盾的情况，这样就需要综合考虑他们，最常见的方法就是F-Measure（又称为F-Score）。 </p>
<p>8、MCC 马修斯相关系数<br>衡量不平衡数据集的指标比较好。</p>
<p><strong>ROC曲线</strong></p>
<p>ROC曲线的横坐标为false positive rate（FPR），纵坐标为 true positive rate（TPR）<br>当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变。根据每个测试样本属于正样本的概率值从大到小排序，依次将 “Score”值作为阈值threshold，当测试样本属于正样本的概率 大于或等于这个threshold时，认为它为正样本，否则为负样本。 </p>
<p><strong>PRC曲线</strong></p>
<p>在正负样本分布得极不均匀(highly skewed datasets)的情况下，PRC比ROC能更有效地反应分类器的好坏。 </p>
<p><strong>其他指标</strong></p>
<p>1、kappa statics Kappa<br>值即内部一致性系数(inter-rater,coefficient of internal consistency)，是作为评价判断的一致性程度的重要指标。取值在0～1之间。Kappa≥0.75两者一致性较好；0.75&gt;Kappa≥0.4两者一致性一般；Kappa&lt;0.4两者一致性较差。</p>
<p>2、Mean absolute error 和 Root mean squared error<br>平均绝对误差和均方根误差，用来衡量分类器预测值和实际结果的差异，越小越好。</p>
<p>3、Relative absolute error 和 Root relative squared error<br>相对绝对误差和相对均方根误差，有时绝对误差不能体现误差的真实大小，而相对误差通过体现误差占真值的比重来反映误差大小。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/29/weka1/" itemprop="url">
                  机器学习weka（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-09-29T20:39:32+08:00" content="2016-09-29">
              2016-09-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/weka/" itemprop="url" rel="index">
                    <span itemprop="name">weka</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>###机器学习weka（一）<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/09/29/weka1/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/25/Object类有哪些方法/" itemprop="url">
                  Object类有哪些方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-09-25T23:52:26+08:00" content="2016-09-25">
              2016-09-25
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ps：上周面试中科院，被问到object类有哪些方法。当时一脸懵逼没有反应过来，做以下记录。</p>
<pre><code>clone();
equals();
finalize();
getClass();
notify(),notifyAll();
hashCode();
toString();
wait();
</code></pre><p>摘要如下：</p>
<pre><code>protected  Object    clone() //创建并返回此对象的一个副本。
boolean    equals(Object obj) //指示某个其他对象是否与此对象“相等”。
protected  void    finalize() //当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。
Class&lt;? extends Object&gt;    getClass() //返回一个对象的运行时类。
int    hashCode() //返回该对象的哈希码值。
void    notify() //唤醒在此对象监视器上等待的单个线程。
void    notifyAll() //唤醒在此对象监视器上等待的所有线程。
String    toString()  //返回该对象的字符串表示。
void    wait() //导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。
void    wait(long timeout) //导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。
void    wait(long timeout, int nanos) //导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/25/java多线程/" itemprop="url">
                  java多线程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-09-25T23:43:30+08:00" content="2016-09-25">
              2016-09-25
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>线程和进程有什么区别？</p>
<p>答：一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。</p>
<p>如何在Java中实现线程？</p>
<p>答：<br>创建线程有两种方式：</p>
<ol>
<li>一、继承 Thread 类，扩展线程。</li>
<li>二、实现 Runnable 接口。</li>
</ol>
<p>启动一个线程是调用run()还是start()方法？</p>
<p>答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。</p>
<p>Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</p>
<ul>
<li>sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。</li>
<li>wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</li>
</ul>
<p>线程的sleep()方法和yield()方法有什么区别？</p>
<p>答：</p>
<ul>
<li>① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</li>
<li>② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；</li>
<li>③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；</li>
<li>④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。</li>
</ul>
<p>请说出与线程同步以及线程调度相关的方法。<br>答：</p>
<ul>
<li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</li>
<li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；</li>
<li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；</li>
<li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/25/oracle/" itemprop="url">
                  oracle
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-09-25T22:14:27+08:00" content="2016-09-25">
              2016-09-25
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>很少使用oracle，记录两个问题。</p>
<p>###1.在Maven仓库中添加Oracle JDBC驱动</p>
<p>由于Oracle授权问题，Maven不提供Oracle JDBC driver，为了在Maven项目中应用Oracle JDBC driver,必须手动添加到本地仓库。</p>
<p>1.获取oracle jdbc driver</p>
<ol>
<li>通过Oracle官方网站下载相应版本： <a href="http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html" target="_blank" rel="external">http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html</a></li>
<li>通过Oracle的安装目录获得，位置在“{ORACLE_HOME}\jdbc\lib\ojdbc14.jar</li>
</ol>
<p>2.安装到本地仓库</p>
<pre><code>mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=12.1.0.2 -Dpackaging=jar -Dfile=D:\Document_x64\Downloads\ojdbc14.jar
</code></pre><p>3.pom文件中添加引用</p>
<pre><code>&lt;dependency&gt;
&lt;groupId&gt;com.oracle&lt;/groupId&gt;
&lt;artifactId&gt;ojdbc7&lt;/artifactId&gt;
&lt;version&gt;12.1.0.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>###2. “ORA-00942: 表或视图不存在 “的原因和解决方法</p>
<p>产生的原因：<br>Oracle 是大小写敏感的，我们创自己写Sql脚本创建表的时候Oracle会自动将我们的表名，字段名转成大写,</p>
<pre><code>create table T_WindRadar  (
   wr_id                VARCHAR2(64)                    not null,
   wr_reciveTime        DATE,
   wr_image             BLOB,
   constraint PK_T_WINDRADAR primary key (wr_id)
);
</code></pre><p>但是 Oracle 同样支持”” 语法，将表名或字段名加上””后，Oracle不会将其转换成大写。</p>
<pre><code>create table &quot;T_WindRadar&quot;  (
   &quot;wr_id&quot;                VARCHAR2(64)                    not null,
   &quot;wr_reciveTime&quot;        DATE,
   &quot;wr_image &quot;            BLOB,
   constraint PK_T_WINDRADAR primary key (wr_id)
);
</code></pre><p>如果加上了””,那么我们采用一般的SQL语句查询则会产生“ORA-00942: 表或视图不存在 ”，因此SQL脚本中需要将表名也加上””。</p>
<pre><code>select * from  &quot;T_WindRadar&quot;;
</code></pre><p>这种情况在我们手写SQL的时候一般不会发生，但是我们使用powerdesigner设计数据库的时候，由于不注意会经常出现此类问题，因为Powerdesigner生成的SQL文件默认是加””的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Loren" />
          <p class="site-author-name" itemprop="name">Loren</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">74</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">34</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Loren</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

  


</body>
</html>
